From ede8ca7645a53567b346cd4513ff27f370005a07 Mon Sep 17 00:00:00 2001
From: Kasper Kopec <kasper@fb.com>
Date: Mon, 15 Aug 2016 16:49:46 -0700
Subject: [PATCH] Fix hh_server Out of Memory Error.

Summary:

Huge squashed commit. FB broke something on hack and we got a Out of Memory
error on HHVM-3.15.1 tag on POWER. Commit eb1cba9 fix the error but there lots
of dependency with other commit. Hack build is painful.
---
 hphp/doc/extension.new_functions                   |   1 +
 hphp/hack/hhi/experimental/interfaces.hhi          |   2 +-
 hphp/hack/hhi/functions.hhi                        |   3 +
 hphp/hack/hhi/stdlib/builtins_debugger.hhi         |   1 +
 hphp/hack/hhi/stdlib/builtins_function.hhi         |   2 -
 hphp/hack/hhi/stdlib/builtins_prof.hhi             |   8 +-
 hphp/hack/src/Makefile                             |   2 +
 hphp/hack/src/client/clientAiInfo.ml               |   2 +-
 hphp/hack/src/client/clientArgs.ml                 |   4 -
 hphp/hack/src/client/clientBuild.ml                |   2 +-
 hphp/hack/src/client/clientCheck.ml                |  10 +-
 hphp/hack/src/client/clientConnect.ml              |   2 +-
 hphp/hack/src/client/clientCoverageMetric.mli      |   2 +-
 hphp/hack/src/client/clientFindDependentFiles.ml   |   3 +-
 hphp/hack/src/client/clientIde.ml                  |  21 +-
 hphp/hack/src/client/clientLint.ml                 |   2 +-
 hphp/hack/src/client/clientRefactor.ml             |  36 +-
 hphp/hack/src/client/clientSymbolInfo.ml           |   8 +-
 hphp/hack/src/decl/decl.ml                         |  20 +-
 hphp/hack/src/decl/decl.mli                        |   2 +
 hphp/hack/src/decl/decl_pos_utils.ml               |   1 +
 hphp/hack/src/decl/decl_redecl_service.ml          |   2 +-
 hphp/hack/src/emitter/emitter_consts.ml            |   4 +-
 .../full_fidelity_declaration_parser.ml            | 108 +++++-
 .../full_fidelity_expression_parser.ml             | 166 +++++---
 hphp/hack/src/full_fidelity/full_fidelity_lexer.ml |  15 +
 .../hack/src/full_fidelity/full_fidelity_lexer.mli |   1 +
 .../src/full_fidelity/full_fidelity_lexer_sig.ml   |   1 +
 .../src/full_fidelity/full_fidelity_operator.ml    |  49 +--
 .../full_fidelity/full_fidelity_parser_helpers.ml  |  78 +++-
 .../full_fidelity_precedence_parser.ml             |  12 +-
 .../full_fidelity/full_fidelity_pretty_printer.ml  |  46 ++-
 .../full_fidelity_statement_parser.ml              |  40 +-
 .../hack/src/full_fidelity/full_fidelity_syntax.ml | 217 +++++++++--
 .../full_fidelity/full_fidelity_syntax_error.ml    |   5 +-
 .../src/full_fidelity/full_fidelity_syntax_kind.ml |  12 +
 .../src/full_fidelity/full_fidelity_token_kind.ml  |  11 +
 .../src/full_fidelity/full_fidelity_type_lexer.ml  |   1 +
 .../src/full_fidelity/full_fidelity_type_parser.ml |  38 +-
 .../src/full_fidelity/hack_grammar_descriptor.ml   |  14 +-
 hphp/hack/src/h2tp/engine.ml                       |   2 +-
 hphp/hack/src/heap/hh_shared.c                     |  56 ++-
 hphp/hack/src/heap/sharedMem.ml                    |  29 +-
 hphp/hack/src/heap/sharedMem.mli                   |   8 +-
 hphp/hack/src/hh_single_type_check.ml              |  70 +++-
 hphp/hack/src/hhas/hhasBytecodeIst.ml              | 182 +++++++++
 hphp/hack/src/hhas/hhasBytecodePp.ml               | 430 +++++++++++++++++++++
 hphp/hack/src/hhas/shared/bufferedPrinter.ml       |  61 +++
 hphp/hack/src/hhas/shared/sharedCollections.ml     | 250 ++++++++++++
 .../injection/default_injector/injector_config.ml  |   1 +
 hphp/hack/src/injection/injector_config.mli        |   1 +
 .../src/injection/test_injector/injector_config.ml |   2 +
 .../injection/test_injector/injector_config.mli    |   1 +
 hphp/hack/src/monitor/serverMonitor.ml             |  28 +-
 hphp/hack/src/monitor/serverMonitorUtils.ml        |   6 +
 hphp/hack/src/monitor/serverProcessTools.ml        |  10 +-
 hphp/hack/src/naming/naming.ml                     |  11 +-
 hphp/hack/src/naming/naming_special_names.ml       |   3 +
 hphp/hack/src/naming/typecheckerOptions.ml         |  16 +-
 hphp/hack/src/parsing/namespaces.ml                |   2 +
 hphp/hack/src/parsing/parsing_service.ml           |  12 +-
 hphp/hack/src/parsing/parsing_service.mli          |   2 +-
 hphp/hack/src/procs/worker.ml                      |  13 +-
 hphp/hack/src/search/fuzzySearchService.ml         |   2 +-
 hphp/hack/src/search/hackSearchService.ml          |   3 +
 hphp/hack/src/server/clientProvider.ml             |   4 +
 hphp/hack/src/server/clientProvider.mli            |   1 +
 hphp/hack/src/server/clientProvider_sig.ml         |  32 ++
 hphp/hack/src/server/diagnostic_subscription.ml    |  19 +
 hphp/hack/src/server/diagnostic_subscription.mli   |  15 +
 hphp/hack/src/server/findRefsService.ml            |  29 +-
 hphp/hack/src/server/hhServerMonitor.ml            |  33 +-
 hphp/hack/src/server/identifySymbolService.ml      |   3 +
 hphp/hack/src/server/inferAtPosService.ml          |   2 +
 hphp/hack/src/server/methodJumps.ml                |   4 +-
 hphp/hack/src/server/serverBuild.ml                |   5 +-
 hphp/hack/src/server/serverCheckUtils.ml           |   2 +-
 hphp/hack/src/server/serverCheckpoint.ml           |   2 +-
 hphp/hack/src/server/serverClientProvider.ml       | 116 ++++++
 hphp/hack/src/server/serverColorFile.ml            |   2 -
 hphp/hack/src/server/serverCommand.ml              |  76 +---
 hphp/hack/src/server/serverCommandTypes.ml         |  73 ++++
 hphp/hack/src/server/serverConfig.ml               |  19 +-
 hphp/hack/src/server/serverConfig.mli              |   2 +-
 hphp/hack/src/server/serverCoverageMetric.ml       |   6 +-
 hphp/hack/src/server/serverCoverageMetricTypes.ml  |  12 +
 hphp/hack/src/server/serverEnv.ml                  |  10 +-
 hphp/hack/src/server/serverEnvBuild.ml             |   9 +-
 hphp/hack/src/server/serverFindRefs.ml             |   9 +
 hphp/hack/src/server/serverHighlightRefs.ml        |   3 +-
 hphp/hack/src/server/serverHighlightRefs.mli       |   8 +-
 hphp/hack/src/server/serverHighlightRefsTypes.ml   |  11 +
 hphp/hack/src/server/serverIdeUtils.ml             |  56 +--
 hphp/hack/src/server/serverIdentifyFunction.ml     |   3 -
 hphp/hack/src/server/serverInferType.ml            |   2 -
 hphp/hack/src/server/serverInit.ml                 |  24 +-
 hphp/hack/src/server/serverInit.mli                |   2 +
 hphp/hack/src/server/serverLint.ml                 |   2 -
 hphp/hack/src/server/serverLintTypes.ml            |  11 +
 hphp/hack/src/server/serverMain.ml                 | 280 +++++++-------
 hphp/hack/src/server/serverMain.mli                |  15 +-
 hphp/hack/src/server/serverRefactor.ml             |  17 +-
 hphp/hack/src/server/serverRefactorTypes.ml        |  25 ++
 hphp/hack/src/server/serverRpc.ml                  | 140 +++----
 hphp/hack/src/server/serverSearch.ml               |   3 -
 hphp/hack/src/server/serverTypeCheck.ml            |  54 ++-
 hphp/hack/src/server/serverTypeCheck.mli           |   4 +-
 hphp/hack/src/server/serverUtils.ml                |   3 +
 hphp/hack/src/server/symbolInfoService.ml          |   6 +-
 hphp/hack/src/server/symbolInfoServiceTypes.ml     |  14 +
 hphp/hack/src/server/symbolTypeService.ml          |   2 +-
 hphp/hack/src/server/testClientProvider.ml         | 132 +++++++
 hphp/hack/src/stubs/ai.ml                          |   2 +
 hphp/hack/src/stubs/buildMain.ml                   |   2 +-
 hphp/hack/src/stubs/hackEventLogger.ml             |   5 +-
 hphp/hack/src/typed_ast/typed_ast.ml               |  27 ++
 hphp/hack/src/typed_ast/typed_ast_defs.ml          |  14 +
 hphp/hack/src/typed_ast/typed_ast_printer.ml       | 174 +++++++++
 hphp/hack/src/typing/coverage_level.ml             |   5 +-
 hphp/hack/src/typing/typing.ml                     |  73 +++-
 hphp/hack/src/typing/typing.mli                    |   2 +
 hphp/hack/src/typing/typing_dependent_type.ml      |   8 +-
 hphp/hack/src/typing/typing_enum.ml                |   6 +-
 hphp/hack/src/typing/typing_env.ml                 |   4 +
 hphp/hack/src/typing/typing_env.mli                |   1 +
 hphp/hack/src/typing/typing_extends.ml             |  52 ++-
 hphp/hack/src/typing/typing_reason.ml              |   4 +
 hphp/hack/src/typing/typing_suggest_service.ml     |   4 +-
 hphp/hack/src/typing/typing_unify.ml               |   8 +-
 hphp/hack/src/typing/typing_utils.ml               |   9 +
 hphp/hack/src/typing/typing_variance.ml            |  57 ++-
 hphp/hack/src/utils/collections/myMap.ml           |  37 +-
 hphp/hack/src/utils/collections/myMap.mli          |  38 +-
 hphp/hack/src/utils/collections/myMap_sig.ml       |  23 ++
 .../collections/reordered_argument_collections.ml  |   7 +
 hphp/hack/src/utils/diagnostic_subscription.ml     |  36 --
 hphp/hack/src/utils/diagnostic_subscription.mli    |  21 -
 hphp/hack/src/utils/disk/disk.ml                   |   8 +
 hphp/hack/src/utils/disk/disk.mli                  |   1 +
 hphp/hack/src/utils/disk/disk_sig.ml               |   3 +
 hphp/hack/src/utils/disk/realDisk.ml               |   8 +
 hphp/hack/src/utils/disk/testDisk.ml               |   4 +
 hphp/hack/src/utils/disk/testDisk.mli              |   2 +
 hphp/hack/src/utils/errors.ml                      |  80 ++--
 hphp/hack/src/utils/errors_sig.ml                  |   2 +
 hphp/hack/src/utils/exit_status.ml                 |   7 +
 hphp/hack/src/utils/file_content.ml                |   4 -
 hphp/hack/src/utils/file_content.mli               |   4 -
 hphp/hack/src/utils/measure.ml                     |   4 +-
 hphp/hack/src/utils/relative_path.ml               |   2 +-
 hphp/hack/src/utils/sys_utils.ml                   |  19 +-
 hphp/hack/src/utils/tty.ml                         |  14 +-
 hphp/hack/src/utils/tty.mli                        |   8 +-
 hphp/hack/src/utils/utils.ml                       |   4 +-
 hphp/hack/test/find_refs/global_const.flags        |   1 +
 hphp/hack/test/find_refs/global_const.php          |   7 +
 hphp/hack/test/find_refs/global_const.php.exp      |   1 +
 .../cases/test_array_key_value_precedence.exp      |   2 +-
 .../cases/test_array_key_value_precedence.php      |   2 +-
 .../full_fidelity/cases/test_function_call.exp     |   4 +-
 .../cases/test_inclusion_directive.exp             |  52 +++
 .../cases/test_inclusion_directive.php             |  11 +
 .../full_fidelity/cases/test_list_precedence.exp   |  10 +-
 .../test/full_fidelity/cases/test_statements.exp   |   6 +-
 .../test/full_fidelity/full_fidelity_unit_test.ml  |   1 +
 .../test/h2tp/convert_hack_test_inputs_base.py     |   2 +
 hphp/hack/test/highlight_refs/global_const.flags   |   1 +
 hphp/hack/test/highlight_refs/global_const.php     |   8 +
 hphp/hack/test/highlight_refs/global_const.php.exp |   2 +
 .../test/identify_symbol/global_const_assign.php   |   3 +-
 .../identify_symbol/global_const_assign.php.exp    |   6 +-
 .../test/identify_symbol/special_function.php.exp  |   4 +-
 .../test/incremental/test_inconsistent_state.ml    |  75 ++++
 hphp/hack/test/incremental/test_method_override.ml |  86 +++++
 hphp/hack/test/integration/common_tests.py         | 169 --------
 .../integration_ml/ide/test_ide_consistency.ml     |  95 +++++
 .../ide/test_ide_diagnostic_subscription.ml        |  52 +++
 hphp/hack/test/integration_ml/ide/test_ide_disk.ml | 112 ++++++
 .../test/integration_ml/ide/test_ide_file_sync.ml  |  95 +++++
 .../integration_ml/ide/test_identify_symbol.ml     |  62 +++
 .../test/integration_ml/integration_test_base.ml   | 104 +++++
 .../test/integration_ml/integration_test_base.mli  |  26 ++
 .../integration_ml/integration_test_base_types.ml  |  29 ++
 hphp/hack/test/integration_ml/test_delete_file.ml  |  46 +++
 .../test/integration_ml/test_duplicate_parent.ml   |  70 ++++
 .../test/integration_ml/test_duplicated_file.ml    |  44 +++
 hphp/hack/test/integration_ml/test_failed_decl.ml  |  68 ++++
 hphp/hack/test/integration_ml/test_modify_file.ml  |  46 +++
 hphp/hack/test/integration_ml/test_new_file.ml     |  34 ++
 .../test/typecheck/class_as_class_constant.php     |  14 +
 .../test/typecheck/class_as_class_constant.php.exp |   2 +
 .../class_as_class_constant.php.no_format          |   0
 .../hack/test/typecheck/class_as_enum_constant.php |  15 +
 .../test/typecheck/class_as_enum_constant.php.exp  |   2 +
 .../typecheck/class_as_enum_constant.php.no_format |   0
 .../test/typecheck/class_as_enum_constant2.php     |  15 +
 .../test/typecheck/class_as_enum_constant2.php.exp |   2 +
 .../class_as_enum_constant2.php.no_format          |   0
 hphp/hack/test/typecheck/contravariant_this1.php   |   6 +
 .../test/typecheck/contravariant_this1.php.exp     |   2 +
 hphp/hack/test/typecheck/contravariant_this2.php   |   6 +
 .../test/typecheck/contravariant_this2.php.exp     |   2 +
 .../test/typecheck/contravariant_this2.php.out     |   2 +
 hphp/hack/test/typecheck/contravariant_this3.php   |  11 +
 .../test/typecheck/contravariant_this3.php.exp     |   2 +
 .../typecheck/contravariant_this3.php.format_out   |   8 +
 .../test/typecheck/contravariant_this3.php.out     |   2 +
 hphp/hack/test/typecheck/keyset/is_keyset.php      |   9 +
 hphp/hack/test/typecheck/keyset/is_keyset.php.exp  |   1 +
 hphp/hack/test/typecheck/keyset/is_keyset_fail.php |   9 +
 .../test/typecheck/keyset/is_keyset_fail.php.exp   |  10 +
 .../test/typecheck/keyset/must_be_arraykey.php.exp |   4 +-
 hphp/hack/test/typecheck/override_attr_08.php.exp  |   2 +-
 hphp/hack/test/typecheck/override_attr_09.php.exp  |   2 +-
 .../type_structure/type_structure2.php.exp         |   2 +-
 .../type_structure/type_structure3.php.exp         |   2 +-
 .../type_structure/type_structure5.php.exp         |   2 +-
 hphp/hack/test/typecheck/typing_fail_inherit2.php  |   4 +-
 hphp/hack/test/typed_ast/binary_op.php             |   5 +
 hphp/hack/test/typed_ast/binary_op.php.exp         |   8 +
 hphp/hack/test/typed_ast/class_types.php           |  12 +
 hphp/hack/test/typed_ast/class_types.php.exp       |  13 +
 hphp/hack/test/typed_ast/function_call.php         |   8 +
 hphp/hack/test/typed_ast/function_call.php.exp     |  13 +
 .../hack/test/typed_ast/loop_analysis_aliasing.php |  14 +
 .../test/typed_ast/loop_analysis_aliasing.php.exp  |  22 ++
 hphp/hack/test/typed_ast/null_type.php             |  14 +
 hphp/hack/test/typed_ast/null_type.php.exp         |  19 +
 hphp/hack/test/typed_ast/prim_unresolved.php       |  12 +
 hphp/hack/test/typed_ast/prim_unresolved.php.exp   |  21 +
 hphp/hack/test/unit/heap/test_hashtbl.ml           | 209 ++++++++++
 hphp/hack/test/unit/ide/ide_file_content_test.ml   |  24 --
 hphp/runtime/base/file-util.cpp                    |  21 +
 hphp/runtime/base/file-util.h                      |   2 +
 hphp/runtime/base/header-kind.h                    |   7 +-
 hphp/runtime/base/heap-collect.cpp                 |  40 +-
 hphp/runtime/base/heap-graph.cpp                   |   2 +-
 hphp/runtime/base/heap-report.cpp                  |   4 +-
 hphp/runtime/base/heap-scan.h                      |   8 +-
 hphp/runtime/base/memory-manager-defs.h            |  27 +-
 hphp/runtime/base/memory-manager.cpp               |   8 +-
 hphp/runtime/base/memory-manager.h                 |   2 +-
 hphp/runtime/base/runtime-option.cpp               |   3 +
 hphp/runtime/base/runtime-option.h                 |   1 +
 hphp/runtime/debugger/cmd/all.h                    |   1 +
 hphp/runtime/debugger/cmd/cmd_auth.cpp             |  55 +++
 hphp/runtime/debugger/cmd/cmd_auth.h               |  45 +++
 hphp/runtime/debugger/debugger_client.cpp          |   7 +-
 hphp/runtime/debugger/debugger_command.cpp         |   1 +
 hphp/runtime/debugger/debugger_command.h           |   1 +
 hphp/runtime/debugger/debugger_proxy.cpp           |  31 ++
 hphp/runtime/debugger/debugger_proxy.h             |   2 +
 hphp/runtime/debugger/dummy_sandbox.cpp            |  24 +-
 .../ext/asio/ext_async-function-wait-handle.h      |   2 +-
 hphp/runtime/ext/debugger/ext_debugger.cpp         |  10 +
 hphp/runtime/ext/debugger/ext_debugger.h           |   1 +
 hphp/runtime/ext/debugger/ext_debugger.php         |   6 +
 hphp/runtime/ext/objprof/ext_heapgraph.cpp         |   4 +-
 .../php-src/ext/standard/basic_functions.h         |   2 -
 hphp/runtime/vm/resumable.h                        |   2 +-
 260 files changed, 5168 insertions(+), 1269 deletions(-)
 create mode 100644 hphp/hack/src/hhas/hhasBytecodeIst.ml
 create mode 100644 hphp/hack/src/hhas/hhasBytecodePp.ml
 create mode 100644 hphp/hack/src/hhas/shared/bufferedPrinter.ml
 create mode 100644 hphp/hack/src/hhas/shared/sharedCollections.ml
 create mode 100644 hphp/hack/src/injection/test_injector/injector_config.ml
 create mode 120000 hphp/hack/src/injection/test_injector/injector_config.mli
 create mode 100644 hphp/hack/src/server/clientProvider.ml
 create mode 100644 hphp/hack/src/server/clientProvider.mli
 create mode 100644 hphp/hack/src/server/clientProvider_sig.ml
 create mode 100644 hphp/hack/src/server/diagnostic_subscription.ml
 create mode 100644 hphp/hack/src/server/diagnostic_subscription.mli
 create mode 100644 hphp/hack/src/server/serverClientProvider.ml
 create mode 100644 hphp/hack/src/server/serverCommandTypes.ml
 create mode 100644 hphp/hack/src/server/serverCoverageMetricTypes.ml
 create mode 100644 hphp/hack/src/server/serverHighlightRefsTypes.ml
 create mode 100644 hphp/hack/src/server/serverLintTypes.ml
 create mode 100644 hphp/hack/src/server/serverRefactorTypes.ml
 create mode 100644 hphp/hack/src/server/symbolInfoServiceTypes.ml
 create mode 100644 hphp/hack/src/server/testClientProvider.ml
 create mode 100644 hphp/hack/src/typed_ast/typed_ast.ml
 create mode 100644 hphp/hack/src/typed_ast/typed_ast_defs.ml
 create mode 100644 hphp/hack/src/typed_ast/typed_ast_printer.ml
 create mode 100644 hphp/hack/src/utils/collections/myMap_sig.ml
 delete mode 100644 hphp/hack/src/utils/diagnostic_subscription.ml
 delete mode 100644 hphp/hack/src/utils/diagnostic_subscription.mli
 create mode 100644 hphp/hack/src/utils/disk/disk.ml
 create mode 100644 hphp/hack/src/utils/disk/disk.mli
 create mode 100644 hphp/hack/src/utils/disk/disk_sig.ml
 create mode 100644 hphp/hack/src/utils/disk/realDisk.ml
 create mode 100644 hphp/hack/src/utils/disk/testDisk.ml
 create mode 100644 hphp/hack/src/utils/disk/testDisk.mli
 create mode 100644 hphp/hack/test/find_refs/global_const.flags
 create mode 100644 hphp/hack/test/find_refs/global_const.php
 create mode 100644 hphp/hack/test/find_refs/global_const.php.exp
 create mode 100644 hphp/hack/test/full_fidelity/cases/test_inclusion_directive.exp
 create mode 100644 hphp/hack/test/full_fidelity/cases/test_inclusion_directive.php
 create mode 100644 hphp/hack/test/highlight_refs/global_const.flags
 create mode 100644 hphp/hack/test/highlight_refs/global_const.php
 create mode 100644 hphp/hack/test/highlight_refs/global_const.php.exp
 create mode 100644 hphp/hack/test/incremental/test_inconsistent_state.ml
 create mode 100644 hphp/hack/test/incremental/test_method_override.ml
 create mode 100644 hphp/hack/test/integration_ml/ide/test_ide_consistency.ml
 create mode 100644 hphp/hack/test/integration_ml/ide/test_ide_diagnostic_subscription.ml
 create mode 100644 hphp/hack/test/integration_ml/ide/test_ide_disk.ml
 create mode 100644 hphp/hack/test/integration_ml/ide/test_ide_file_sync.ml
 create mode 100644 hphp/hack/test/integration_ml/ide/test_identify_symbol.ml
 create mode 100644 hphp/hack/test/integration_ml/integration_test_base.ml
 create mode 100644 hphp/hack/test/integration_ml/integration_test_base.mli
 create mode 100644 hphp/hack/test/integration_ml/integration_test_base_types.ml
 create mode 100644 hphp/hack/test/integration_ml/test_delete_file.ml
 create mode 100644 hphp/hack/test/integration_ml/test_duplicate_parent.ml
 create mode 100644 hphp/hack/test/integration_ml/test_duplicated_file.ml
 create mode 100644 hphp/hack/test/integration_ml/test_failed_decl.ml
 create mode 100644 hphp/hack/test/integration_ml/test_modify_file.ml
 create mode 100644 hphp/hack/test/integration_ml/test_new_file.ml
 create mode 100644 hphp/hack/test/typecheck/class_as_class_constant.php
 create mode 100644 hphp/hack/test/typecheck/class_as_class_constant.php.exp
 create mode 100644 hphp/hack/test/typecheck/class_as_class_constant.php.no_format
 create mode 100644 hphp/hack/test/typecheck/class_as_enum_constant.php
 create mode 100644 hphp/hack/test/typecheck/class_as_enum_constant.php.exp
 create mode 100644 hphp/hack/test/typecheck/class_as_enum_constant.php.no_format
 create mode 100644 hphp/hack/test/typecheck/class_as_enum_constant2.php
 create mode 100644 hphp/hack/test/typecheck/class_as_enum_constant2.php.exp
 create mode 100644 hphp/hack/test/typecheck/class_as_enum_constant2.php.no_format
 create mode 100644 hphp/hack/test/typecheck/contravariant_this1.php
 create mode 100644 hphp/hack/test/typecheck/contravariant_this1.php.exp
 create mode 100644 hphp/hack/test/typecheck/contravariant_this2.php
 create mode 100644 hphp/hack/test/typecheck/contravariant_this2.php.exp
 create mode 100644 hphp/hack/test/typecheck/contravariant_this2.php.out
 create mode 100644 hphp/hack/test/typecheck/contravariant_this3.php
 create mode 100644 hphp/hack/test/typecheck/contravariant_this3.php.exp
 create mode 100644 hphp/hack/test/typecheck/contravariant_this3.php.format_out
 create mode 100644 hphp/hack/test/typecheck/contravariant_this3.php.out
 create mode 100644 hphp/hack/test/typecheck/keyset/is_keyset.php
 create mode 100644 hphp/hack/test/typecheck/keyset/is_keyset.php.exp
 create mode 100644 hphp/hack/test/typecheck/keyset/is_keyset_fail.php
 create mode 100644 hphp/hack/test/typecheck/keyset/is_keyset_fail.php.exp
 create mode 100644 hphp/hack/test/typed_ast/binary_op.php
 create mode 100644 hphp/hack/test/typed_ast/binary_op.php.exp
 create mode 100644 hphp/hack/test/typed_ast/class_types.php
 create mode 100644 hphp/hack/test/typed_ast/class_types.php.exp
 create mode 100644 hphp/hack/test/typed_ast/function_call.php
 create mode 100644 hphp/hack/test/typed_ast/function_call.php.exp
 create mode 100644 hphp/hack/test/typed_ast/loop_analysis_aliasing.php
 create mode 100644 hphp/hack/test/typed_ast/loop_analysis_aliasing.php.exp
 create mode 100644 hphp/hack/test/typed_ast/null_type.php
 create mode 100644 hphp/hack/test/typed_ast/null_type.php.exp
 create mode 100644 hphp/hack/test/typed_ast/prim_unresolved.php
 create mode 100644 hphp/hack/test/typed_ast/prim_unresolved.php.exp
 create mode 100644 hphp/hack/test/unit/heap/test_hashtbl.ml
 create mode 100644 hphp/runtime/debugger/cmd/cmd_auth.cpp
 create mode 100644 hphp/runtime/debugger/cmd/cmd_auth.h

diff --git a/hphp/doc/extension.new_functions b/hphp/doc/extension.new_functions
index d909cab..aa2b14e 100644
--- a/hphp/doc/extension.new_functions
+++ b/hphp/doc/extension.new_functions
@@ -15,6 +15,7 @@ testing and some alternative PHP implementation.
 - hphp_thread_set_warmup_enabled
 - hphp_get_thread_id
 
+- hphpd_auth_token
 - hphpd_install_user_command
 - hphpd_get_user_commands
 - hphpd_break
diff --git a/hphp/hack/hhi/experimental/interfaces.hhi b/hphp/hack/hhi/experimental/interfaces.hhi
index 0625fc0..e3740bf 100644
--- a/hphp/hack/hhi/experimental/interfaces.hhi
+++ b/hphp/hack/hhi/experimental/interfaces.hhi
@@ -10,4 +10,4 @@
  */
 
 abstract final class dict<+Tk, +Tv> implements Indexish<Tk, Tv> {}
-abstract final class keyset<T as arraykey> implements Indexish<T, T> {}
+abstract final class keyset<+T as arraykey> implements Indexish<T, T> {}
diff --git a/hphp/hack/hhi/functions.hhi b/hphp/hack/hhi/functions.hhi
index bf61d5d..298000f 100644
--- a/hphp/hack/hhi/functions.hhi
+++ b/hphp/hack/hhi/functions.hhi
@@ -31,6 +31,9 @@ function func_get_args(): array;
 function implode(string $glue, $pieces): string; // could be Container<Stringish>
 function explode(string $delimiter, ?Stringish $str, int $limit = 0x7FFFFFFF): array; // : array<string> & false for '' delimiter
 function is_array(mixed $arg): bool;
+function is_vec(mixed $arg): bool;
+function is_dict(mixed $arg): bool;
+function is_keyset(mixed $arg): bool;
 function ord(string $string): int;
 function strip_tags(string $str, string $allowable_tags = ''): string;
 
diff --git a/hphp/hack/hhi/stdlib/builtins_debugger.hhi b/hphp/hack/hhi/stdlib/builtins_debugger.hhi
index fecb8ae..41bdd02 100644
--- a/hphp/hack/hhi/stdlib/builtins_debugger.hhi
+++ b/hphp/hack/hhi/stdlib/builtins_debugger.hhi
@@ -9,6 +9,7 @@
  *
  */
 function hphpd_install_user_command($cmd, $clsname);
+function hphpd_auth_token(): string;
 function hphpd_get_user_commands();
 function hphpd_break(bool $condition = true): void;
 function hphp_debugger_attached(): bool;
diff --git a/hphp/hack/hhi/stdlib/builtins_function.hhi b/hphp/hack/hhi/stdlib/builtins_function.hhi
index af2f7b0..5fdd6a2 100644
--- a/hphp/hack/hhi/stdlib/builtins_function.hhi
+++ b/hphp/hack/hhi/stdlib/builtins_function.hhi
@@ -23,5 +23,3 @@ function func_get_arg(int $arg_num);
 function func_num_args(): int;
 function register_postsend_function($function, ...);
 function register_shutdown_function($function, ...);
-function register_tick_function($function, ...);
-function unregister_tick_function($function_name);
diff --git a/hphp/hack/hhi/stdlib/builtins_prof.hhi b/hphp/hack/hhi/stdlib/builtins_prof.hhi
index f30c6a0..0f4c7c3 100644
--- a/hphp/hack/hhi/stdlib/builtins_prof.hhi
+++ b/hphp/hack/hhi/stdlib/builtins_prof.hhi
@@ -9,6 +9,10 @@
  *
  */
 
+const int OBJPROF_FLAGS_DEFAULT = 1;
+const int OBJPROF_FLAGS_USER_TYPES_ONLY = 2;
+const int OBJPROF_FLAGS_PER_PROPERTY = 4;
+
 /**
  * Gather all of the stack traces this request thread has captured by now.
  * Does not clear the stored stacks.
@@ -27,9 +31,9 @@ function thread_memory_stats(): array<string, int>; // auto-imported from HH nam
 
 function objprof_start(): void; // auto-imported from HH namespace
 
-function objprof_get_data(): array<string, array>; // auto-imported from HH namespace
+function objprof_get_data(int $flags = OBJPROF_FLAGS_DEFAULT, array $exclude_list = array()): array<string, array>; // auto-imported from HH namespace
 
-function objprof_get_paths(): array<string, array>; // auto-imported from HH namespace
+function objprof_get_paths(int $flags = OBJPROF_FLAGS_DEFAULT, array $exclude_list = array()): array<string, array>; // auto-imported from HH namespace
 
 function objprof_get_strings(int $min_dup): array<string, array>; // auto-imported from HH namespace
 
diff --git a/hphp/hack/src/Makefile b/hphp/hack/src/Makefile
index 6bc1593..52f8a02 100644
--- a/hphp/hack/src/Makefile
+++ b/hphp/hack/src/Makefile
@@ -69,9 +69,11 @@ MODULES=\
   stubs\
   third-party/avl\
   third-party/core\
+  typed_ast\
   typing\
   utils\
   utils/collections\
+  utils/disk\
   utils/hh_json\
   monitor\
   watchman\
diff --git a/hphp/hack/src/client/clientAiInfo.ml b/hphp/hack/src/client/clientAiInfo.ml
index 62175cb..3a513a9 100644
--- a/hphp/hack/src/client/clientAiInfo.ml
+++ b/hphp/hack/src/client/clientAiInfo.ml
@@ -58,7 +58,7 @@ let go conn (files:string) expand_path =
     List.rev_map file_list begin fun file_path ->
       expand_path file_path
     end in
-  let command = ServerRpc.DUMP_AI_INFO (expand_path_list file_list) in
+  let command = ServerCommandTypes.DUMP_AI_INFO (expand_path_list file_list) in
   let result = ServerCommand.rpc conn command in
   let result_json = to_json result in
   print_endline (Hh_json.json_to_string result_json)
diff --git a/hphp/hack/src/client/clientArgs.ml b/hphp/hack/src/client/clientArgs.ml
index 67c2e91..441ba0c 100644
--- a/hphp/hack/src/client/clientArgs.ml
+++ b/hphp/hack/src/client/clientArgs.ml
@@ -422,7 +422,6 @@ let parse_build_args () =
   let clean = ref false in
   (* todo: for now better to default to true here, but this is temporary! *)
   let clean_before_build = ref true in
-  let incremental = ref false in
   let run_scripts = ref true in
   let wait = ref false in
   let options = [
@@ -452,8 +451,6 @@ let parse_build_args () =
     " erase previously generated files before building (default)";
     "--no-clean-before-build", Arg.Clear clean_before_build,
     " do not erase previously generated files before building";
-    (* Don't document --incremental option for now *)
-    "--incremental", Arg.Set incremental, "";
     "--wait", Arg.Set wait,
     " wait forever for hh_server intialization (default: false)";
     "--verbose", Arg.Set verbose,
@@ -480,7 +477,6 @@ let parse_build_args () =
       clean = !clean;
       clean_before_build = !clean_before_build;
       check = !check;
-      incremental = !incremental;
       user = Sys_utils.logname ();
       verbose = !verbose;
       id = Random_id.short_string ();
diff --git a/hphp/hack/src/client/clientBuild.ml b/hphp/hack/src/client/clientBuild.ml
index 8c5b899..58fcfea 100644
--- a/hphp/hack/src/client/clientBuild.ml
+++ b/hphp/hack/src/client/clientBuild.ml
@@ -77,7 +77,7 @@ let main env =
     ~exit:(fun () ->
       Printf.eprintf "\nHack build id: %s\n%!" request_id)
     ~do_:(fun () ->
-      ServerCommand.(stream_request oc (BUILD env.build_opts));
+      ServerCommand.stream_request oc (ServerCommandTypes.BUILD env.build_opts);
       handle_response env ic) in
   let svnrev = Option.try_with begin fun () ->
     Sys_utils.read_file ServerBuild.svnrev_path
diff --git a/hphp/hack/src/client/clientCheck.ml b/hphp/hack/src/client/clientCheck.ml
index 51970d9..2bdfca1 100644
--- a/hphp/hack/src/client/clientCheck.ml
+++ b/hphp/hack/src/client/clientCheck.ml
@@ -14,11 +14,11 @@ open Utils
 open ClientRefactor
 
 module Cmd = ServerCommand
-module Rpc = ServerRpc
+module Rpc = ServerCommandTypes
 
 let get_list_files conn (args:client_check_env): string list =
   let ic, oc = conn in
-  Cmd.(stream_request oc LIST_FILES);
+  Cmd.stream_request oc ServerCommandTypes.LIST_FILES;
   let res = ref [] in
   try
     while true do
@@ -91,7 +91,7 @@ let main args =
       Exit_status.No_error
     | MODE_LIST_MODES ->
       let ic, oc = connect args in
-      Cmd.(stream_request oc LIST_MODES);
+      Cmd.stream_request oc ServerCommandTypes.LIST_MODES;
       begin try
         while true do print_endline (Timeout.input_line ic) done;
       with End_of_file -> () end;
@@ -260,7 +260,7 @@ let main args =
       if error_list = [] then Exit_status.No_error else Exit_status.Type_error
     | MODE_SHOW classname ->
       let ic, oc = connect args in
-      Cmd.(stream_request oc (SHOW classname));
+      Cmd.stream_request oc (ServerCommandTypes.SHOW classname);
       print_all ic;
       Exit_status.No_error
     | MODE_SEARCH (query, type_) ->
@@ -307,7 +307,7 @@ let main args =
     | MODE_REMOVE_DEAD_FIXMES codes ->
       let conn = connect args in
       let patches = ServerCommand.rpc conn @@
-        ServerRpc.REMOVE_DEAD_FIXMES codes in
+        Rpc.REMOVE_DEAD_FIXMES codes in
       let file_map = List.fold_left patches
         ~f:map_patches_to_filename ~init:SMap.empty in
       if args.output_json
diff --git a/hphp/hack/src/client/clientConnect.ml b/hphp/hack/src/client/clientConnect.ml
index ede3723..872b9c9 100644
--- a/hphp/hack/src/client/clientConnect.ml
+++ b/hphp/hack/src/client/clientConnect.ml
@@ -262,7 +262,7 @@ let connect env =
       connect ~first_attempt:true env env.retries start_time tail_env in
     Tail.close_env tail_env;
     HackEventLogger.client_established_connection start_time;
-    ServerCommand.send_connection_type oc ServerCommand.Non_persistent;
+    ServerCommand.send_connection_type oc ServerCommandTypes.Non_persistent;
     (ic, oc)
   with
   | e ->
diff --git a/hphp/hack/src/client/clientCoverageMetric.mli b/hphp/hack/src/client/clientCoverageMetric.mli
index 79f8839..7d049e8 100644
--- a/hphp/hack/src/client/clientCoverageMetric.mli
+++ b/hphp/hack/src/client/clientCoverageMetric.mli
@@ -8,4 +8,4 @@
  *
  *)
 
-val go : json:bool -> ServerCoverageMetric.result -> unit
+val go : json:bool -> ServerCoverageMetricTypes.result -> unit
diff --git a/hphp/hack/src/client/clientFindDependentFiles.ml b/hphp/hack/src/client/clientFindDependentFiles.ml
index a59cc5e..11b7718 100644
--- a/hphp/hack/src/client/clientFindDependentFiles.ml
+++ b/hphp/hack/src/client/clientFindDependentFiles.ml
@@ -26,7 +26,8 @@ let go conn (files : string) expand_path =
     List.rev_map file_list begin fun file_path ->
       expand_path file_path
     end in
-  let command = ServerRpc.FIND_DEPENDENT_FILES (expand_path_list file_list) in
+  let command =
+    ServerCommandTypes.FIND_DEPENDENT_FILES (expand_path_list file_list) in
   let result = ServerCommand.rpc conn command in
   let result_json = to_json result in
   print_endline (Hh_json.json_to_string result_json)
diff --git a/hphp/hack/src/client/clientIde.ml b/hphp/hack/src/client/clientIde.ml
index fc28b5e..dc61e93 100644
--- a/hphp/hack/src/client/clientIde.ml
+++ b/hphp/hack/src/client/clientIde.ml
@@ -7,10 +7,11 @@
  * of patent rights can be found in the PATENTS file in the same directory.
  *
 *)
+open Core
 open IdeJson
 
 module Cmd = ServerCommand
-module Rpc = ServerRpc
+module Rpc = ServerCommandTypes
 module SMUtils = ServerMonitorUtils
 
 type env = {
@@ -55,7 +56,7 @@ let connect_persistent env ~retries =
   try
     let (ic, oc) = connect_persistent env retries start_time in
     HackEventLogger.client_established_connection start_time;
-    Cmd.send_connection_type oc Cmd.Persistent;
+    Cmd.send_connection_type oc ServerCommandTypes.Persistent;
     (ic, oc)
   with
   | e ->
@@ -65,15 +66,15 @@ let connect_persistent env ~retries =
 let malformed_input () =
   raise Exit_status.(Exit_with IDE_malformed_request)
 
-let read_server_message fd : response_type =
+let read_server_message fd : ServerCommandTypes.push =
   Marshal_tools.from_fd_with_preamble fd
 
 let read_connection_response fd =
   let res = Marshal_tools.from_fd_with_preamble fd in
   match res with
-  | Cmd.Persistent_client_alredy_exists ->
+  | ServerCommandTypes.Persistent_client_alredy_exists ->
     raise Exit_status.(Exit_with IDE_persistent_client_already_exists)
-  | Cmd.Persistent_client_connected -> ()
+  | ServerCommandTypes.Persistent_client_connected -> ()
 
 let server_disconnected () =
   raise Exit_status.(Exit_with No_error)
@@ -90,7 +91,7 @@ let get_ready_channel server_in_fd =
   let stdin_fd = Unix.descr_of_in_channel stdin in
   let readable, _, _ = Unix.select [server_in_fd; stdin_fd] [] [] 1.0 in
   if readable = [] then `None
-  else if List.mem server_in_fd readable then `Server
+  else if List.mem readable server_in_fd then `Server
   else `Stdin
 
 let handle conn id call =
@@ -99,7 +100,7 @@ match call with
   let raw_result =
     Cmd.rpc conn (Rpc.IDE_AUTOCOMPLETE (path, pos)) in
   let result =
-    List.map AutocompleteService.autocomplete_result_to_json raw_result in
+    List.map raw_result AutocompleteService.autocomplete_result_to_json in
   let result_field = (Hh_json.JSON_Array result) in
   print_endline @@ IdeJsonUtils.json_string_of_response id
     (Auto_complete_response result_field)
@@ -155,6 +156,10 @@ let main env =
         | Marshal_tools.Reading_Preamble_Exception
         | Unix.Unix_error _ -> server_disconnected ()
       in
-      write_response @@ IdeJsonUtils.json_string_of_response 0 res;
+      match res with
+      | ServerCommandTypes.DIAGNOSTIC (id, errors) ->
+        let errors_json = List.map ~f:Errors.to_json errors in
+        write_response @@ IdeJsonUtils.json_string_of_response 0
+          (Diagnostic_response (id, Hh_json.JSON_Array errors_json));
   done;
   Exit_status.exit Exit_status.No_error
diff --git a/hphp/hack/src/client/clientLint.ml b/hphp/hack/src/client/clientLint.ml
index 8d6adc7..afe9254 100644
--- a/hphp/hack/src/client/clientLint.ml
+++ b/hphp/hack/src/client/clientLint.ml
@@ -8,7 +8,7 @@
  *
  *)
 
-let go (results : ServerLint.result) output_json =
+let go (results : ServerLintTypes.result) output_json =
   if output_json then
     ServerLint.output_json stdout results
   else
diff --git a/hphp/hack/src/client/clientRefactor.ml b/hphp/hack/src/client/clientRefactor.ml
index c60b0aa..348a7a7 100644
--- a/hphp/hack/src/client/clientRefactor.ml
+++ b/hphp/hack/src/client/clientRefactor.ml
@@ -21,9 +21,9 @@ let compare_pos pos1 pos2 =
   else 0
 
 let get_pos = function
-  | ServerRefactor.Insert patch
-  | ServerRefactor.Replace patch -> patch.ServerRefactor.pos
-  | ServerRefactor.Remove p -> p
+  | ServerRefactorTypes.Insert patch
+  | ServerRefactorTypes.Replace patch -> patch.ServerRefactorTypes.pos
+  | ServerRefactorTypes.Remove p -> p
 
 let compare_result res1 res2 =
   compare_pos (get_pos res1) (get_pos res2)
@@ -56,12 +56,12 @@ let write_patches_to_buffer buf original_content patch_list =
     let char_start, char_end = Pos.info_raw pos in
     add_original_content (char_start - 1);
     match res with
-      | ServerRefactor.Insert patch ->
-          Buffer.add_string buf patch.ServerRefactor.text
-      | ServerRefactor.Replace patch ->
-          Buffer.add_string buf patch.ServerRefactor.text;
+      | ServerRefactorTypes.Insert patch ->
+          Buffer.add_string buf patch.ServerRefactorTypes.text
+      | ServerRefactorTypes.Replace patch ->
+          Buffer.add_string buf patch.ServerRefactorTypes.text;
           i := char_end
-      | ServerRefactor.Remove _ ->
+      | ServerRefactorTypes.Remove _ ->
           i := char_end
   end;
   add_original_content (String.length original_content - 1)
@@ -86,11 +86,11 @@ let apply_patches file_map =
 
 let patch_to_json res =
   let type_, replacement = match res with
-    | ServerRefactor.Insert patch ->
-        "insert", patch.ServerRefactor.text
-    | ServerRefactor.Replace patch ->
-        "replace", patch.ServerRefactor.text
-    | ServerRefactor.Remove _ ->
+    | ServerRefactorTypes.Insert patch ->
+        "insert", patch.ServerRefactorTypes.text
+    | ServerRefactorTypes.Replace patch ->
+        "replace", patch.ServerRefactorTypes.text
+    | ServerRefactorTypes.Remove _ ->
         "remove", ""
   in
   let pos = get_pos res in
@@ -117,8 +117,8 @@ let print_patches_json file_map =
 
 let go conn args mode before after =
     let command = match mode with
-    | "Class" -> ServerRefactor.ClassRename (before, after)
-    | "Function" -> ServerRefactor.FunctionRename (before, after)
+    | "Class" -> ServerRefactorTypes.ClassRename (before, after)
+    | "Function" -> ServerRefactorTypes.FunctionRename (before, after)
     | "Method" ->
       let befores = Str.split (Str.regexp "::") before in
       if (List.length befores) <> 2
@@ -138,11 +138,13 @@ let go conn args mode before after =
         failwith "Before and After classname must match"
       end
       else
-        ServerRefactor.MethodRename (before_class, before_method, after_method)
+        ServerRefactorTypes.MethodRename
+          (before_class, before_method, after_method)
     | _ ->
         failwith "Unexpected Mode" in
 
-    let patches = ServerCommand.rpc conn @@ ServerRpc.REFACTOR command in
+    let patches =
+      ServerCommand.rpc conn @@ ServerCommandTypes.REFACTOR command in
     let file_map = List.fold_left patches
       ~f:map_patches_to_filename ~init:SMap.empty in
     if args.output_json
diff --git a/hphp/hack/src/client/clientSymbolInfo.ml b/hphp/hack/src/client/clientSymbolInfo.ml
index 1c00a2d..1d9902c 100644
--- a/hphp/hack/src/client/clientSymbolInfo.ml
+++ b/hphp/hack/src/client/clientSymbolInfo.ml
@@ -37,9 +37,10 @@ let symbol_type_to_json symbol_type_results =
   end
 
 let to_json result =
-  let fun_call_json = fun_call_to_json result.SymbolInfoService.fun_calls in
+  let fun_call_json =
+    fun_call_to_json result.SymbolInfoServiceTypes.fun_calls in
   let symbol_type_json =
-    symbol_type_to_json result.SymbolInfoService.symbol_types in
+    symbol_type_to_json result.SymbolInfoServiceTypes.symbol_types in
   JSON_Object [
     "function_calls",   JSON_Array fun_call_json;
     "symbol_types",     JSON_Array symbol_type_json;
@@ -57,7 +58,8 @@ let go conn (files:string) expand_path =
     List.rev_map file_list begin fun file_path ->
       expand_path file_path
     end in
-  let command = ServerRpc.DUMP_SYMBOL_INFO (expand_path_list file_list) in
+  let command =
+    ServerCommandTypes.DUMP_SYMBOL_INFO (expand_path_list file_list) in
   let result = ServerCommand.rpc conn command in
   let result_json = to_json result in
   print_endline (Hh_json.json_to_string result_json)
diff --git a/hphp/hack/src/decl/decl.ml b/hphp/hack/src/decl/decl.ml
index aebe5d2..f71b40a 100644
--- a/hphp/hack/src/decl/decl.ml
+++ b/hphp/hack/src/decl/decl.ml
@@ -327,7 +327,6 @@ and class_decl tcopt c =
   let sm = List.fold_left c.c_static_methods
       ~f:(method_decl_acc ~is_static:true env c)
       ~init:sm in
-  SMap.iter (check_static_method m) sm;
   let parent_cstr = inherited.Decl_inherit.ih_cstr in
   let cstr = constructor_decl env parent_cstr c in
   let has_concrete_cstr = match (fst cstr) with
@@ -445,17 +444,6 @@ and trait_exists env acc trait =
       )
     | _ -> false
 
-and check_static_method obj method_name { elt_origin = cls; _ } =
-  if SMap.mem method_name obj
-  then begin
-    let static_method_pos = method_pos ~is_static:true cls method_name in
-    let dyn_method = SMap.find_unsafe method_name obj in
-    let dyn_method_pos =
-      method_pos ~is_static:false dyn_method.elt_origin method_name in
-    Errors.static_dynamic static_method_pos dyn_method_pos method_name
-  end
-  else ()
-
 and constructor_decl env (pcstr, pconsist) class_ =
   (* constructors in children of class_ must be consistent? *)
   let cconsist = class_.c_final ||
@@ -822,9 +810,8 @@ and type_typedef_naming_and_decl tcopt tdef =
 (* Global constants *)
 (*****************************************************************************)
 
-let iconst_decl tcopt cst =
+let const_decl cst =
   let open Option.Monad_infix in
-  let cst = Naming.global_const tcopt cst in
   let cst_pos, cst_name = cst.cst_name in
   let dep = Dep.GConst (snd cst.cst_name) in
   let env = {Decl_env.mode = cst.cst_mode; droot = Some dep} in
@@ -843,6 +830,11 @@ let iconst_decl tcopt cst =
   Decl_heap.GConsts.add cst_name hint_ty;
   ()
 
+let iconst_decl tcopt cst =
+  let cst = Naming.global_const tcopt cst in
+  const_decl cst;
+  ()
+
 (*****************************************************************************)
 
 let name_and_declare_types_program tcopt prog =
diff --git a/hphp/hack/src/decl/decl.mli b/hphp/hack/src/decl/decl.mli
index 16788f9..298eb95 100644
--- a/hphp/hack/src/decl/decl.mli
+++ b/hphp/hack/src/decl/decl.mli
@@ -30,6 +30,8 @@ val fun_decl : Nast.fun_ -> unit
 
 val typedef_decl : Nast.typedef -> unit
 
+val const_decl : Nast.gconst -> unit
+
 val fun_decl_in_env:
   Decl_env.env -> Nast.fun_ -> Typing_defs.decl Typing_defs.fun_type
 
diff --git a/hphp/hack/src/decl/decl_pos_utils.ml b/hphp/hack/src/decl/decl_pos_utils.ml
index 8caf45f..4feaf7f 100644
--- a/hphp/hack/src/decl/decl_pos_utils.ml
+++ b/hphp/hack/src/decl/decl_pos_utils.ml
@@ -78,6 +78,7 @@ module TraversePos(ImplementPos: sig val pos: Pos.t -> Pos.t end) = struct
     | Rtconst_no_cstr (p, s)   -> Rtconst_no_cstr (pos p, s)
     | Rused_as_map p           -> Rused_as_map (pos p)
     | Rused_as_shape p         -> Rused_as_shape (pos p)
+    | Rpredicated (p, f)       -> Rpredicated (pos p, f)
   let string_id (p, x) = pos p, x
 
   let rec ty (p, x) =
diff --git a/hphp/hack/src/decl/decl_redecl_service.ml b/hphp/hack/src/decl/decl_redecl_service.ml
index 4d71fef..8eb23e6 100644
--- a/hphp/hack/src/decl/decl_redecl_service.ml
+++ b/hphp/hack/src/decl/decl_redecl_service.ml
@@ -139,7 +139,7 @@ let otf_decl_files tcopt filel =
 
 let compute_deps fast filel =
   let infol =
-    List.map filel (fun fn -> Relative_path.Map.find_unsafe fn fast) in
+    List.map filel (fun fn -> Relative_path.Map.find_unsafe fast fn) in
   let names =
     List.fold_left infol ~f:FileInfo.merge_names ~init:FileInfo.empty_names in
   let { FileInfo.n_classes; n_funs; n_types; n_consts } = names in
diff --git a/hphp/hack/src/emitter/emitter_consts.ml b/hphp/hack/src/emitter/emitter_consts.ml
index abbc39d..148aa7d 100644
--- a/hphp/hack/src/emitter/emitter_consts.ml
+++ b/hphp/hack/src/emitter/emitter_consts.ml
@@ -18,9 +18,9 @@ open Utils
  * keep this synced eventually *)
 let header_kinds = [
   "Packed"; "Struct"; "Mixed"; "Empty"; "Apc"; "Globals"; "Proxy"; "String";
-  "Resource"; "Ref"; "Object"; "WaitHandle"; "ResumableObj"; "AwaitAllWH";
+  "Resource"; "Ref"; "Object"; "WaitHandle"; "AsyncFuncWH"; "AwaitAllWH";
   "Vector"; "Map"; "Set"; "Pair"; "ImmVector"; "ImmMap"; "ImmSet";
-  "ResumableFrame"; "NativeData";
+  "AsyncFuncFrame"; "NativeData";
   "SmallMalloc"; "BigMalloc"; "BigObj"; "Free"; "Hole"
 ]
 let header_kind_values = List.foldi
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_declaration_parser.ml b/hphp/hack/src/full_fidelity/full_fidelity_declaration_parser.ml
index eed3546..e86d299 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_declaration_parser.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_declaration_parser.ml
@@ -100,6 +100,8 @@ module WithExpressionAndStatementParser
     require-once-directive:
       require_once  (  include-filename  )  ;
       require_once  include-filename  ;
+    TODO The php spec says that include and include_once is followed by
+      expression, we need to know what kind of expression is allowed.
     *)
 
     let (parser, require) = next_token parser in
@@ -182,7 +184,6 @@ module WithExpressionAndStatementParser
     | RightBrace -> parser, make_missing ()
     | _ -> aux [] parser
 
-
   and parse_enum_declaration parser =
     (*
     enum-declaration:
@@ -281,12 +282,21 @@ module WithExpressionAndStatementParser
     (* SPEC
       namespace-use-declaration:
         use  namespace-use-clauses  ;
+        use  const  namespace-use-clauses  ;
+        use  function  namespace-use-clauses  ;
     *)
     let (parser, use_token) = assert_token parser Use in
+    (* const, function case *)
+    let (parser1, keyword_token) = next_token parser in
+    let (parser, keyword_token) =
+      match Token.kind keyword_token with
+        | Function
+        | Const -> (parser1, make_token keyword_token)
+        | _ -> (parser, make_missing()) in
     let (parser, clauses) = parse_comma_list
       parser Semicolon SyntaxError.error1004 parse_namespace_use_clause in
     let (parser, semi) = expect_semicolon parser in
-    let result = make_namespace_use use_token clauses semi in
+    let result = make_namespace_use use_token keyword_token clauses semi in
     (parser, result)
 
   and parse_classish_declaration parser attribute_spec =
@@ -294,7 +304,7 @@ module WithExpressionAndStatementParser
       parse_classish_modifiers parser in
     let (parser, token) =
       parse_classish_token parser in
-    let (parser, name) = expect_name parser in
+    let (parser, name) = expect_class_name parser in
     let (parser, generic_type_parameter_list) =
       parse_generic_type_parameter_list_opt parser in
     let (parser, classish_extends, classish_extends_list) =
@@ -373,6 +383,7 @@ module WithExpressionAndStatementParser
     (parser, syntax)
 
   and parse_classish_element_list_opt parser =
+    (* TODO: Refactor this method so that it uses list parsing helpers. *)
     (* We need to identify an element of a class, trait, etc. Possibilities
        are:
 
@@ -414,6 +425,9 @@ module WithExpressionAndStatementParser
       require  extends  qualified-name
       require  implements  qualified-name
 
+      // XHP class attribute declaration
+      attribute ... ;
+
     *)
     let rec aux parser acc =
       let token = peek_token parser in
@@ -453,6 +467,9 @@ module WithExpressionAndStatementParser
              in a later pass. *)
          let (parser, require) = parse_require_clause parser in
          aux parser (require :: acc)
+      | TokenKind.Attribute -> let (parser, attr) =
+        parse_xhp_class_attribute_declaration parser in
+        aux parser (attr :: acc)
       | _ ->
           (* TODO *)
         let (parser, token) = next_token parser in
@@ -463,6 +480,70 @@ module WithExpressionAndStatementParser
     let classish_elements = List.rev classish_elements in
     (parser, make_list classish_elements)
 
+  and parse_xhp_type_specifier parser =
+    (* SPEC (Draft)
+      xhp-type-specifier:
+        enum { xhp-attribute-enum-list-opt }
+        type-specifier
+
+      xhp-attribute-enum-value:
+        any integer literal
+        any single-quoted-string literal
+        any double-quoted-string literal
+
+      TODO: What are the semantics of encapsulated expressions in double-quoted
+            string literals here?
+      TODO: Write the grammar for the comma-separated list
+      TODO: Can the list end in a trailing comma?
+      TODO: Can it be empty?
+      ERROR RECOVERY: We parse any expressions here;
+      TODO: give an error in a later pass if the expressions are not literals.
+    *)
+    if peek_token_kind parser = Enum then
+      let (parser, enum_token) = assert_token parser Enum in
+      let (parser, left_brace, values, right_brace) =
+        parse_braced_comma_list_opt_allow_trailing
+        parser parse_expression in
+      let result =
+        make_xhp_enum_type enum_token left_brace values right_brace in
+      (parser, result)
+    else
+      parse_type_specifier parser
+
+  and parse_xhp_class_attribute parser =
+    (* SPEC (Draft)
+    xhp-attribute-declaration:
+      xhp-class-name
+      xhp-type-specifier name initializer-opt @required-opt (TODO)
+    *)
+    if peek_token_kind parser = Colon then
+      (* TODO: This doesn't give quite the right error message if it turns
+      out to be malformed; consider tweaking this. *)
+      (* TODO: What about the case where we have a "type name = value"
+         attribute and the type starts with a colon? Is that ever legal? *)
+      expect_class_name parser
+    else
+      let (parser, ty) = parse_xhp_type_specifier parser in
+      let (parser, name) = expect_name parser in
+      let (parser, init) = parse_simple_initializer_opt parser in
+      (* TODO: Parse @required *)
+      let result = make_xhp_class_attribute ty name init in
+      (parser, result)
+
+  and parse_xhp_class_attribute_declaration parser =
+    (* SPEC: (Draft)
+    xhp-class-attribute-declaration :
+      attribute xhp-attribute-declaration-list ;
+    *)
+    let (parser, attr_token) = assert_token parser TokenKind.Attribute in
+    (* TODO: Can this list be terminated with a trailing comma? *)
+    (* TODO: Better error message. *)
+    let (parser, attrs) = parse_comma_list parser Semicolon
+      SyntaxError.error1004 parse_xhp_class_attribute in
+    let (parser, semi) = expect_semicolon parser in
+    let result = make_xhp_class_attribute_declaration attr_token attrs semi in
+    (parser, result)
+
   and parse_qualified_name_type parser =
     (* Here we're parsing a name followed by an optional generic type
        argument list; if we don't have a name, give an error. *)
@@ -561,15 +642,9 @@ module WithExpressionAndStatementParser
         =  expression
     *)
     let (parser, name) = expect_variable parser in
-    let (parser, equal) = optional_token parser Equal in
-    if is_missing equal then
-      let result = make_property_declarator name (make_missing()) in
-      (parser, result)
-    else
-      let (parser, initial_value) = parse_expression parser in
-      let simple_init = make_simple_initializer equal initial_value in
-      let result = make_property_declarator name simple_init in
-      (parser, result)
+    let (parser, simple_init) = parse_simple_initializer_opt parser in
+    let result = make_property_declarator name simple_init in
+    (parser, result)
 
   (* SPEC:
     const-declaration:
@@ -602,10 +677,9 @@ module WithExpressionAndStatementParser
 
   and parse_constant_declarator parser =
     let (parser, const_name) = expect_name parser in
-    let (parser, initializer_) = parse_simple_initializer parser in
+    let (parser, initializer_) = parse_simple_initializer_opt parser in
     (parser, make_constant_declarator const_name initializer_)
 
-
   (* SPEC:
     type-constant-declaration:
       abstract-type-constant-declaration
@@ -791,7 +865,7 @@ module WithExpressionAndStatementParser
         | Variable | DotDotDot | Ampersand -> (parser, make_missing())
         | _ -> parse_type_specifier parser in
     let (parser, name) = parse_decorated_variable_opt parser in
-    let (parser, default) = parse_simple_initializer parser in
+    let (parser, default) = parse_simple_initializer_opt parser in
     let syntax =
       make_parameter_declaration attrs visibility type_specifier name default in
     (parser, syntax)
@@ -821,7 +895,7 @@ module WithExpressionAndStatementParser
     constant-initializer:
       =  const-expression
   *)
-  and parse_simple_initializer parser =
+  and parse_simple_initializer_opt parser =
     let (parser1, token) = next_token parser in
     match (Token.kind token) with
     | Equal ->
@@ -955,6 +1029,8 @@ module WithExpressionAndStatementParser
   and parse_declaration parser =
     let (parser1, token) = next_token parser in
     match (Token.kind token) with
+    | Include
+    | Include_once
     | Require
     | Require_once -> parse_inclusion_directive parser
     | Type
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_expression_parser.ml b/hphp/hack/src/full_fidelity/full_fidelity_expression_parser.ml
index 7424211..d102ced 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_expression_parser.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_expression_parser.ml
@@ -62,6 +62,9 @@ module WithStatementAndDeclParser
   and parse_expression_with_reset_precedence parser =
     with_reset_precedence parser parse_expression
 
+  and parse_expression_with_operator_precedence parser operator =
+    with_operator_precedence parser operator parse_expression
+
   (* try to parse an expression. If parser cannot make progress, return None *)
   and parse_expression_optional parser ~reset_prec =
     let module Lexer = PrecedenceParser.Lexer in
@@ -103,6 +106,9 @@ module WithStatementAndDeclParser
     | Name
     | QualifiedName ->
         parse_name_or_collection_literal_expression parser1 token
+    | Self
+    | Parent
+    | Static -> parse_scope_resolution_expression parser1 (make_token token)
     | Yield -> parse_yield_expression parser
     | Print -> parse_print_expression parser
     | Exclamation
@@ -153,9 +159,17 @@ module WithStatementAndDeclParser
       (* TODO: Error, expected expression *)
       (parser1, make_token token)
 
+  and next_is_lower_precedence parser =
+    let kind = peek_token_kind parser in
+    if not (Operator.is_trailing_operator_token kind) then
+      true (* No trailing operator; terminate the expression. *)
+    else
+      let operator = Operator.trailing_from_token kind in
+      (Operator.precedence operator) < parser.precedence
+
   and parse_remaining_expression parser term =
-    let (parser1, token) = next_token parser in
-    match (Token.kind token) with
+    if next_is_lower_precedence parser then (parser, term)
+    else match peek_token_kind parser with
     (* Binary operators *)
     | Plus
     | Minus
@@ -193,22 +207,45 @@ module WithStatementAndDeclParser
     | GreaterThanGreaterThan
     | Carat
     | BarGreaterThan
-    | MinusGreaterThan
-    | QuestionMinusGreaterThan
-    | ColonColon
     | QuestionQuestion
     | Instanceof ->
     (* TODO: "and" "or" "xor" *)
       parse_remaining_binary_operator parser term
-
+    | QuestionMinusGreaterThan
+    | MinusGreaterThan -> parse_member_selection_expression parser term
+    | ColonColon ->
+      parse_scope_resolution_expression parser term
     | PlusPlus
     | MinusMinus -> parse_postfix_unary parser term
     | LeftParen -> parse_function_call parser term
     | LeftBracket
     | LeftBrace -> parse_subscript parser term
-    | Question -> parse_conditional_expression parser1 term (make_token token)
+    | Question ->
+      let (parser, token) = assert_token parser Question in
+      parse_conditional_expression parser term token
     | _ -> (parser, term)
 
+  and parse_member_selection_expression parser term =
+    (* SPEC:
+    member-selection-expression:
+      postfix-expression  ->  name
+      postfix-expression  ->  variable-name
+
+    null-safe-member-selection-expression:
+      postfix-expression  ->  name
+      postfix-expression  ->  variable-name
+    *)
+    let (parser, token) = next_token parser in
+    let op = make_token token in
+    (* TODO: We are putting the name / variable into the tree as a token
+    leaf, rather than as a name or variable expression. Is that right? *)
+    let (parser, name) = expect_name_or_variable parser in
+    let result = if (Token.kind token) = MinusGreaterThan then
+      make_member_selection_expression term op name
+    else
+      make_safe_member_selection_expression term op name in
+    parse_remaining_expression parser result
+
   and parse_subscript parser term =
     (* SPEC
       subscript-expression:
@@ -260,43 +297,42 @@ module WithStatementAndDeclParser
       parser, make_decorated_expression dots expr
     | _ -> parse_expression parser
 
-  and parse_object_creation_expression parser =
-    (* SPEC
-      object-creation-expression:
-        new  class-type-designator  (  argument-expression-listopt  )
-
-      class-type-designator:
-        static
-        qualified-name
-        variable-name
+  and parse_designator parser =
+    (* SPEC:
+        class-type-designator:
+          parent
+          self
+          static
+          member-selection-expression
+          null-safe-member-selection-expression
+          qualified-name
+          scope-resolution-expression
+          subscript-expression
+          variable-name
     *)
-    let (parser, new_token) = next_token parser in
     let (parser1, token) = next_token parser in
-    (* TODO: handle error reporting:
-      not all types of expressions are allowed
-      dynamic calls are not allowed in strict mode
-    *)
-    let (parser, designator, left, args, right) = match Token.kind token with
-    | Static ->
-        let (parser, designator) = parser1, (make_token token) in
-        let (parser, left, args, right) = parse_expression_list_opt parser in
-        (parser, designator, left, args, right)
+    let kind = peek_token_kind parser1 in
+    match Token.kind token with
+    | Parent
+    | Self
+    | Static when kind = LeftParen ->
+      (parser1, make_token token)
     | _ ->
-      let (parser, expr) = parse_expression parser in
-      match syntax expr with
-        | FunctionCallExpression fce -> (
-            parser,
-            fce.function_call_receiver,
-            fce.function_call_lparen,
-            fce.function_call_arguments,
-            fce.function_call_rparen
-          )
-        | _ ->
-          (parser, expr, make_missing(), make_missing(), make_missing())
-    in
+        parse_expression_with_operator_precedence parser Operator.NewOperator
+        (* TODO: We need to verify in a later pass that the expression is a
+        scope resolution (that does not end in class!), a member selection,
+        a name, a variable, a property, or an array subscript expression. *)
 
-    let result = make_object_creation_expression (make_token new_token)
-      designator left args right in
+  and parse_object_creation_expression parser =
+    (* SPEC
+      object-creation-expression:
+        new  class-type-designator  (  argument-expression-list-opt  )
+    *)
+    let (parser, new_token) = assert_token parser New in
+    let (parser, designator) = parse_designator parser in
+    let (parser, left, args, right) = parse_expression_list_opt parser in
+    let result =
+      make_object_creation_expression new_token designator left args right in
     (parser, result)
 
   and parse_function_call parser receiver =
@@ -477,7 +513,9 @@ module WithStatementAndDeclParser
 
   and parse_remaining_binary_operator parser left_term =
     (* We have a left term. If we get here then we know that
-     * we have a binary operator to its right.
+     * we have a binary operator to its right, and that furthermore,
+     * the binary operator is of equal or higher precedence than the
+     * whatever is going on in the left term.
      *
      * Here's how this works.  Suppose we have something like
      *
@@ -499,9 +537,9 @@ module WithStatementAndDeclParser
      *
      * How are we going to figure this out?
      *
-     * We have the term A in hand; the precedence is zero.
+     * We have the term A in hand; the precedence is low.
      * We see that x follows A.
-     * We obtain the precedence of x. It is greater than zero,
+     * We obtain the precedence of x. It is higher than the precedence of A,
      * so we obtain B, and then we call a helper method that
      * collects together everything to the right of B that is
      * of higher precedence than x. (Or equal, and right-associative.)
@@ -512,19 +550,15 @@ module WithStatementAndDeclParser
      * will simply return B, we'll construct (A x B) and recurse with that
      * as the left term.
      *)
-
+      assert (not (next_is_lower_precedence parser));
       let (parser1, token) = next_token parser in
       let operator = Operator.trailing_from_token (Token.kind token) in
       let precedence = Operator.precedence operator in
-      if precedence < parser.precedence then
-        (parser, left_term)
-      else
-        let (parser2, right_term) = parse_term parser1 in
-        let (parser2, right_term) = parse_remaining_binary_operator_helper
-          parser2 right_term precedence in
-        let term =
-          make_binary_operator left_term (make_token token) right_term in
-        parse_remaining_expression parser2 term
+      let (parser2, right_term) = parse_term parser1 in
+      let (parser2, right_term) = parse_remaining_binary_operator_helper
+        parser2 right_term precedence in
+      let term = make_binary_operator left_term (make_token token) right_term in
+      parse_remaining_expression parser2 term
 
   and parse_remaining_binary_operator_helper
       parser right_term left_precedence =
@@ -883,6 +917,7 @@ module WithStatementAndDeclParser
 
   and parse_braced_expression parser =
     let (parser, left_brace) = next_token parser in
+    (* TODO: Rewrite this to use helper methods. *)
     let precedence = parser.precedence in
     let parser = with_precedence parser 0 in
     let (parser, expression) = parse_expression parser in
@@ -1009,4 +1044,29 @@ module WithStatementAndDeclParser
       missing, give a missing node for the left side, and parse the
       remainder as the right side. We'll go for the former for now. *)
       (with_error parser SyntaxError.error1015, (make_token token))
+
+  and parse_scope_resolution_expression parser qualifier =
+    (* SPEC
+      scope-resolution-expression:
+        scope-resolution-qualifier  ::  name
+        scope-resolution-qualifier  ::  class
+
+      scope-resolution-qualifier:
+        qualified-name
+        variable-name
+        self
+        parent
+        static
+    *)
+    (* TODO: The left hand side can in fact be any expression in this parser;
+    we need to add a later error pass to detect that the left hand side is
+    a valid qualifier. *)
+    (* TODO: The right hand side, if a name or a variable, is treated as a
+    name or variable *token* and not a name or variable *expression*. Is
+    that the desired tree topology? Give this more thought; it might impact
+    rename refactoring semantics. *)
+    let (parser, op) = expect_coloncolon parser in
+    let (parser, name) = expect_name_variable_or_class parser in
+    let result = make_scope_resolution_expression qualifier op name in
+    parse_remaining_expression parser result
 end
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_lexer.ml b/hphp/hack/src/full_fidelity/full_fidelity_lexer.ml
index 2c81510..41c2242 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_lexer.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_lexer.ml
@@ -477,6 +477,18 @@ let rec scan_xhp_element_name lexer =
   else
     (lexer, TokenKind.XHPElementName)
 
+let scan_xhp_class_name lexer =
+  (* An XHP class name is a colon followed by an xhp name. *)
+  if peek_char lexer 0 = ':' then
+    let (lexer, token) = scan_xhp_element_name (advance lexer 1) in
+    if token = TokenKind.XHPElementName then
+      (lexer, TokenKind.XHPClassName)
+    else
+      (lexer, token)
+  else
+    let lexer = with_error lexer SyntaxError.error0008 in
+    (advance lexer 1, TokenKind.Error)
+
 let scan_xhp_string_literal lexer =
   (* XHP string literals are just straight up "find the closing quote"
      strings.  TODO: What about newlines embedded? *)
@@ -855,3 +867,6 @@ let next_xhp_body_token lexer =
     let w = width lexer in
     (lexer, Token.make kind w [] []) in
   scan_assert_progress scanner lexer
+
+let next_xhp_class_name lexer =
+  scan_token_and_trivia scan_xhp_class_name false lexer
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_lexer.mli b/hphp/hack/src/full_fidelity/full_fidelity_lexer.mli
index 7ad61dd..2ed7a7d 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_lexer.mli
+++ b/hphp/hack/src/full_fidelity/full_fidelity_lexer.mli
@@ -18,3 +18,4 @@ val next_token_as_name : t -> t * Full_fidelity_minimal_token.t
 val next_token_in_type : t -> t * Full_fidelity_minimal_token.t
 val next_xhp_element_token : t -> t * Full_fidelity_minimal_token.t * String.t
 val next_xhp_body_token : t -> t * Full_fidelity_minimal_token.t
+val next_xhp_class_name : t -> t * Full_fidelity_minimal_token.t
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_lexer_sig.ml b/hphp/hack/src/full_fidelity/full_fidelity_lexer_sig.ml
index 2cf8d61..10b2508 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_lexer_sig.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_lexer_sig.ml
@@ -15,4 +15,5 @@ module type Lexer_S = sig
   val next_token : t -> t * Full_fidelity_minimal_token.t
   val next_token_as_name : t -> t * Full_fidelity_minimal_token.t
   val errors : t -> Full_fidelity_syntax_error.t list
+  val next_xhp_class_name : t -> t * Full_fidelity_minimal_token.t
 end
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_operator.ml b/hphp/hack/src/full_fidelity/full_fidelity_operator.ml
index f0ac56a..b01e85d 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_operator.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_operator.ml
@@ -86,6 +86,7 @@ let precedence operator =
   (* TODO: variable operator $ *)
   match operator with
 
+  | AwaitOperator -> 1
   | AssignmentOperator | AdditionAssignmentOperator
   | SubtractionAssignmentOperator | MultiplicationAssignmentOperator
   | DivisionAssignmentOperator | ExponentiationAssignmentOperator
@@ -93,35 +94,35 @@ let precedence operator =
   | AndAssignmentOperator
   | OrAssignmentOperator | ExclusiveOrAssignmentOperator
   | LeftShiftAssignmentOperator | RightShiftAssignmentOperator
-    -> 1
-  | PipeOperator -> 2
-  | ConditionalQuestionOperator | ConditionalColonOperator -> 3
-  | CoalesceOperator -> 4
-  | LogicalOrOperator -> 5
-  | LogicalAndOperator -> 6
-  | OrOperator -> 7
-  | ExclusiveOrOperator -> 8
-  | AndOperator -> 9
+    -> 2
+  | PipeOperator -> 3
+  | ConditionalQuestionOperator | ConditionalColonOperator -> 4
+  | CoalesceOperator -> 5
+  | LogicalOrOperator -> 6
+  | LogicalAndOperator -> 7
+  | OrOperator -> 8
+  | ExclusiveOrOperator -> 9
+  | AndOperator -> 10
   | EqualOperator | StrictEqualOperator
-  | NotEqualOperator | StrictNotEqualOperator -> 10
+  | NotEqualOperator | StrictNotEqualOperator -> 11
   | LessThanOperator | LessThanOrEqualOperator
-  | GreaterThanOperator | GreaterThanOrEqualOperator -> 11
-  | LeftShiftOperator | RightShiftOperator -> 12
-  | AdditionOperator | SubtractionOperator | ConcatenationOperator -> 13
-  | MultiplicationOperator | DivisionOperator | RemainderOperator -> 14
-  | InstanceofOperator -> 15
-  | AwaitOperator| CastOperator
+  | GreaterThanOperator | GreaterThanOrEqualOperator -> 12
+  | LeftShiftOperator | RightShiftOperator -> 13
+  | AdditionOperator | SubtractionOperator | ConcatenationOperator -> 14
+  | MultiplicationOperator | DivisionOperator | RemainderOperator -> 15
+  | InstanceofOperator -> 16
+  | CastOperator
   | ReferenceOperator | ErrorControlOperator
   | PrefixIncrementOperator | PrefixDecrementOperator
   | LogicalNotOperator| NotOperator
-  | UnaryPlusOperator | UnaryMinusOperator -> 16
-  | NewOperator | CloneOperator
-  | ExponentOperator
-  | FunctionCallOperator
-  | MemberSelectionOperator | NullSafeMemberSelectionOperator
-  | PostfixIncrementOperator | PostfixDecrementOperator
-  | IndexingOperator
-  | ScopeResolutionOperator -> 17
+  | UnaryPlusOperator | UnaryMinusOperator -> 17
+  | ExponentOperator -> 18
+  | PostfixIncrementOperator | PostfixDecrementOperator -> 19
+  | FunctionCallOperator -> 20
+  | NewOperator | CloneOperator -> 21
+  | IndexingOperator -> 22
+  | MemberSelectionOperator | NullSafeMemberSelectionOperator -> 23
+  | ScopeResolutionOperator -> 24
 
 let associativity operator =
   match operator with
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_parser_helpers.ml b/hphp/hack/src/full_fidelity/full_fidelity_parser_helpers.ml
index afc84ff..77392bd 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_parser_helpers.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_parser_helpers.ml
@@ -30,10 +30,21 @@ module WithParser(Parser : ParserType) = struct
     let parser = Parser.with_lexer parser lexer in
     (parser, token)
 
-  let peek_token parser =
+  let peek_token ?(lookahead=0) parser =
+    let rec lex_ahead lexer n =
+      let (next_lexer, token) = Parser.Lexer.next_token lexer in
+      match n with
+      | 0 -> token
+      | _ -> lex_ahead next_lexer (n-1)
+    in
+      lex_ahead (Parser.lexer parser) lookahead
+
+  let next_token_as_name parser =
+    (* TODO: This isn't right.  Pass flags to the lexer. *)
     let lexer = Parser.lexer parser in
-    let (_, token) = Parser.Lexer.next_token lexer in
-    token
+    let (lexer, token) = Parser.Lexer.next_token_as_name lexer in
+    let parser = Parser.with_lexer parser lexer in
+    (parser, token)
 
   let peek_token_kind parser =
     Token.kind (peek_token parser)
@@ -62,11 +73,22 @@ module WithParser(Parser : ParserType) = struct
       (with_error parser error, (Syntax.make_missing()))
 
   let expect_name parser =
+    (* TODO: What if the name is a keyword? *)
     expect_token parser TokenKind.Name SyntaxError.error1004
 
+  let expect_class_name parser =
+    if peek_token_kind parser = TokenKind.Colon then
+      let lexer = Parser.lexer parser in
+      let (lexer, token) = Parser.Lexer.next_xhp_class_name lexer in
+      let parser = Parser.with_lexer parser lexer in
+      (parser, (Syntax.make_token token))
+    else
+      expect_name parser
+
   (* We accept either a Name or a QualifiedName token when looking for a
      qualified name. *)
   let expect_qualified_name parser =
+    (* TODO: What if the name is a keyword? *)
     let (parser1, name) = next_token parser in
     match Token.kind name with
     | TokenKind.QualifiedName
@@ -128,6 +150,33 @@ module WithParser(Parser : ParserType) = struct
   let expect_while parser =
     expect_token parser TokenKind.While SyntaxError.error1018
 
+  let expect_coloncolon parser =
+    expect_token parser TokenKind.ColonColon SyntaxError.error1047
+
+  let expect_name_or_variable parser =
+    let (parser1, token) = next_token_as_name parser in
+    match Token.kind token with
+    | TokenKind.Name
+    | TokenKind.Variable -> (parser1, Syntax.make_token token)
+    | _ ->
+      (* ERROR RECOVERY: Create a missing token for the expected token,
+         and continue on from the current token. Don't skip it. *)
+      (with_error parser SyntaxError.error1050, (Syntax.make_missing()))
+
+  let expect_name_variable_or_class parser =
+    let (parser1, token) = next_token parser in
+    if Token.kind token = TokenKind.Class then
+      (parser1, Syntax.make_token token)
+    else
+      let (parser1, token) = next_token_as_name parser in
+      match Token.kind token with
+      | TokenKind.Name
+      | TokenKind.Variable -> (parser1, Syntax.make_token token)
+      | _ ->
+        (* ERROR RECOVERY: Create a missing token for the expected token,
+           and continue on from the current token. Don't skip it. *)
+        (with_error parser SyntaxError.error1048, (Syntax.make_missing()))
+
   let optional_token parser kind =
     let (parser1, token) = next_token parser in
     if (Token.kind token) = kind then
@@ -140,13 +189,6 @@ module WithParser(Parser : ParserType) = struct
     assert ((Token.kind token) = kind);
     (parser, Syntax.make_token token)
 
-  let next_token_as_name parser =
-    (* TODO: This isn't right.  Pass flags to the lexer. *)
-    let lexer = Parser.lexer parser in
-    let (lexer, token) = Parser.Lexer.next_token_as_name lexer in
-    let parser = Parser.with_lexer parser lexer in
-    (parser, token)
-
   (* This helper method parses a list of the form
 
     open_token item separator_token item ... close_token
@@ -269,4 +311,20 @@ module WithParser(Parser : ParserType) = struct
         parser TokenKind.RightParen SyntaxError.error1011 parse_item in
     parse_parenthesized_list parser parse_items
 
+  let parse_braced_list parser parse_items =
+    parse_delimited_list parser TokenKind.LeftBrace SyntaxError.error1034
+      TokenKind.RightBrace SyntaxError.error1006 parse_items
+
+  let parse_braced_comma_list_opt parser parse_item =
+    let parse_items parser =
+      parse_comma_list_opt
+        parser TokenKind.RightBrace SyntaxError.error1006 parse_item in
+    parse_braced_list parser parse_items
+
+  let parse_braced_comma_list_opt_allow_trailing parser parse_item =
+    let parse_items parser =
+      parse_comma_list_opt_allow_trailing
+        parser TokenKind.RightBrace SyntaxError.error1006 parse_item in
+    parse_braced_list parser parse_items
+
 end
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_precedence_parser.ml b/hphp/hack/src/full_fidelity/full_fidelity_precedence_parser.ml
index 63f6877..05a8c53 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_precedence_parser.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_precedence_parser.ml
@@ -10,6 +10,7 @@
 
 module SyntaxError = Full_fidelity_syntax_error
 module Lexer = Full_fidelity_lexer
+module Operator = Full_fidelity_operator
 
 type t = {
   lexer : Lexer.t;
@@ -35,13 +36,20 @@ let lexer parser =
 let with_precedence parser precedence =
   { parser with precedence }
 
-let with_reset_precedence parser parse_function =
+let with_numeric_precedence parser new_precedence parse_function =
   let old_precedence = parser.precedence in
-  let parser = with_precedence parser 0 in
+  let parser = with_precedence parser new_precedence in
   let (parser, result) = parse_function parser in
   let parser = with_precedence parser old_precedence in
   (parser, result)
 
+let with_operator_precedence parser operator parse_function =
+  let new_precedence = Operator.precedence operator in
+  with_numeric_precedence parser new_precedence parse_function
+
+let with_reset_precedence parser parse_function =
+  with_numeric_precedence parser 0 parse_function
+
 let next_xhp_element_token parser =
   let (lexer, token, text) = Lexer.next_xhp_element_token parser.lexer in
   let parser = { parser with lexer } in
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_pretty_printer.ml b/hphp/hack/src/full_fidelity/full_fidelity_pretty_printer.ml
index 5ea53cb..7ab0eda 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_pretty_printer.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_pretty_printer.ml
@@ -260,6 +260,22 @@ let rec get_doc node =
     let right = get_doc (classish_body_right_brace x) in
     let body = get_doc (classish_body_elements x) in
     indent_block_no_space left body right indt
+  | XHPEnumType x ->
+    let e = get_doc x.xhp_enum_token in
+    let l = get_doc x.xhp_enum_left_brace in
+    let v = get_doc x.xhp_enum_values in
+    let r = get_doc x.xhp_enum_right_brace in
+    group_doc (e ^| l ^| v ^| r)
+  | XHPClassAttributeDeclaration x ->
+    let attr = get_doc x.xhp_attr_token in
+    let attrs = get_doc x.xhp_attr_list in
+    let semi = get_doc x.xhp_attr_semicolon in
+    group_doc (attr ^| attrs ^^^ semi)
+  | XHPClassAttribute x ->
+    let t = get_doc x.xhp_attr_decl_type in
+    let n = get_doc x.xhp_attr_decl_name in
+    let i = get_doc x.xhp_attr_decl_init in
+    group_doc (t ^| n ^| i)
   | TraitUse x ->
     let use = get_doc (trait_use_token x) in
     let name_list = get_doc (trait_use_name_list x) in
@@ -345,9 +361,10 @@ let rec get_doc node =
     indent_block_no_space left body right indt |> add_break
   | NamespaceUseDeclaration x ->
     let u = get_doc x.namespace_use in
+    let k = get_doc x.namespace_use_keywordopt in
     let c = get_doc x.namespace_use_clauses in
     let s = get_doc x.namespace_use_semicolon in
-    u ^| c ^^^ s
+    u ^| k ^| c ^^^ s
   | NamespaceUseClause x ->
     let n = get_doc x.namespace_use_name in
     let a = get_doc x.namespace_use_as in
@@ -564,6 +581,17 @@ let rec get_doc node =
     let start_block = indent_block_no_space left_part expr right indt in
     handle_switch start_block x
     (* group_doc (start_block ^| statement) *)
+  | ScopeResolutionExpression x ->
+    let q = get_doc x.scope_resolution_qualifier in
+    let o = get_doc x.scope_resolution_operator in
+    let n = get_doc x.scope_resolution_name in
+    group_doc (q ^^^ o ^^^ n)
+  | MemberSelectionExpression x
+  | SafeMemberSelectionExpression x ->
+    let ob = get_doc x.member_object in
+    let op = get_doc x.member_operator in
+    let nm = get_doc x.member_name in
+    group_doc (ob ^^^ op ^^^ nm)
   | YieldExpression x ->
     let y = get_doc x.yield_token in
     let o = get_doc x.yield_operand in
@@ -832,13 +860,17 @@ let rec get_doc node =
     let back_part = expr ^^^ semicolon in
     group_doc (indent_doc keyword back_part indt)
   | BreakStatement x ->
-    let keyword = get_doc (break_keyword x) in
-    let semicolon = get_doc (break_semicolon x) in
-    keyword ^^^ semicolon
+    let b = get_doc x.break_keyword in
+    let l = get_doc x.break_level in
+    let s = get_doc x.break_semicolon in
+    if is_missing x.break_level then group_doc (b ^^^ l ^^^ s)
+    else group_doc (b ^| l ^^^ s)
   | ContinueStatement x ->
-    let keyword = get_doc (continue_keyword x) in
-    let semicolon = get_doc (continue_semicolon x) in
-    keyword ^^^ semicolon
+    let c = get_doc x.continue_keyword in
+    let l = get_doc x.continue_level in
+    let s = get_doc x.continue_semicolon in
+    if is_missing x.continue_level then group_doc (c ^^^ l ^^^ s)
+    else group_doc (c ^| l ^^^ s)
   | FunctionStaticStatement x ->
     let st = get_doc x.static_static in
     let ds = get_doc x.static_declarations in
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_statement_parser.ml b/hphp/hack/src/full_fidelity/full_fidelity_statement_parser.ml
index a2c7027..a707ee5 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_statement_parser.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_statement_parser.ml
@@ -44,7 +44,8 @@ module WithExpressionParser
     | Default -> parse_default_label_statement parser
     | Case -> parse_case_label_statement parser
     | LeftBrace -> parse_compound_statement parser
-    | Static -> parse_function_static_declaration parser
+    | Static ->
+      parse_function_static_declaration_or_expression_statement parser
     | Echo -> parse_echo_statement parser
     | _ -> parse_expression_statement parser
 
@@ -285,16 +286,40 @@ module WithExpressionParser
     (parser, syntax)
 
   and parse_break_statement parser =
+    (* SPEC
+    break-statement:
+      break  ;
+
+    However, PHP allows an optional expression; though Hack does not have
+    this feature, we allow it at parse time and produce an error later.
+    TODO: Implement that error. *)
+
     (* We detect if we are not inside a switch or loop in a later pass. *)
     let (parser, break_token) = assert_token parser Break in
+    let (parser, level) =
+      if peek_token_kind parser = Semicolon then (parser, (make_missing()))
+      else parse_expression parser in
     let (parser, semi_token) = expect_semicolon parser in
-    (parser, make_break_statement break_token semi_token)
+    let result = make_break_statement break_token level semi_token in
+    (parser, result)
 
   and parse_continue_statement parser =
+    (* SPEC
+    continue-statement:
+      continue  ;
+
+    However, PHP allows an optional expression; though Hack does not have
+    this feature, we allow it at parse time and produce an error later.
+    TODO: Implement that error. *)
+
     (* We detect if we are not inside a loop in a later pass. *)
     let (parser, continue_token) = assert_token parser Continue in
+    let (parser, level) =
+      if peek_token_kind parser = Semicolon then (parser, (make_missing()))
+      else parse_expression parser in
     let (parser, semi_token) = expect_semicolon parser in
-    (parser, make_continue_statement continue_token semi_token)
+    let result = make_continue_statement continue_token level semi_token in
+    (parser, result)
 
   and parse_return_statement parser =
     let (parser, return_token) = assert_token parser Return in
@@ -346,6 +371,15 @@ module WithExpressionParser
       else parse_statement parser in
     (parser, make_case_statement case_token expr colon_token stmt)
 
+  and parse_function_static_declaration_or_expression_statement parser =
+    (* Determine if the current token is a late-bound static scope to be
+     * resolved by the '::' operator. (E.g., "static::foo".)
+     *)
+    if Token.kind (peek_token ~lookahead:1 parser) == TokenKind.ColonColon then
+      parse_expression_statement parser
+    else
+      parse_function_static_declaration parser
+
   and parse_function_static_declaration parser =
     (* SPEC
 
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_syntax.ml b/hphp/hack/src/full_fidelity/full_fidelity_syntax.ml
index 68e338f..d25e00a 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_syntax.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_syntax.ml
@@ -138,6 +138,7 @@ module WithToken(Token: TokenType) = struct
     }
     and namespace_use_declaration = {
       namespace_use : t;
+      namespace_use_keywordopt : t;
       namespace_use_clauses : t;
       namespace_use_semicolon : t
     }
@@ -364,10 +365,12 @@ module WithToken(Token: TokenType) = struct
     }
     and break_statement = {
       break_keyword: t;
+      break_level: t;
       break_semicolon: t
     }
     and continue_statement = {
       continue_keyword: t;
+      continue_level: t;
       continue_semicolon: t
     }
     and function_static_statement = {
@@ -424,6 +427,16 @@ module WithToken(Token: TokenType) = struct
       cast_right_paren : t;
       cast_operand : t
     }
+    and scope_resolution_expression = {
+      scope_resolution_qualifier : t;
+      scope_resolution_operator : t;
+      scope_resolution_name : t
+    }
+    and member_selection_expression = {
+      member_object : t;
+      member_operator : t;
+      member_name : t
+    }
     and yield_expression = {
       yield_token : t;
       yield_operand : t
@@ -509,6 +522,22 @@ module WithToken(Token: TokenType) = struct
       awaitable_async : t;
       awaitable_compound_statement : t;
     }
+    and xhp_enum_type = {
+      xhp_enum_token : t;
+      xhp_enum_left_brace : t;
+      xhp_enum_values : t;
+      xhp_enum_right_brace : t
+    }
+    and xhp_class_attribute_declaration = {
+      xhp_attr_token : t;
+      xhp_attr_list : t;
+      xhp_attr_semicolon : t
+    }
+    and xhp_class_attribute = {
+      xhp_attr_decl_type : t;
+      xhp_attr_decl_name : t;
+      xhp_attr_decl_init : t
+    }
     and xhp_attribute = {
       xhp_attr_name : t;
       xhp_attr_equal : t;
@@ -629,6 +658,9 @@ module WithToken(Token: TokenType) = struct
     | MethodishDeclaration of methodish_declaration
     | ClassishDeclaration of classish_declaration
     | ClassishBody of classish_body
+    | XHPEnumType of xhp_enum_type
+    | XHPClassAttributeDeclaration of xhp_class_attribute_declaration
+    | XHPClassAttribute of xhp_class_attribute
     | TraitUse of trait_use
     | RequireClause of require_clause
     | ConstDeclaration of const_declaration
@@ -668,6 +700,9 @@ module WithToken(Token: TokenType) = struct
     | StaticDeclarator of static_declarator
     | EchoStatement of echo_statement
 
+    | MemberSelectionExpression of member_selection_expression
+    | SafeMemberSelectionExpression of member_selection_expression
+    | ScopeResolutionExpression of scope_resolution_expression
     | YieldExpression of yield_expression
     | PrintExpression of print_expression
     | CastExpression of cast_expression
@@ -731,6 +766,10 @@ module WithToken(Token: TokenType) = struct
       match syntax with
       | Missing -> SyntaxKind.Missing
       | Token _  -> SyntaxKind.Token
+      | MemberSelectionExpression _ -> SyntaxKind.MemberSelectionExpression
+      | SafeMemberSelectionExpression _ ->
+        SyntaxKind.SafeMemberSelectionExpression
+      | ScopeResolutionExpression _ -> SyntaxKind.ScopeResolutionExpression
       | YieldExpression _ -> SyntaxKind.YieldExpression
       | PrintExpression _ -> SyntaxKind.PrintExpression
       | CastExpression _ -> SyntaxKind.CastExpression
@@ -761,6 +800,10 @@ module WithToken(Token: TokenType) = struct
       | MethodishDeclaration _ -> SyntaxKind.MethodishDeclaration
       | ClassishDeclaration _ -> SyntaxKind.ClassishDeclaration
       | ClassishBody _ -> SyntaxKind.ClassishBody
+      | XHPEnumType _ -> SyntaxKind.XHPEnumType
+      | XHPClassAttributeDeclaration _ ->
+        SyntaxKind.XHPClassAttributeDeclaration
+      | XHPClassAttribute _ -> SyntaxKind.XHPClassAttribute
       | TraitUse _ -> SyntaxKind.TraitUse
       | RequireClause _ -> SyntaxKind.RequireClause
       | ConstDeclaration _ -> SyntaxKind.ConstDeclaration
@@ -835,6 +878,12 @@ module WithToken(Token: TokenType) = struct
 
     let is_missing node = kind node = SyntaxKind.Missing
     let is_token node = kind node = SyntaxKind.Token
+    let is_scope_resolution_expression node =
+      kind node = SyntaxKind.ScopeResolutionExpression
+    let is_member_selection_expression node =
+      kind node = SyntaxKind.MemberSelectionExpression
+    let is_safe_member_selection_expression node =
+      kind node = SyntaxKind.SafeMemberSelectionExpression
     let is_yield_expression node = kind node = SyntaxKind.YieldExpression
     let is_print_expression node = kind node = SyntaxKind.PrintExpression
     let is_cast_expression node = kind node = SyntaxKind.CastExpression
@@ -928,6 +977,7 @@ module WithToken(Token: TokenType) = struct
     let is_element_initializer node = kind node = SyntaxKind.ElementInitializer
     let is_subscript_expression node =
       kind node = SyntaxKind.SubscriptExpression
+    let is_xhp_enum_type node = kind node = SyntaxKind.XHPEnumType
     let is_xhp_expression node = kind node = SyntaxKind.XHPExpression
     let is_xhp_open node = kind node = SyntaxKind.XHPOpen
     let is_xhp_attribute node = kind node = SyntaxKind.XHPAttribute
@@ -997,6 +1047,17 @@ module WithToken(Token: TokenType) = struct
       | PipeVariableExpression x -> [x]
       | Error x -> x
       | SyntaxList x -> x
+      | ScopeResolutionExpression
+        { scope_resolution_qualifier; scope_resolution_operator;
+          scope_resolution_name } ->
+        [ scope_resolution_qualifier; scope_resolution_operator;
+          scope_resolution_name ]
+      | MemberSelectionExpression
+        { member_object; member_operator; member_name } ->
+        [ member_object; member_operator; member_name ]
+      | SafeMemberSelectionExpression
+        { member_object; member_operator; member_name } ->
+        [ member_object; member_operator; member_name ]
       | YieldExpression
         { yield_token; yield_operand } ->
         [ yield_token; yield_operand ]
@@ -1065,8 +1126,14 @@ module WithToken(Token: TokenType) = struct
         [ namespace_left_brace; namespace_declarations;
           namespace_right_brace ]
       | NamespaceUseDeclaration
-        { namespace_use; namespace_use_clauses; namespace_use_semicolon } ->
-        [ namespace_use; namespace_use_clauses; namespace_use_semicolon ]
+        { namespace_use;
+          namespace_use_keywordopt;
+          namespace_use_clauses;
+          namespace_use_semicolon } ->
+          [ namespace_use;
+            namespace_use_keywordopt;
+            namespace_use_clauses;
+            namespace_use_semicolon ]
       | NamespaceUseClause
         { namespace_use_name; namespace_use_as; namespace_use_alias } ->
         [ namespace_use_name; namespace_use_as; namespace_use_alias ]
@@ -1100,6 +1167,17 @@ module WithToken(Token: TokenType) = struct
           classish_body_right_brace } ->
         [ classish_body_left_brace; classish_body_elements;
           classish_body_right_brace ]
+      | XHPEnumType
+        { xhp_enum_token; xhp_enum_left_brace; xhp_enum_values;
+          xhp_enum_right_brace } ->
+        [ xhp_enum_token; xhp_enum_left_brace; xhp_enum_values;
+          xhp_enum_right_brace ]
+      | XHPClassAttributeDeclaration
+        { xhp_attr_token; xhp_attr_list; xhp_attr_semicolon } ->
+        [ xhp_attr_token; xhp_attr_list; xhp_attr_semicolon ]
+      | XHPClassAttribute
+        { xhp_attr_decl_type; xhp_attr_decl_name; xhp_attr_decl_init } ->
+        [ xhp_attr_decl_type; xhp_attr_decl_name; xhp_attr_decl_init ]
       | TraitUse
         { trait_use_token; trait_use_name_list; trait_use_semicolon; } ->
         [ trait_use_token; trait_use_name_list; trait_use_semicolon; ]
@@ -1214,11 +1292,11 @@ module WithToken(Token: TokenType) = struct
         { throw_keyword; throw_expr; throw_semicolon } ->
         [ throw_keyword; throw_expr; throw_semicolon ]
       | BreakStatement
-        { break_keyword; break_semicolon } ->
-        [ break_keyword; break_semicolon ]
+        { break_keyword; break_level; break_semicolon } ->
+        [ break_keyword; break_level; break_semicolon ]
       | ContinueStatement
-        { continue_keyword; continue_semicolon } ->
-        [ continue_keyword; continue_semicolon ]
+        { continue_keyword; continue_level; continue_semicolon } ->
+        [ continue_keyword; continue_level; continue_semicolon ]
       | FunctionStaticStatement
         { static_static; static_declarations; static_semicolon } ->
         [ static_static; static_declarations; static_semicolon ]
@@ -1377,6 +1455,17 @@ module WithToken(Token: TokenType) = struct
       | PipeVariableExpression _ -> ["pipe_variable_expression"]
       | Error _ -> []
       | SyntaxList _ -> []
+      | MemberSelectionExpression
+        { member_object; member_operator; member_name } ->
+        [ "member_object"; "member_operator"; "member_name" ]
+      | SafeMemberSelectionExpression
+        { member_object; member_operator; member_name } ->
+        [ "member_object"; "member_operator"; "member_name" ]
+      | ScopeResolutionExpression
+        { scope_resolution_qualifier; scope_resolution_operator;
+          scope_resolution_name } ->
+        [ "scope_resolution_qualifier"; "scope_resolution_operator";
+          "scope_resolution_name" ]
       | YieldExpression
         { yield_token; yield_operand } ->
         [ "yield_token"; "yield_operand" ]
@@ -1445,8 +1534,14 @@ module WithToken(Token: TokenType) = struct
         [ "namespace_left_brace"; "namespace_declarations";
           "namespace_right_brace" ]
       | NamespaceUseDeclaration
-        { namespace_use; namespace_use_clauses; namespace_use_semicolon } ->
-        [ "namespace_use"; "namespace_use_clauses"; "namespace_use_semicolon" ]
+        { namespace_use;
+          namespace_use_keywordopt;
+          namespace_use_clauses;
+          namespace_use_semicolon } ->
+            [ "namespace_use";
+              "namespace_use_keywordopt";
+              "namespace_use_clauses";
+              "namespace_use_semicolon" ]
       | NamespaceUseClause
         { namespace_use_name; namespace_use_as; namespace_use_alias } ->
         [ "namespace_use_name"; "namespace_use_as"; "namespace_use_alias" ]
@@ -1481,6 +1576,17 @@ module WithToken(Token: TokenType) = struct
           classish_body_right_brace } ->
         [ "classish_body_left_brace"; "classish_body_elements";
           "classish_body_right_brace" ]
+      | XHPEnumType
+        { xhp_enum_token; xhp_enum_left_brace; xhp_enum_values;
+          xhp_enum_right_brace } ->
+        [ "xhp_enum_token"; "xhp_enum_left_brace"; "xhp_enum_values";
+          "xhp_enum_right_brace" ]
+      | XHPClassAttributeDeclaration
+        { xhp_attr_token; xhp_attr_list; xhp_attr_semicolon } ->
+        [ "xhp_attr_token"; "xhp_attr_list"; "xhp_attr_semicolon" ]
+      | XHPClassAttribute
+        { xhp_attr_decl_type; xhp_attr_decl_name; xhp_attr_decl_init } ->
+        [ "xhp_attr_decl_type"; "xhp_attr_decl_name"; "xhp_attr_decl_init" ]
       | TraitUse
         { trait_use_token; trait_use_name_list; trait_use_semicolon; } ->
         [ "trait_use_token"; "trait_use_name_list"; "trait_use_semicolon"; ]
@@ -1599,11 +1705,11 @@ module WithToken(Token: TokenType) = struct
         { throw_keyword; throw_expr; throw_semicolon } ->
         [ "throw_keyword"; "throw_expr"; "throw_semicolon" ]
       | BreakStatement
-        { break_keyword; break_semicolon } ->
-        [ "break_keyword"; "break_semicolon" ]
+        { break_keyword; break_level; break_semicolon } ->
+        [ "break_keyword"; "break_level"; "break_semicolon" ]
       | ContinueStatement
-        { continue_keyword; continue_semicolon } ->
-        [ "continue_keyword"; "continue_semicolon" ]
+        { continue_keyword; continue_level; continue_semicolon } ->
+        [ "continue_keyword"; "continue_level"; "continue_semicolon" ]
       | FunctionStaticStatement
         { static_static; static_declarations; static_semicolon } ->
         [ "static_static"; "static_declarations"; "static_semicolon" ]
@@ -1906,10 +2012,6 @@ module WithToken(Token: TokenType) = struct
     let throw_keyword x = x.throw_keyword
     let throw_expr x = x.throw_expr
     let throw_semicolon x = x.throw_semicolon
-    let break_keyword x = x.break_keyword
-    let break_semicolon x = x.break_semicolon
-    let continue_keyword x = x.continue_keyword
-    let continue_semicolon x = x.continue_semicolon
     let echo_token x = x.echo_token
     let echo_expression_list x = x.echo_expression_list
     let echo_semicolon x = x.echo_semicolon
@@ -2021,6 +2123,20 @@ module WithToken(Token: TokenType) = struct
       match kind, ts with
       | (SyntaxKind.Missing, []) -> Missing
       | (SyntaxKind.SyntaxList, x) -> SyntaxList x
+      | (SyntaxKind.MemberSelectionExpression,
+        [ member_object; member_operator; member_name ]) ->
+        MemberSelectionExpression
+        { member_object; member_operator; member_name }
+      | (SyntaxKind.SafeMemberSelectionExpression,
+        [ member_object; member_operator; member_name ]) ->
+        SafeMemberSelectionExpression
+        { member_object; member_operator; member_name }
+      | (SyntaxKind.ScopeResolutionExpression,
+        [ scope_resolution_qualifier; scope_resolution_operator;
+          scope_resolution_name ]) ->
+        ScopeResolutionExpression
+        { scope_resolution_qualifier; scope_resolution_operator;
+          scope_resolution_name }
       | (SyntaxKind.YieldExpression,
         [ yield_token; yield_operand ]) ->
         YieldExpression
@@ -2106,9 +2222,15 @@ module WithToken(Token: TokenType) = struct
         { namespace_left_brace; namespace_declarations;
           namespace_right_brace }
       | (SyntaxKind.NamespaceUseDeclaration,
-        [ namespace_use; namespace_use_clauses; namespace_use_semicolon ]) ->
+        [ namespace_use;
+          namespace_use_keywordopt;
+          namespace_use_clauses;
+          namespace_use_semicolon ]) ->
         NamespaceUseDeclaration
-        { namespace_use; namespace_use_clauses; namespace_use_semicolon }
+        { namespace_use;
+          namespace_use_keywordopt;
+          namespace_use_clauses;
+          namespace_use_semicolon }
       | (SyntaxKind.NamespaceUseClause,
         [ namespace_use_name; namespace_use_as; namespace_use_alias ]) ->
         NamespaceUseClause
@@ -2147,6 +2269,20 @@ module WithToken(Token: TokenType) = struct
         ClassishBody {
           classish_body_left_brace; classish_body_elements;
           classish_body_right_brace }
+      | (SyntaxKind.XHPEnumType,
+        [ xhp_enum_token; xhp_enum_left_brace; xhp_enum_values;
+          xhp_enum_right_brace ]) ->
+        XHPEnumType
+        { xhp_enum_token; xhp_enum_left_brace; xhp_enum_values;
+          xhp_enum_right_brace }
+      | (SyntaxKind.XHPClassAttributeDeclaration,
+        [ xhp_attr_token; xhp_attr_list; xhp_attr_semicolon ]) ->
+        XHPClassAttributeDeclaration
+        { xhp_attr_token; xhp_attr_list; xhp_attr_semicolon }
+      | (SyntaxKind.XHPClassAttribute,
+        [ xhp_attr_decl_type; xhp_attr_decl_name; xhp_attr_decl_init ]) ->
+        XHPClassAttribute
+        { xhp_attr_decl_type; xhp_attr_decl_name; xhp_attr_decl_init }
       | (SyntaxKind.TraitUse,
         [ trait_use_token; trait_use_name_list; trait_use_semicolon; ]) ->
         TraitUse { trait_use_token; trait_use_name_list; trait_use_semicolon; }
@@ -2265,11 +2401,14 @@ module WithToken(Token: TokenType) = struct
       | (SyntaxKind.ThrowStatement, [ throw_keyword;
         throw_expr; throw_semicolon ]) ->
         ThrowStatement { throw_keyword; throw_expr; throw_semicolon }
-      | (SyntaxKind.BreakStatement, [ break_keyword; break_semicolon ]) ->
-        BreakStatement { break_keyword; break_semicolon }
+      | (SyntaxKind.BreakStatement,
+        [ break_keyword; break_level; break_semicolon ]) ->
+        BreakStatement
+        { break_keyword; break_level; break_semicolon }
       | (SyntaxKind.ContinueStatement,
-          [ continue_keyword; continue_semicolon ]) ->
-        ContinueStatement { continue_keyword; continue_semicolon }
+        [ continue_keyword; continue_level; continue_semicolon ]) ->
+        ContinueStatement
+        { continue_keyword; continue_level; continue_semicolon }
       | (SyntaxKind.FunctionStaticStatement,
         [ static_static; static_declarations; static_semicolon ]) ->
         FunctionStaticStatement
@@ -2497,6 +2636,16 @@ module WithToken(Token: TokenType) = struct
           [ function_call_receiver; function_call_lparen;
             function_call_arguments; function_call_rparen ]
 
+      let make_member_selection_expression ob op name =
+        from_children SyntaxKind.MemberSelectionExpression [ ob; op; name ]
+
+      let make_safe_member_selection_expression ob op name =
+        from_children SyntaxKind.SafeMemberSelectionExpression [ ob; op; name ]
+
+      let make_scope_resolution_expression qualifier op name =
+        from_children SyntaxKind.ScopeResolutionExpression
+          [ qualifier; op; name ]
+
       let make_yield_expression token operand =
         from_children SyntaxKind.YieldExpression [ token; operand ]
 
@@ -2652,9 +2801,9 @@ module WithToken(Token: TokenType) = struct
         from_children SyntaxKind.NamespaceBody
           [ left; decls; right ]
 
-      let make_namespace_use use clauses semi =
+      let make_namespace_use use keyword_opt clauses semi =
         from_children SyntaxKind.NamespaceUseDeclaration
-          [ use; clauses; semi ]
+          [ use; keyword_opt; clauses; semi ]
 
       let make_namespace_use_clause name as_token alias =
         from_children SyntaxKind.NamespaceUseClause [ name; as_token; alias ]
@@ -2696,6 +2845,18 @@ module WithToken(Token: TokenType) = struct
           classish_body_left_brace; classish_body_elements;
           classish_body_right_brace ]
 
+      let make_xhp_enum_type token left items right =
+        from_children SyntaxKind.XHPEnumType
+        [ token; left; items; right ]
+
+      let make_xhp_class_attribute_declaration attr attrs semi =
+        from_children SyntaxKind.XHPClassAttributeDeclaration
+          [ attr; attrs; semi ]
+
+      let make_xhp_class_attribute attr_type name init =
+        from_children SyntaxKind.XHPClassAttribute
+          [ attr_type; name; init ]
+
       let make_trait_use trait_use_token trait_use_name_list
         trait_use_semicolon =
         from_children SyntaxKind.TraitUse [
@@ -2843,13 +3004,13 @@ module WithToken(Token: TokenType) = struct
         from_children SyntaxKind.ThrowStatement
           [ throw_keyword; throw_expr; throw_semicolon ]
 
-      let make_break_statement break_keyword break_semicolon =
+      let make_break_statement keyword level semi =
         from_children SyntaxKind.BreakStatement
-          [ break_keyword; break_semicolon ]
+          [ keyword; level; semi ]
 
-      let make_continue_statement continue_keyword continue_semicolon =
+      let make_continue_statement keyword level semi =
         from_children SyntaxKind.ContinueStatement
-          [ continue_keyword; continue_semicolon ]
+          [ keyword; level; semi ]
 
       let make_function_static_statement static decls semi =
         from_children SyntaxKind.FunctionStaticStatement [ static; decls; semi ]
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_syntax_error.ml b/hphp/hack/src/full_fidelity/full_fidelity_syntax_error.ml
index 80563e2..996007a 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_syntax_error.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_syntax_error.ml
@@ -89,7 +89,7 @@ let error1032 = "A closing square bracket is expected here."
 let error1033 = "A class member, method, type, trait usage, trait require, " ^
   "xhp attribute, xhp use, or xhp category is expected here."
 let error1034 = "A left brace is expected here."
-let error1035 = "'Class' keyword is expected here."
+let error1035 = "The 'class' keyword is expected here."
 let error1036 = "A '=' is expected here."
 let error1037 = "A left brace is expected here."
 let error1038 = "A namespace body is expected here."
@@ -102,6 +102,9 @@ let error1043 = "A function header is expected here."
 let error1044 = "A name, __construct, or __destruct keyword is expected here."
 let error1045 = "An 'extends' or 'implements' keyword is expected here."
 let error1046 = "A lambda arrow ('==>') is expected here."
+let error1047 = "A scope resolution operator ('::') is expected here."
+let error1048 = "A name, variable name or 'class' is expected here."
+let error1050 = "A name or variable name is expected here."
 
 let error2001 = "A type annotation is required in strict mode."
 let error2002 = "An XHP attribute name may not contain '-' or ':'."
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_syntax_kind.ml b/hphp/hack/src/full_fidelity/full_fidelity_syntax_kind.ml
index 1326333..3380fe2 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_syntax_kind.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_syntax_kind.ml
@@ -69,6 +69,9 @@ type t =
 | SimpleInitializer
 
 (* Expressions *)
+| MemberSelectionExpression
+| SafeMemberSelectionExpression
+| ScopeResolutionExpression
 | YieldExpression
 | PrintExpression
 | CastExpression
@@ -101,6 +104,9 @@ type t =
 | XHPOpen
 | XHPAttribute
 | XHPClose
+| XHPClassAttributeDeclaration
+| XHPClassAttribute
+| XHPEnumType
 
 (* Types *)
 | SimpleTypeSpecifier
@@ -122,6 +128,9 @@ let to_string kind =
   match kind with
   | Missing -> "missing"
   | Token -> "token"
+  | MemberSelectionExpression -> "member_selection_expression"
+  | SafeMemberSelectionExpression -> "safe_member_selection_expression"
+  | ScopeResolutionExpression -> "scope_resolution_expression"
   | YieldExpression -> "yield_expression"
   | PrintExpression -> "print_expression"
   | CastExpression -> "cast_expression"
@@ -220,3 +229,6 @@ let to_string kind =
   | XHPOpen -> "xhp_open"
   | XHPAttribute -> "xhp_attribute"
   | XHPClose -> "xhp_close"
+  | XHPClassAttributeDeclaration -> "xhp_class_attribute_declaration"
+  | XHPClassAttribute -> "xhp_class_attribute"
+  | XHPEnumType -> "xhp_enum_type"
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_token_kind.ml b/hphp/hack/src/full_fidelity/full_fidelity_token_kind.ml
index ea341ac..78917b8 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_token_kind.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_token_kind.ml
@@ -20,6 +20,7 @@ type t =
 | Arraykey
 | As
 | Async
+| Attribute
 | Await
 | Bool
 | Break
@@ -48,6 +49,8 @@ type t =
 | Function
 | If
 | Implements
+| Include
+| Include_once
 | Instanceof
 | Insteadof
 | Int
@@ -162,6 +165,7 @@ type t =
 | NullLiteral
 (* XHP *)
 | XHPElementName
+| XHPClassName
 | XHPStringLiteral
 | XHPBody
 | XHPComment
@@ -176,6 +180,7 @@ let from_string keyword =
   | "arraykey" -> Some Arraykey
   | "as" -> Some As
   | "async" -> Some Async
+  | "attribute" -> Some Attribute
   | "await" -> Some Await
   | "bool" -> Some Bool
   | "break" -> Some Break
@@ -205,6 +210,8 @@ let from_string keyword =
   | "function" -> Some Function
   | "if" -> Some If
   | "implements" -> Some Implements
+  | "include" -> Some Include
+  | "include_once" -> Some Include_once
   | "instanceof" -> Some Instanceof
   | "insteadof" -> Some Insteadof
   | "int" -> Some Int
@@ -254,6 +261,7 @@ let to_string kind =
   | Arraykey -> "arraykey"
   | As -> "as"
   | Async -> "async"
+  | Attribute -> "attribute"
   | Await -> "await"
   | Bool -> "bool"
   | Break -> "break"
@@ -282,6 +290,8 @@ let to_string kind =
   | Function -> "function"
   | If -> "if"
   | Implements -> "implements"
+  | Include -> "include"
+  | Include_once -> "include_once"
   | Instanceof -> "instanceof"
   | Insteadof -> "insteadof"
   | Int -> "int"
@@ -398,6 +408,7 @@ let to_string kind =
   | BooleanLiteral -> "boolean_literal"
   | NullLiteral -> "null_literal"
   | XHPElementName -> "XHP_element_name"
+  | XHPClassName -> "XHP_class_name"
   | XHPStringLiteral -> "XHP_string_literal"
   | XHPBody -> "XHP_body"
   | XHPComment -> "XHP_comment"
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_type_lexer.ml b/hphp/hack/src/full_fidelity/full_fidelity_type_lexer.ml
index b2b22a5..f65b105 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_type_lexer.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_type_lexer.ml
@@ -17,4 +17,5 @@ let start_offset = Full_fidelity_lexer.start_offset
 let end_offset = Full_fidelity_lexer.end_offset
 let next_token = Full_fidelity_lexer.next_token_in_type
 let next_token_as_name = Full_fidelity_lexer.next_token_as_name
+let next_xhp_class_name = Full_fidelity_lexer.next_xhp_class_name
 let errors = Full_fidelity_lexer.errors
diff --git a/hphp/hack/src/full_fidelity/full_fidelity_type_parser.ml b/hphp/hack/src/full_fidelity/full_fidelity_type_parser.ml
index 7937b01..4ce618a 100644
--- a/hphp/hack/src/full_fidelity/full_fidelity_type_parser.ml
+++ b/hphp/hack/src/full_fidelity/full_fidelity_type_parser.ml
@@ -201,7 +201,16 @@ and parse_generic_type_argument_list_opt parser =
     (parser, make_missing())
 
 and parse_type_list parser close_kind =
-  parse_comma_list parser close_kind SyntaxError.error1007 parse_type_specifier
+  (* SPEC:
+    type-specifier-list:
+      type-specifiers  ,opt
+
+    type-specifiers:
+      type-specifier
+      type-specifiers  ,  type-specifier
+  *)
+  parse_comma_list_allow_trailing parser close_kind SyntaxError.error1007
+    parse_type_specifier
 
 and parse_type_or_ellipsis_list parser close_kind =
   parse_comma_list parser close_kind SyntaxError.error1007
@@ -214,9 +223,28 @@ and parse_type_or_ellipsis parser =
   | _ -> parse_type_specifier parser
 
 and parse_generic_type_argument_list parser =
+  (* SPEC:
+    generic-type-argument-list:
+      <  generic-type-arguments  ,opt  >
+
+    generic-type-arguments:
+      generic-type-argument
+      generic-type-arguments  ,  generic-type-argument
+  *)
+  (* TODO: SPEC ISSUE
+    The specification indicates that "noreturn" is only syntactically valid
+    as a return type hint, but this is plainly wrong because
+    Awaitable<noreturn> is a legal type. Likely the correct rule will be to
+    allow noreturn as a type argument, and then a later semantic analysis
+    pass can determine when it is being used incorrectly.
+
+    For now, we extend the specification to allow return types, not just
+    ordinary types.
+  *)
   let (parser, open_angle) = next_token parser in
   let open_angle = make_token open_angle in
-  let (parser, args) = parse_type_list parser GreaterThan in
+  let (parser, args) = parse_comma_list_allow_trailing parser GreaterThan
+    SyntaxError.error1007 parse_return_type in
   let (parser1, close_angle) = next_token parser in
   if (Token.kind close_angle) = GreaterThan then
     let result = make_type_arguments open_angle args (make_token close_angle) in
@@ -305,6 +333,10 @@ and parse_tuple_type_specifier parser =
         ( type-specifier  ,  type-specifier-list  )
   *)
 
+  (* TODO: Here we parse a type list with one or more items, but the grammar
+     actually requires a type list with two or more items. Give an error in
+     a later pass if there is only one item here. *)
+
   let (parser, left_paren) = next_token parser in
   let left_paren = make_token left_paren in
   let (parser, args) = parse_type_list parser RightParen in
@@ -409,7 +441,7 @@ and parse_type_constraint_opt parser =
   else
     (parser, (make_missing()))
 
-let parse_return_type parser =
+and parse_return_type parser =
   let (parser1, token) = next_token parser in
   if (Token.kind token) = Noreturn then
     (parser1, make_token token)
diff --git a/hphp/hack/src/full_fidelity/hack_grammar_descriptor.ml b/hphp/hack/src/full_fidelity/hack_grammar_descriptor.ml
index cace8ee..f61283d 100644
--- a/hphp/hack/src/full_fidelity/hack_grammar_descriptor.ml
+++ b/hphp/hack/src/full_fidelity/hack_grammar_descriptor.ml
@@ -873,18 +873,26 @@ and p_postfix_expression = "PostfixExpression", fun () -> [
   [NonTerm p_subscript_expression];
   [NonTerm p_function_call_expression];
   [NonTerm p_postfix_expression; minus_greater_than; name];
-  [NonTerm p_postfix_expression; minus_greater_than; NonTerm p_expression];
+  [NonTerm p_postfix_expression; minus_greater_than; NonTerm p_variable_name];
   [NonTerm p_postfix_expression; question_minus_greater_than; name];
+  [NonTerm p_postfix_expression; question_minus_greater_than;
+    NonTerm p_variable_name];
   [NonTerm p_unary_expression; plus_plus];
   [NonTerm p_unary_expression; minus_minus];
-  (* [NonTerm p_scope_resolution_quantifier; colon_colon; name]; *)
-  (* [NonTerm p_scope_resolution_quantifier; colon_colon; term_class]; *)
+  [NonTerm p_scope_resolution_quantifier; colon_colon; name];
+  [NonTerm p_scope_resolution_quantifier; colon_colon; term_class];
   [NonTerm p_expression; star_star; NonTerm p_expression]]
 
 and p_unary_operator = "UnaryOperator", fun () ->
   [[plus]; [minus]; [exclamation]; [tilde]]
 
 and p_object_creation_expression = "ObjectCreationExpression", fun () -> [
+  [term_new; parent; left_paren; NonTerm p_argument_expression_list;
+    right_paren];
+  [term_new; parent; left_paren; right_paren];
+  [term_new; self; left_paren; NonTerm p_argument_expression_list;
+    right_paren];
+  [term_new; self; left_paren; right_paren];
   [term_new; static; left_paren; NonTerm p_argument_expression_list;
     right_paren];
   [term_new; static; left_paren; right_paren];
diff --git a/hphp/hack/src/h2tp/engine.ml b/hphp/hack/src/h2tp/engine.ml
index 52ef8cd..0cebecf 100644
--- a/hphp/hack/src/h2tp/engine.ml
+++ b/hphp/hack/src/h2tp/engine.ml
@@ -117,7 +117,7 @@ let go src dest =
   if not (Sys.is_directory src) then raise (CE.InputError (
     "The source \"" ^ src ^ "\" is not a directory. This tool works over " ^
     "directories"));
-  Sys.mkdir_p (Filename.dirname dest);
+  Sys_utils.mkdir_p (Filename.dirname dest);
   let exns = ref [] in
   List.iter ~f:begin fun (s, d) ->
     try
diff --git a/hphp/hack/src/heap/hh_shared.c b/hphp/hack/src/heap/hh_shared.c
index 51fa170..f427d89 100644
--- a/hphp/hack/src/heap/hh_shared.c
+++ b/hphp/hack/src/heap/hh_shared.c
@@ -87,8 +87,6 @@
 #include <caml/unixsupport.h>
 #include <caml/intext.h>
 
-#include <assert.h>
-
 #ifdef _WIN32
 #include <windows.h>
 #else
@@ -117,6 +115,17 @@
 #define Val_handle(fd) (Val_long(fd))
 #endif
 
+#if !defined _CUSTOM_ASSERT_FUNCTIONS_
+#define _CUSTOM_ASSERT_FUNCTIONS_
+/**
+ * Concatenate the __LINE__ and __FILE__ strings in a macro.
+ */
+#define S1(x) #x
+#define S2(x) S1(x)
+#define LOCATION __FILE__ " : " S2(__LINE__)
+#define assert(f) (f ? 0 : caml_failwith("assertion failed: " LOCATION))
+#endif
+
 /****************************************************************************
  * Quoting the linux manpage: memfd_create() creates an anonymous file
  * and returns a file descriptor that refers to it. The file behaves
@@ -403,14 +412,23 @@ CAMLprim value hh_log_level(void) {
 
 CAMLprim value hh_hash_used_slots(void) {
   CAMLparam0();
-  uint64_t count = 0;
+  uint64_t filled_slots = 0;
+  uint64_t nonempty_slots = 0;
   uintptr_t i = 0;
   for (i = 0; i < hashtbl_size; ++i) {
     if (hashtbl[i].addr != NULL) {
-      count++;
+      filled_slots++;
+    }
+    if (hashtbl[i].hash != 0) {
+      nonempty_slots++;
     }
   }
-  CAMLreturn(Val_long(count));
+  assert(nonempty_slots == *hcounter);
+  value connector = caml_alloc_tuple(2);
+  Field(connector, 0) = Val_long(filled_slots);
+  Field(connector, 1) = Val_long(nonempty_slots);
+
+  CAMLreturn(connector);
 }
 
 CAMLprim value hh_hash_slots(void) {
@@ -486,7 +504,7 @@ static void raise_failed_anonymous_memfd_init() {
 }
 
 static void raise_less_than_minimum_available(uint64_t avail) {
-  CAMLlocal1(arg);
+  value arg;
   static value *exn = NULL;
   if (!exn) exn = caml_named_value("less_than_minimum_available");
   arg = Val_long(avail);
@@ -877,15 +895,6 @@ CAMLprim value hh_shared_init(
   CAMLreturn(connector);
 }
 
-void hh_shared_reset() {
-#ifndef _WIN32
-  assert(shared_mem);
-  early_counter = 1;
-  memset(shared_mem, 0, heap_init - shared_mem);
-  init_shared_globals(0);
-#endif
-}
-
 /* Must be called by every worker before any operation is performed */
 value hh_connect(value connector, value is_master) {
   CAMLparam2(connector, is_master);
@@ -1448,7 +1457,7 @@ static void raise_hash_table_full() {
 void hh_add(value key, value data) {
   uint64_t hash = get_hash(key);
   unsigned int slot = hash & (hashtbl_size - 1);
-
+  unsigned int init_slot = slot;
   while(1) {
     uint64_t slot_hash = hashtbl[slot].hash;
 
@@ -1492,6 +1501,10 @@ void hh_add(value key, value data) {
     }
 
     slot = (slot + 1) & (hashtbl_size - 1);
+    if (slot == init_slot) {
+      // We're never going to find a spot
+      raise_hash_table_full();
+    }
   }
 }
 
@@ -1503,7 +1516,7 @@ void hh_add(value key, value data) {
 static unsigned int find_slot(value key) {
   uint64_t hash = get_hash(key);
   unsigned int slot = hash & (hashtbl_size - 1);
-
+  unsigned int init_slot = slot;
   while(1) {
     if(hashtbl[slot].hash == hash) {
       return slot;
@@ -1512,6 +1525,10 @@ static unsigned int find_slot(value key) {
       return slot;
     }
     slot = (slot + 1) & (hashtbl_size - 1);
+
+    if (slot == init_slot) {
+      raise_hash_table_full();
+    }
   }
 }
 
@@ -1585,6 +1602,10 @@ void hh_move(value key1, value key2) {
   assert_master();
   assert(hashtbl[slot1].hash == get_hash(key1));
   assert(hashtbl[slot2].addr == NULL);
+  // We are taking up a previously empty slot. Let's increment the counter.
+  if (hashtbl[slot2].hash == 0) {
+    __sync_fetch_and_add(hcounter, 1);
+  }
   hashtbl[slot2].hash = get_hash(key2);
   hashtbl[slot2].addr = hashtbl[slot1].addr;
   hashtbl[slot1].addr = NULL;
@@ -1601,7 +1622,6 @@ void hh_remove(value key) {
   assert_master();
   assert(hashtbl[slot].hash == get_hash(key));
   hashtbl[slot].addr = NULL;
-  __sync_fetch_and_sub(hcounter, 1);
 }
 
 /*****************************************************************************/
diff --git a/hphp/hack/src/heap/sharedMem.ml b/hphp/hack/src/heap/sharedMem.ml
index 536cca0..f5a6fea 100644
--- a/hphp/hack/src/heap/sharedMem.ml
+++ b/hphp/hack/src/heap/sharedMem.ml
@@ -124,8 +124,6 @@ let init config =
 
 external connect : handle -> is_master:bool -> unit = "hh_connect"
 
-external reset: unit -> unit = "hh_shared_reset"
-
 (*****************************************************************************)
 (* The shared memory garbage collector. It must be called every time we
  * free data (cf hh_shared.c for the underlying C implementation).
@@ -158,7 +156,7 @@ external hh_log_level : unit -> int = "hh_log_level"
 (*****************************************************************************)
 (* The number of used slots in our hashtable *)
 (*****************************************************************************)
-external hash_used_slots : unit -> int = "hh_hash_used_slots"
+external hash_used_slots : unit -> int * int = "hh_hash_used_slots"
 
 (*****************************************************************************)
 (* The total number of slots in our hashtable *)
@@ -189,19 +187,26 @@ let init_done () =
   EventLogger.sharedmem_init_done (heap_size ())
 
 type table_stats = {
+  nonempty_slots : int;
   used_slots : int;
   slots : int;
 }
 
-let dep_stats () = {
-  used_slots = dep_used_slots ();
-  slots = dep_slots ();
-}
-
-let hash_stats () = {
-  used_slots = hash_used_slots ();
-  slots = hash_slots ();
-}
+let dep_stats () =
+  let used = dep_used_slots () in
+  {
+    nonempty_slots = used;
+    used_slots = used;
+    slots = dep_slots ();
+  }
+
+let hash_stats () =
+  let used_slots, nonempty_slots = hash_used_slots () in
+  {
+    nonempty_slots;
+    used_slots;
+    slots = hash_slots ();
+  }
 
 let collect (effort : [ `gentle | `aggressive ]) =
   let old_size = heap_size () in
diff --git a/hphp/hack/src/heap/sharedMem.mli b/hphp/hack/src/heap/sharedMem.mli
index 0c3eaa0..3ea5d31 100644
--- a/hphp/hack/src/heap/sharedMem.mli
+++ b/hphp/hack/src/heap/sharedMem.mli
@@ -50,13 +50,6 @@ val init: config -> handle
 val connect: handle -> is_master:bool -> unit
 
 (*****************************************************************************)
-(* Resets the initialized and used memory to the state right after
- * initialization.
- *)
-(*****************************************************************************)
-val reset: unit -> unit
-
-(*****************************************************************************)
 (* The shared memory garbage collector. It must be called every time we
  * free data (cf hh_shared.c for the underlying C implementation).
  *)
@@ -92,6 +85,7 @@ val heap_size : unit -> int
 (*****************************************************************************)
 
 type table_stats = {
+  nonempty_slots : int;
   used_slots : int;
   slots : int;
 }
diff --git a/hphp/hack/src/hh_single_type_check.ml b/hphp/hack/src/hh_single_type_check.ml
index c6f23a6..def13ac 100644
--- a/hphp/hack/src/hh_single_type_check.ml
+++ b/hphp/hack/src/hh_single_type_check.ml
@@ -13,6 +13,8 @@ open Coverage_level
 open String_utils
 open Sys_utils
 
+module TNBody       = Typing_naming_body
+
 (*****************************************************************************)
 (* Types, constants *)
 (*****************************************************************************)
@@ -24,6 +26,7 @@ type mode =
   | Coverage
   | Dump_symbol_info
   | Dump_inheritance
+  | Dump_tast
   | Errors
   | Lint
   | Suggest
@@ -155,6 +158,9 @@ let builtins =
   "function is_string(mixed $x): bool {}\n"^
   "function is_null(mixed $x): bool {}\n"^
   "function is_array(mixed $x): bool {}\n"^
+  "function is_vec(mixed $x): bool {}\n"^
+  "function is_dict(mixed $x): bool {}\n"^
+  "function is_keyset(mixed $x): bool {}\n"^
   "function is_resource(mixed $x): bool {}\n"^
   "interface IMemoizeParam {\n"^
   "  public function getInstanceKey(): string;\n"^
@@ -194,7 +200,7 @@ let builtins =
   "interface Indexish<+Tk, +Tv> extends KeyedContainer<Tk, Tv> {}\n"^
   "abstract final class dict<+Tk, +Tv> implements Indexish<Tk, Tv> {}\n"^
   "function dict<Tk, Tv>(KeyedTraversable<Tk, Tv> $arr): dict<Tk, Tv> {}\n"^
-  "abstract final class keyset<T as arraykey> implements Indexish<T, T> {}\n"^
+  "abstract final class keyset<+T as arraykey> implements Indexish<T, T> {}\n"^
   "abstract final class vec<+Tv> implements Indexish<int, Tv> {}\n"^
   "function meth_caller(string $cls_name, string $meth_name);\n"
 
@@ -240,6 +246,9 @@ let parse_options () =
     "--dump-symbol-info",
       Arg.Unit (set_mode Dump_symbol_info),
       "Dump all symbol information";
+    "--dump-tast",
+      Arg.Unit (set_mode Dump_tast),
+      "Check for errors then dump the Typed AST";
     "--lint",
       Arg.Unit (set_mode Lint),
       "Produce lint errors";
@@ -412,6 +421,38 @@ let print_symbol (symbol, definition) =
       ~f:(fun x -> Pos.multiline_string_no_file x.SymbolDefinition.span)
       ~default:"None")
 
+let check_errors tcopt errors files_info =
+  Relative_path.Map.fold files_info ~f:begin fun fn fileinfo errors ->
+    errors @ Errors.get_error_list
+        (Typing_check_utils.check_defs tcopt fn fileinfo)
+  end ~init:errors
+
+let with_named_body tcopt n_fun =
+  (** In the naming heap, the function bodies aren't actually named yet, so
+   * we need to invoke naming here.
+   * See also docs in Naming.Make. *)
+  let n_f_body = TNBody.func_body tcopt n_fun in
+  { n_fun with Nast.f_body = Nast.NamedBody n_f_body }
+
+let n_fun_fold tcopt fn acc (_, fun_name) =
+  match Parser_heap.find_fun_in_file fn fun_name with
+  | None -> acc
+  | Some f ->
+    let n_fun = Naming.fun_ tcopt f in
+    (with_named_body tcopt n_fun) :: acc
+
+let n_class_fold _tcopt _fn acc _class_name = acc
+let n_type_fold _tcopt _fn acc _type_name = acc
+let n_const_fold _tcopt _fn acc _const_name = acc
+
+(** Load the Nast for the file from the Nast heaps. *)
+let nast_for_file tcopt fn
+{ FileInfo.funs; classes; typedefs; consts; _} =
+  List.fold_left funs ~init:[] ~f:(n_fun_fold tcopt fn),
+  List.fold_left classes ~init:[] ~f:(n_class_fold tcopt fn),
+  List.fold_left typedefs ~init:[] ~f:(n_type_fold tcopt fn),
+  List.fold_left consts ~init:[] ~f:(n_const_fold tcopt fn)
+
 let handle_mode mode filename tcopt files_contents files_info errors =
   match mode with
   | Ai _ -> ()
@@ -533,16 +574,33 @@ let handle_mode mode filename tcopt files_contents files_info errors =
     ClientHighlightRefs.go results ~output_json:false;
   | Suggest
   | Errors ->
-      let errors =
-        Relative_path.Map.fold files_info ~f:begin fun fn fileinfo errors ->
-          errors @ Errors.get_error_list
-              (Typing_check_utils.check_defs tcopt fn fileinfo)
-        end ~init:errors in
+      let errors = check_errors tcopt errors files_info in
       if mode = Suggest
       then Relative_path.Map.iter files_info suggest_and_print;
       if errors <> []
       then (error (List.hd_exn errors); exit 2)
       else Printf.printf "No errors\n"
+  | Dump_tast ->
+      let pos_ty_map = ref Pos.Map.empty in
+      Typing_hooks.attach_infer_ty_hook (Typed_ast.save_ty pos_ty_map);
+      let errors = check_errors tcopt errors files_info in
+      Typing_hooks.remove_all_hooks ();
+      let nasts = Relative_path.Map.fold files_info
+        ~f:begin fun fn fileinfo nasts ->
+          Relative_path.Map.add nasts ~key:fn
+          ~data:(nast_for_file tcopt fn fileinfo)
+        end ~init:Relative_path.Map.empty
+      in
+      if errors <> []
+      then (error (List.hd_exn errors); exit 2);
+      Relative_path.Map.iter nasts ~f:begin fun fn nast ->
+        if (Relative_path.S.compare fn builtins_filename) = 0 then ()
+        else begin
+          Printf.eprintf "%s:\n%s\n"
+            (Relative_path.S.to_string fn)
+            (Typed_ast_printer.print_string !pos_ty_map nast)
+        end
+      end
 
 (*****************************************************************************)
 (* Main entry point *)
diff --git a/hphp/hack/src/hhas/hhasBytecodeIst.ml b/hphp/hack/src/hhas/hhasBytecodeIst.ml
new file mode 100644
index 0000000..2e3b566
--- /dev/null
+++ b/hphp/hack/src/hhas/hhasBytecodeIst.ml
@@ -0,0 +1,182 @@
+(*****************************************************************************)
+(* An IST for the HHVM bytecode *)
+(*****************************************************************************)
+
+open SharedCollections
+
+type ident = Id of string
+type name = string
+type label = string
+
+type class_kind =
+  | KClass (** Plain old class. *)
+  | KInterface
+  | KFinalClass
+  | KTrait
+  | KAbstractFinal
+
+type type_ =
+  | Tany
+  | Tvoid
+  | Tapply of applied_type
+  | Ttuple of type_ list
+  | Tfun of type_ list * type_
+  | Tparam of name * type_ option
+  | Tthis of type_
+  | Tinst of type_
+  | Tinter of applied_type list
+
+and applied_type = name * type_ list
+
+type attribute =
+  | AttrStatic
+  | AttrAbstract
+  | AttrPublic
+  | AttrPrivate
+  | AttrMayusevv
+
+type program = {
+    class_defs      : class_def UMap.t;
+    fun_defs        : fun_def UMap.t;
+  }
+
+and class_def = {
+    cla_name        : ident;
+    cla_kind        : class_kind;
+    cla_implements  : ident list;
+    cla_extends     : ident list;
+    cla_properties  : (string * attribute list) list;
+    cla_uses        : type_ list UMap.t;
+    cla_met_use     : (name * name list) UMap.t;
+    cla_types       : (string * ident * type_) UMap.t;
+    cla_methods     : method_def UMap.t;
+    cla_constructor : method_def;
+    cla_lambdas     : lambda_def UMap.t;
+  }
+
+and type_hint = {
+    tyh_user        : type_;
+    tyh_hhvm        : (ident * hint_flag list) option;
+  }
+
+and hint_flag =
+  | HintVar
+  | HintExtended
+  | HintSoft
+
+and method_def = {
+    met_name        : string;
+    met_attrs       : attribute list;
+    met_return      : type_hint;
+    met_params      : parameter list;
+    met_locals      : SSet.t;
+    met_async       : bool;
+    met_blocks      : blocks;
+  }
+
+and fun_def = {
+    fun_name        : ident;
+    fun_attrs       : attribute list;
+    fun_return      : type_hint;
+    fun_params      : parameter list;
+    fun_locals      : SSet.t;
+    fun_async       : bool;
+    fun_blocks      : blocks;
+    fun_lambdas     : lambda_def UMap.t;
+  }
+
+and parameter = string * type_hint
+
+and lambda_def = {
+    lam_name        : ident;
+    lam_kind        : lambda_kind;
+    lam_params      : string list;
+    lam_uses        : SSet.t;
+    lam_locals      : SSet.t;
+    lam_blocks      : blocks;
+  }
+
+and lambda_kind =
+  | LamAsyncBlock
+  | LamNormal of bool (* async *)
+
+and blocks = block list
+
+and block =
+  | BSimple of simple_block
+  | BTryCatch of blocks * catch_block list
+
+and catch_block = ident * label * blocks
+and simple_block = label option * instr list * jump
+
+and jump =
+  | JNext
+  | JJmp of label
+  | JJmpZ of label
+  | JJmpNZ of label
+  | JRetC
+  | JThrow
+  | JFatal of fatal
+
+and fatal =
+  | FatalRuntimeOmitFrame
+
+and instr =
+  | IAGetC
+  | IAdd
+  | IAwait
+  | IBareThis
+  | IBaseC of int
+  | IBaseH
+  | IBaseL of string
+  | ICGetL of string
+  | ICUGetL of string
+  | ICatch
+  | ICheckThis
+  | IClsCns of string
+  | IConcat
+  | ICreateCl of int * ident
+  | IDim of member
+  | IDiv
+  | IDouble of float
+  | IDup
+  | IEq
+  | IFCall of int
+  | IFPassCE of int
+  | IFPushClsMethod of int
+  | IFPushClsMethodD of int * string * ident
+  | IFPushCtor of int
+  | IFPushCtorD of int * ident
+  | IFPushFunc of int
+  | IFPushFuncD of int * ident
+  | IFPushObjMethodD of int * string
+  | IFalse
+  | IGt
+  | IGte
+  | IInstanceOfD of ident
+  | IInt of Int64.t
+  | IIsTypeCNull
+  | ILateBoundCls
+  | ILt
+  | ILte
+  | IMod
+  | IMul
+  | INameA
+  | INeq
+  | INewPackedArray of int
+  | INot
+  | INull
+  | IPopC
+  | IPopR
+  | IQueryM of int * member
+  | ISetL of string
+  | ISetM of int * member
+  | IString of string
+  | IStringId of ident
+  | ISub
+  | ITrue
+  | IUnboxR
+
+and member =
+  | MembField of string
+  | MembIndex of int
diff --git a/hphp/hack/src/hhas/hhasBytecodePp.ml b/hphp/hack/src/hhas/hhasBytecodePp.ml
new file mode 100644
index 0000000..a034f1a
--- /dev/null
+++ b/hphp/hack/src/hhas/hhasBytecodePp.ml
@@ -0,0 +1,430 @@
+open BufferedPrinter
+open HhasBytecodeIst
+open SharedCollections
+
+let map_illegals str =
+  String.map begin function
+    | '!' -> '$'
+    | '@' -> '.'
+    | c -> c
+  end str
+
+let variable str = "$" ^ map_illegals str
+
+let qual_name s =
+  if s <> "" && s.[0] = '\\'
+  then map_illegals (String.sub s 1 (String.length s - 1))
+  else failwith ("Missing namespace for name " ^ s)
+
+let ident (Id s) = qual_name s
+
+let string o s =
+  o#out_char '"';
+  String.iter (function
+      | '"' -> o#out "\\\""
+      | '\\' -> o#out "\\\\"
+      | c -> o#out_char c
+    ) s;
+  o#out_char '"'
+
+let attributes o attrs =
+  let attr o = function
+    | AttrStatic -> o#out "static"
+    | AttrAbstract -> o#out "abstract"
+    | AttrPublic -> o#out "public"
+    | AttrPrivate -> o#out "private"
+    | AttrMayusevv -> o#out "mayusevv"
+  in
+  let attrs = List.sort_uniq compare attrs in
+  o#out "["; list ~sep:" " attr o attrs; o#out "]"
+
+let rec to_files dir { class_defs; fun_defs; } =
+  let o = new_out () in
+  UMap.iter (fun _ cd ->
+      let o = new_out () in
+      pseudo_main o 1;
+      class_def o cd;
+      out_to_file o (dir ^ "/" ^ ident cd.cla_name ^ ".hhas")
+    ) class_defs;
+  pseudo_main o 0;
+  UMap.iter (fun _ fd -> fun_def o fd) fun_defs;
+  out_to_file o (dir ^ "/rx.hhas")
+
+and pseudo_main o nclasses =
+  o#out ".main {";
+  o#newline;
+  o#margin begin fun () ->
+    for i = 1 to nclasses do
+      o#out (Printf.sprintf "DefCls %d" (i-1));
+      o#newline
+    done;
+    o#out "Int 1";
+    o#newline;
+    o#out "RetC";
+    o#newline
+  end;
+  o#out "}";
+  o#newline
+
+and class_def o cd =
+  o#out ".class ";
+  begin match cd.cla_kind with
+    | KClass -> ()
+    | KInterface -> o#out "[interface] "
+    | KFinalClass -> o#out "[final] "
+    | KTrait -> o#out "[final trait] "
+    | KAbstractFinal -> o#out "[abstract final] " end;
+  o#out (ident cd.cla_name);
+  if cd.cla_extends <> [] then begin
+    o#out " extends ";
+    list ~sep:" " (fun o c -> o#out (ident c)) o cd.cla_extends;
+  end;
+  if cd.cla_implements <> [] then begin
+    o#out " implements (";
+    list ~sep:" " (fun o c -> o#out (ident c)) o cd.cla_implements;
+    o#out ")";
+  end;
+  o#out " {";
+  o#newline;
+  o#margin begin fun () ->
+    uses o cd.cla_uses cd.cla_met_use;
+    type_defs o cd.cla_types;
+    (* TODO require extends is not supported by the
+       HHAS parser yet, c.f. task 12483869 *)
+    UMap.iter (fun _ md -> method_def o md) cd.cla_methods;
+    method_def o cd.cla_constructor;
+    List.iter (property o) cd.cla_properties
+  end;
+  o#out "}";
+  o#newline;
+  lambdas o cd.cla_lambdas
+
+and uses o traits conflicts =
+  let traits = UMap.key_values traits in
+  if traits <> [] then begin
+    o#out  ".use ";
+    list ~sep:" "
+      (fun o (n, _) -> o#out (qual_name n))
+      o traits;
+    if UMap.for_all (fun _ (_, c) -> c = []) conflicts
+    then o#out ";"
+    else begin
+      o#out " {";
+      o#newline;
+      o#margin begin fun () ->
+        UMap.iter (fun met_name (cla_name, conflicted) ->
+            if conflicted <> [] then begin
+              o#out (qual_name cla_name);
+              o#out "::";
+              o#out (map_illegals met_name);
+              o#out " insteadof ";
+              list ~sep:" "
+                (fun o n -> o#out (qual_name n))
+                o conflicted;
+              o#out ";";
+              o#newline;
+            end
+          ) conflicts;
+      end;
+      o#out "}";
+    end;
+    o#newline;
+  end
+
+and type_defs o types =
+  (* TODO
+     make sure type parameters can indeed be ignored
+     make sure the abstract type constants can be serialized
+  *)
+  let type_kind = function
+    (* see hphp/runtime/base/type-structure.h *)
+    | "void" -> Some 0
+    | "HH\\int" -> Some 1
+    | "HH\\bool" -> Some 2
+    | "HH\\float" -> Some 3
+    | "HH\\string" -> Some 4
+    | "HH\\arraykey" -> Some 7
+    | "HH\\array" -> Some 12
+    | "HH\\dict" -> Some 19
+    | "HH\\vec" -> Some 20
+    | "HH\\keyset" -> Some 21
+    | s ->
+      assert (String.length s < 3 || String.sub s 0 3 <> "HH\\");
+      None
+  in
+  UMap.iter (fun _ (name, tother, _typ) ->
+      let tother = ident tother in
+      o#out ".const ";
+      o#out (map_illegals name);
+      o#out " isType = ";
+      (match type_kind tother with
+      | Some n ->
+        o#out (Printf.sprintf "\"\"\"a:1:{s:4:\\\"kind\\\";i:%d;}\"\"\"" n)
+      | None ->
+        let len = String.length tother in
+        o#out "\"\"\"a:2:{s:4:\\\"kind\\\";i:101;s:9:\\\"classname\\\";s:";
+        o#out (Printf.sprintf "%d:\\\"%s\\\";}\"\"\"" len tother);
+      );
+      o#out ";";
+      o#newline
+    ) types
+
+and type_user ty =
+  match ty with
+  | Tany -> "HH\\mixed"
+  | Tvoid -> "HH\\void"
+  | Tapply (n, []) -> qual_name n
+  | Tapply (n, tyl) ->
+    let tyl = List.map type_user tyl in
+    Printf.sprintf "%s<%s>"
+      (qual_name n)
+      (String.concat ", " tyl)
+  | Ttuple tyl ->
+    let tyl = List.map type_user tyl in
+    Printf.sprintf "(%s)"
+      (String.concat ", " tyl)
+  | Tfun (fty_params, fty_return) ->
+    let fty_params = List.map type_user fty_params in
+    Printf.sprintf "(function (%s): %s)"
+      (String.concat ", " fty_params)
+      (type_user fty_return)
+  | Tparam (n, _) -> map_illegals n
+  | Tinst _ -> "@inst"
+  | Tthis _ -> "HH\\this"
+  | Tinter _ -> assert false
+
+and type_hint o tyh =
+  o#out "< ";
+  let t = type_user tyh.tyh_user in
+  string o t;
+  o#space;
+  (match tyh.tyh_hhvm with
+  | Some (t, fl) ->
+    let type_flag o = function
+      | HintVar -> o#out "type_var"
+      | HintExtended -> o#out "extended_hint"
+      | HintSoft -> o#out "soft"
+    in
+    string o (ident t);
+    o#out " hh_type";
+    let fl = List.sort_uniq compare fl in
+    if fl <> [] then o#space;
+    list ~sep:" " type_flag o fl
+  | None -> o#out "N"
+  );
+  o#out " >"
+
+and lambdas o ls =
+  UMap.iter (fun _ -> lambda o) ls
+and lambda o lam =
+  o#out ".class [no_override unique] ";
+  o#out (ident lam.lam_name);
+  o#out " extends Closure {";
+  o#newline;
+  o#margin begin fun () ->
+    SSet.iter (fun p ->
+        property o ~uninit:true (p, [AttrPublic])
+      ) lam.lam_uses;
+    o#out ".method ";
+    attributes o begin
+      if lam.lam_kind = LamAsyncBlock
+      then [AttrPublic; AttrStatic; AttrMayusevv]
+      else [AttrPublic; AttrMayusevv]
+    end;
+    o#out " < \"\" N > __invoke(";
+    list (fun o p -> o#out (variable p)) o lam.lam_params;
+    o#out ")";
+    if lam.lam_kind = LamNormal true
+    || lam.lam_kind = LamAsyncBlock
+    then o#out " isAsync";
+    o#out " isClosureBody {";
+    o#newline;
+    o#margin begin fun () ->
+      declvars o ~closure:lam.lam_uses lam.lam_locals;
+      blocks o lam.lam_blocks
+    end;
+    o#out "}";
+    o#newline
+  end;
+  o#out "}";
+  o#newline
+
+and property o ?(uninit = false) (pname, pattrs) =
+  o#out ".property ";
+  attributes o pattrs;
+  o#space;
+  o#out (map_illegals pname);
+  if uninit
+  then o#out " = uninit;"
+  else o#out " = \"\"\"N;\"\"\";";
+  o#newline
+
+and method_def o md =
+  o#out ".method ";
+  attributes o md.met_attrs;
+  o#space;
+  type_hint o md.met_return;
+  o#space;
+  o#out (map_illegals md.met_name);
+  fun_params o md.met_params;
+  if md.met_async then o#out " isAsync";
+  o#out " {";
+  o#newline;
+  o#margin begin fun () ->
+    declvars o md.met_locals;
+    blocks o md.met_blocks
+  end;
+  o#out "}";
+  o#newline
+
+and fun_def o fd =
+  o#out ".function ";
+  attributes o fd.fun_attrs;
+  o#space;
+  type_hint o fd.fun_return;
+  o#space;
+  o#out (ident fd.fun_name);
+  fun_params o fd.fun_params;
+  if fd.fun_async then o#out " isAsync";
+  o#out " {";
+  o#newline;
+  o#margin begin fun () ->
+    declvars o fd.fun_locals;
+    blocks o fd.fun_blocks
+  end;
+  o#out "}";
+  o#newline;
+  lambdas o fd.fun_lambdas
+
+and fun_params o params =
+  let parameter o (p, tyh) =
+    type_hint o tyh;
+    o#space;
+    o#out (variable p)
+  in
+  o#out "(";
+  list parameter o params;
+  o#out ")"
+
+and declvars o ?closure locals =
+  if closure <> None || not (SSet.is_empty locals) then
+  begin
+    let pset s = SSet.iter (fun n -> o#space; o#out (variable n)) s in
+    o#out ".declvars";
+    (match closure with
+    | None -> ()
+    | Some use -> o#out " $0Closure"; pset use
+    );
+    pset locals;
+    o#out_char ';';
+    o#newline
+  end
+
+and blocks o = List.iter (block o)
+and block o = function
+  | BSimple (lbl, instrs, jmp) ->
+    (match lbl with
+    | None -> ()
+    | Some l ->
+      o#newline;
+      o#out l;
+      o#out_char ':';
+      o#newline
+    );
+    List.iter (instr o) instrs;
+    jump o jmp
+  | BTryCatch (btry, bcatches) ->
+    o#out ".try_catch ";
+    List.iter (fun (ty, lbl, _) ->
+        o#out ("(" ^ ident ty ^ " " ^ lbl ^ ") ")
+      ) bcatches;
+    o#out "{";
+    o#newline;
+    o#margin begin fun () ->
+      blocks o btry
+    end;
+    o#out "}";
+    o#newline;
+    List.iter (fun (_, _, cb) -> blocks o cb) bcatches
+
+and jump o = function
+  | JNext -> ()
+  | JJmp lbl -> o#out ("Jmp " ^ lbl); o#newline
+  | JJmpZ lbl -> o#out ("JmpZ " ^ lbl); o#newline
+  | JJmpNZ lbl -> o#out ("JmpNZ " ^ lbl); o#newline
+  | JRetC -> o#out "RetC"; o#newline
+  | JThrow -> o#out "Throw"; o#newline
+  | JFatal FatalRuntimeOmitFrame ->
+    o#out "Fatal RuntimeOmitFrame"; o#newline
+
+and instr o i =
+  instr_ o i;
+  o#newline
+and instr_ o i =
+  let f = Printf.sprintf in
+  match i with
+  | IAGetC -> o#out "AGetC"
+  | IAdd -> o#out "Add"
+  | IAwait -> o#out "Await"
+  | IBareThis -> o#out "BareThis Notice"
+  | IBaseC slot -> o#out (f "BaseC %d" slot)
+  | IBaseH -> o#out "BaseH"
+  | IBaseL var -> o#out (f "BaseL %s Warn" (variable var))
+  | ICGetL var -> o#out (f "CGetL %s" (variable var))
+  | ICUGetL var -> o#out (f "CUGetL %s" (variable var))
+  | ICatch -> o#out "Catch"
+  | ICheckThis -> o#out "CheckThis"
+  | IClsCns cns -> o#out "ClsCns "; string o cns
+  | IConcat -> o#out "Concat"
+  | ICreateCl (n, id) -> o#out (f "CreateCl %d " n); string o (ident id)
+  | IDim mem -> o#out "Dim Warn "; member o mem
+  | IDiv -> o#out "Div"
+  | IDouble flt -> o#out "Double "; o#out (string_of_float flt)
+  | IDup -> o#out "Dup"
+  | IEq -> o#out "Eq"
+  | IFCall n -> o#out (f "FCall %d" n)
+  | IFPassCE n -> o#out (f "FPassCE %d" n)
+  | IFPushClsMethod n -> o#out (f "FPushClsMethod %d" n)
+  | IFPushClsMethodD (n, met, cls) ->
+    o#out (f "FPushClsMethodD %d " n);
+    string o (map_illegals met);
+    o#space;
+    string o (ident cls)
+  | IFPushCtor n -> o#out (f "FPushCtor %d" n)
+  | IFPushCtorD (n, cls) -> o#out (f "FPushCtorD %d " n); string o (ident cls)
+  | IFPushFunc n -> o#out (f "FPushFunc %d" n)
+  | IFPushFuncD (n, fn) -> o#out (f "FPushFuncD %d " n); string o (ident fn)
+  | IFPushObjMethodD (n, met) ->
+    o#out (f "FPushObjMethodD %d " n);
+    string o (map_illegals met);
+    o#out " NullThrows"
+  | IFalse -> o#out "False"
+  | IGt -> o#out "Gt"
+  | IGte -> o#out "Gte"
+  | IInstanceOfD cls -> o#out "InstanceOfD "; string o (ident cls)
+  | IInt n -> o#out "Int "; o#out (Int64.to_string n)
+  | IIsTypeCNull -> o#out "IsTypeC Null"
+  | ILateBoundCls -> o#out "LateBoundCls"
+  | ILt -> o#out "Lt"
+  | ILte -> o#out "Lte"
+  | IMod -> o#out "Mod"
+  | IMul -> o#out "Mul"
+  | INameA -> o#out "NameA"
+  | INeq -> o#out "Neq"
+  | INewPackedArray n -> o#out (f "NewPackedArray %d" n)
+  | INot -> o#out "Not"
+  | INull -> o#out "Null"
+  | IPopC -> o#out "PopC"
+  | IPopR -> o#out "PopR"
+  | IQueryM (n, mem) -> o#out (f "QueryM %d CGet " n); member o mem
+  | ISetL var -> o#out (f "SetL %s" (variable var))
+  | ISetM (n, mem) -> o#out (f "SetM %d " n); member o mem
+  | IString str -> o#out "String "; string o str
+  | IStringId id -> o#out "String "; string o (ident id)
+  | ISub -> o#out "Sub"
+  | ITrue -> o#out "True"
+  | IUnboxR -> o#out "UnboxR"
+
+and member o = function
+  | MembField s -> o#out "PT:"; string o (map_illegals s)
+  | MembIndex i -> o#out "EI:"; o#out (string_of_int i)
diff --git a/hphp/hack/src/hhas/shared/bufferedPrinter.ml b/hphp/hack/src/hhas/shared/bufferedPrinter.ml
new file mode 100644
index 0000000..396b18a
--- /dev/null
+++ b/hphp/hack/src/hhas/shared/bufferedPrinter.ml
@@ -0,0 +1,61 @@
+let rec list ?(sep=", ") f o l =
+  match l with
+  | [] -> ()
+  | [x] -> f o x
+  | x :: rl -> f o x; o#out sep; list ~sep f o rl
+
+let name o (_, x) = o#out x
+
+class out buf = object(self)
+  val mutable margin: int = 0
+  val mutable last_was_nl: bool = true
+
+  method private pad =
+    if last_was_nl then
+      for i = 1 to margin do
+        Buffer.add_char buf ' '
+      done;
+    last_was_nl <- false;
+
+  method out x =
+    self#pad;
+    Buffer.add_string buf x
+
+  method out_char c =
+    self#pad;
+    Buffer.add_char buf c
+
+  method newline =
+    last_was_nl <- true;
+    Buffer.add_char buf '\n'
+
+  method space =
+    last_was_nl <- false;
+    Buffer.add_char buf ' '
+
+  method margin f =
+    margin <- margin + 2;
+    let () = f() in
+    margin <- margin - 2;
+    ()
+
+  method contents () =
+    Buffer.contents buf
+
+end
+
+let new_out () =
+  let buf = Buffer.create 256 in
+  new out buf
+
+let pp f ast =
+  let o = new_out () in
+  let _ = f o ast in
+  let str = o#contents () in
+  output_string stdout str;
+  print_newline ()
+
+let out_to_file o file =
+  let oc = open_out file in
+  Printf.fprintf oc "%s\n" (o#contents ());
+  close_out oc;
diff --git a/hphp/hack/src/hhas/shared/sharedCollections.ml b/hphp/hack/src/hhas/shared/sharedCollections.ml
new file mode 100644
index 0000000..af52ddf
--- /dev/null
+++ b/hphp/hack/src/hhas/shared/sharedCollections.ml
@@ -0,0 +1,250 @@
+(*****************************************************************************)
+(* Exceptions *)
+(*****************************************************************************)
+exception Error_name_already_bound of string * Pos.t * Pos.t
+exception Error_unbound_name of string * Pos.t
+
+(*****************************************************************************)
+(* Set/Map etc ... *)
+(*****************************************************************************)
+
+module SSet = struct
+  include Set.Make(String)
+
+  let of_list l =
+    List.fold_left (fun acc name -> add name acc) empty l
+
+end
+
+module IMap = struct
+
+  include Map.Make(struct
+    type t = int
+    let compare = (-)
+  end)
+
+  let get x t = try Some (find x t) with Not_found -> None
+  let values t = List.rev (fold (fun _ x y -> x :: y) t [])
+
+  let of_list l =
+    List.fold_left (fun acc (k, v) -> add k v acc) empty l
+
+  let merge_fst m1 m2 =
+    merge (fun _ vo1 vo2 -> match vo1, vo2 with
+    | Some _, _ -> vo1
+    | _, Some _ -> vo2
+    | None, None -> assert false)
+    m1 m2
+end
+
+module ISet = struct
+
+  include Set.Make(struct
+    type t = int
+    let compare = (-)
+  end)
+end
+
+module SMap = struct
+  include Map.Make(String)
+  let get x map = try Some (find x map) with Not_found -> None
+  let union map1 map2 = fold add map1 map2
+
+  let get_list x map =
+    try find x map with Not_found -> []
+
+  let add_list x y map =
+    let l = get_list x map in
+    let l = y :: l in
+    add x l map
+
+  let get_smap x map =
+    try find x map with Not_found -> empty
+
+  let get_sset x map =
+    try find x map with Not_found -> SSet.empty
+
+  let map_fold f acc m =
+    fold begin fun x v (acc, result) ->
+      let acc, v = f acc v in
+      let result = add x v result in
+      acc, result
+    end m (acc, empty)
+
+  let key_set t = fold (fun k _ y -> SSet.add k y) t SSet.empty
+  let values t = List.rev (fold (fun _ x y -> x :: y) t [])
+  let key_values t = List.rev (fold (fun k x y -> (k, x) :: y) t [])
+
+end
+
+(*****************************************************************************)
+(* A string map where all the elements are unique.
+ * An error is thrown when that is not the case.
+ *)
+(*****************************************************************************)
+module UMap: sig
+  type 'a t
+  val empty: 'a t
+  val cardinal: 'a t -> int
+  val is_empty: 'a t -> bool
+  val (@@): ((Pos.t * string) * 'a) -> 'a t -> 'a t
+  val add: (Pos.t * string) -> 'a -> 'a t -> 'a t
+  val remove: string -> 'a t -> 'a t
+  val remove_pos: (Pos.t * string) -> 'a t -> 'a t
+  val replace: string -> 'a -> 'a t -> 'a t
+  val add_replace: (Pos.t * string) -> 'a -> 'a t -> 'a t
+  val mem: string -> 'a t -> bool
+  val mem_pos: (Pos.t * string) -> 'a t -> bool
+  val get: string -> 'a t -> 'a option
+  val get_with_pos : string -> 'a t -> (Pos.t * 'a) option
+  val get_pos: (Pos.t * string) -> 'a t -> 'a option
+  val find: (Pos.t * string) -> 'a t -> 'a
+  val find_unsafe: string -> 'a t -> 'a
+  val get_list: string -> 'a list t -> 'a list
+  val get_sset: string -> SSet.t t -> SSet.t
+  val get_sset_pos: (Pos.t * string) -> SSet.t t -> SSet.t
+  val union: 'a t -> 'a t -> 'a t
+  val iter: (string -> 'a -> unit) -> 'a t -> unit
+  val iter_pos: ((Pos.t * string) -> 'a -> unit) -> 'a t -> unit
+  val fold: (string -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
+  val fold_pos: ((Pos.t * string) -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
+  val map: ('a -> 'b) -> 'a t -> 'b t
+  val mapi: ((Pos.t * string) -> 'a -> 'b) -> 'a t -> 'b t
+  val values: 'a t -> 'a list
+  val key_values: 'a t -> (string * 'a) list
+  val key_pos_values: 'a t -> ((Pos.t * string) * 'a) list
+  val map_fold: ('acc -> 'a -> 'acc * 'b) -> 'acc -> 'a t -> 'acc * 'b t
+  val mapi_fold: ('acc -> (Pos.t * string) -> 'a -> 'acc * 'b)
+      -> 'acc -> 'a t -> 'acc * 'b t
+  val merge:
+      ('acc -> 'a -> 'a -> 'acc * 'a) -> 'acc -> 'a t -> 'a t -> 'acc * 'a t
+  val filter: (string -> 'a -> bool) -> 'a t -> 'a t
+  val key_list: 'a t -> string list
+  val key_set: 'a t -> SSet.t
+  val for_all : (string -> 'a -> bool) -> 'a t -> bool
+  val singleton : (Pos.t * string) -> 'a -> 'a t
+ end = struct
+
+  type 'a t = (Pos.t * 'a) SMap.t
+
+  let empty = SMap.empty
+
+  let cardinal = SMap.cardinal
+
+  let add (pos, name) value map =
+    if SMap.mem name map
+    then
+      let old_pos, _ = SMap.find name map in
+      raise (Error_name_already_bound (name, pos, old_pos))
+    else SMap.add name (pos, value) map
+
+  let remove = SMap.remove
+  let remove_pos (_, x) y = SMap.remove x y
+
+  let replace name value map =
+    try
+      let pos, _ = SMap.find name map in
+      SMap.add name (pos, value) map
+    with Not_found ->
+      failwith "Trying to replace a non-existent value"
+
+  let add_replace (pos, name) value map =
+    SMap.add name (pos, value) map
+
+  let mem = SMap.mem
+  let mem_pos (_, x) t = SMap.mem x t
+
+  let (@@) (name, value) map = add name value map
+
+  let union map1 map2 =
+    SMap.fold begin fun name (pos, value) acc ->
+      add (pos, name) value acc
+    end map1 map2
+
+  let get x t = try Some (snd (SMap.find x t)) with Not_found -> None
+  let get_with_pos x t = try Some (SMap.find x t) with Not_found -> None
+  let get_pos (_, x) t = try Some (snd (SMap.find x t)) with Not_found -> None
+  let get_list x t = try snd (SMap.find x t) with Not_found -> []
+  let get_sset x t = try snd (SMap.find x t) with Not_found -> SSet.empty
+  let get_sset_pos (_, x) t = get_sset x t
+
+  let find (pos, x) t =
+    try snd (SMap.find x t) with Not_found ->
+      raise (Error_unbound_name (x, pos))
+
+  let find_unsafe x t = snd (SMap.find x t)
+
+  let iter f = SMap.iter begin fun x (_, y) -> f x y end
+  let iter_pos f = SMap.iter begin fun x (pos, y) -> f (pos, x) y end
+
+  let fold f map acc =
+    SMap.fold begin fun name (_, value) acc ->
+      f name value acc
+    end map acc
+
+  let fold_pos f map acc =
+    SMap.fold begin fun name (pos, value) acc ->
+      f (pos, name) value acc
+    end map acc
+
+  let map f t =
+    SMap.map begin fun (pos, value) ->
+      let value = f value in
+      pos, value
+    end t
+
+  let mapi f t =
+    SMap.mapi begin fun key (pos, value) ->
+      let value = f (pos, key) value in
+      pos, value
+    end t
+
+  let values t = List.rev (fold (fun _ x y -> x :: y) t [])
+  let key_values t = List.rev (fold (fun k x y -> (k, x) :: y) t [])
+  let key_pos_values t = List.rev (fold_pos (fun k x y -> (k, x) :: y) t [])
+
+  let is_empty = SMap.is_empty
+
+  let map_fold f acc m =
+    SMap.fold begin fun x (pos, v) (acc, result) ->
+      let acc, v = f acc v in
+      let result = SMap.add x (pos, v) result in
+      acc, result
+    end m (acc, empty)
+
+  let mapi_fold f acc m =
+    SMap.fold begin fun x (pos, v) (acc, result) ->
+      let acc, v = f acc (pos, x) v in
+      let result = SMap.add x (pos, v) result in
+      acc, result
+    end m (acc, empty)
+
+  let merge f acc m1 m2 =
+    let acc, m =
+      fold_pos begin fun name value1 (acc, m) ->
+        match get (snd name) m2 with
+        | None -> acc, m
+        | Some value2 ->
+            let acc, value_ = f acc value1 value2 in
+            let m = add_replace name value_ m in
+            acc, m
+      end m1 (acc, m1)
+    in
+    let m =
+      fold_pos begin fun name value2 m ->
+        if not (mem (snd name) m1)
+        then add_replace name value2 m
+        else m
+      end m2 m
+    in
+    acc, m
+
+  let filter p m = SMap.filter (fun s (_, v) -> p s v) m
+  let key_list t = List.map fst (key_values t)
+  let key_set t = SSet.of_list (key_list t)
+
+  let for_all p m = SMap.for_all (fun s (_, v) -> p s v) m
+
+  let singleton (pos, s) v = SMap.singleton s (pos, v)
+
+end
diff --git a/hphp/hack/src/injection/default_injector/injector_config.ml b/hphp/hack/src/injection/default_injector/injector_config.ml
index 08d80e2..c67d449 100644
--- a/hphp/hack/src/injection/default_injector/injector_config.ml
+++ b/hphp/hack/src/injection/default_injector/injector_config.ml
@@ -1 +1,2 @@
 let use_error_tracing = false
+let use_test_stubbing = false
diff --git a/hphp/hack/src/injection/injector_config.mli b/hphp/hack/src/injection/injector_config.mli
index 9ec8b1e..f139985 100644
--- a/hphp/hack/src/injection/injector_config.mli
+++ b/hphp/hack/src/injection/injector_config.mli
@@ -16,3 +16,4 @@
  * Note: Buck doesn't currently have a build rule to only build .mli files
  * into .cmi, so you need to compile against this file directly. *)
 val use_error_tracing: bool
+val use_test_stubbing: bool
diff --git a/hphp/hack/src/injection/test_injector/injector_config.ml b/hphp/hack/src/injection/test_injector/injector_config.ml
new file mode 100644
index 0000000..7e9079f
--- /dev/null
+++ b/hphp/hack/src/injection/test_injector/injector_config.ml
@@ -0,0 +1,2 @@
+let use_error_tracing = false
+let use_test_stubbing = true
diff --git a/hphp/hack/src/injection/test_injector/injector_config.mli b/hphp/hack/src/injection/test_injector/injector_config.mli
new file mode 120000
index 0000000..1ffeb6a
--- /dev/null
+++ b/hphp/hack/src/injection/test_injector/injector_config.mli
@@ -0,0 +1 @@
+../injector_config.mli
\ No newline at end of file
diff --git a/hphp/hack/src/monitor/serverMonitor.ml b/hphp/hack/src/monitor/serverMonitor.ml
index 7a949a7..2071246 100644
--- a/hphp/hack/src/monitor/serverMonitor.ml
+++ b/hphp/hack/src/monitor/serverMonitor.ml
@@ -90,7 +90,8 @@ let sleep_and_check socket =
 (** Kill command from client is handled by server server, so the monitor
  * needs to check liveness of the server process to know whether
  * to stop itself. *)
-let update_status_ (server: ServerProcess.server_process) = match server with
+let update_status_ (server: ServerProcess.server_process) monitor_config =
+  match server with
   | Alive process ->
     let pid, proc_stat =
       Unix.waitpid [Unix.WNOHANG; Unix.WUNTRACED] process.pid in
@@ -102,7 +103,7 @@ let update_status_ (server: ServerProcess.server_process) = match server with
         let was_oom = match proc_stat with
         | Unix.WEXITED code when code = oom_code -> true
         | _ -> check_dmesg_for_oom process in
-        ServerProcessTools.check_exit_status proc_stat process;
+        ServerProcessTools.check_exit_status proc_stat process monitor_config;
         Died_unexpectedly (proc_stat, was_oom))
   | _ -> server
 
@@ -143,8 +144,10 @@ let restart_servers env =
     retries = env.retries + 1;
   }
 
-let update_status env =
-   let servers = SMap.map update_status_ env.servers in
+let update_status env monitor_config =
+   let servers = SMap.map
+    (fun server -> update_status_ server monitor_config)
+    env.servers in
    let env = { env with servers = servers } in
    let watchman_failed _ status = match status with
      | Died_unexpectedly ((Unix.WEXITED c), _)
@@ -292,9 +295,9 @@ and ack_and_handoff_client env client_fd =
     Hh_logger.log "Malformed Build ID";
     raise e
 
-let rec check_and_run_loop env
-    (lock_file: string) (socket: Unix.file_descr) =
-  let env = try check_and_run_loop_ env lock_file socket with
+let rec check_and_run_loop env monitor_config
+    (socket: Unix.file_descr) =
+  let env = try check_and_run_loop_ env monitor_config socket with
     | Unix.Unix_error (Unix.ECHILD, _, _) ->
       ignore (Hh_logger.log
         "check_and_run_loop_ threw with Unix.ECHILD. Exiting");
@@ -304,16 +307,17 @@ let rec check_and_run_loop env
         (Printexc.to_string e);
       env
     in
-    check_and_run_loop env lock_file socket
+    check_and_run_loop env monitor_config socket
 
-and check_and_run_loop_ env
-    (lock_file: string) (socket: Unix.file_descr) =
+and check_and_run_loop_ env monitor_config
+    (socket: Unix.file_descr) =
+  let lock_file = monitor_config.lock_file in
   if not (Lock.grab lock_file) then
     (Hh_logger.log "Lost lock; terminating.\n%!";
      HackEventLogger.lock_stolen lock_file;
      Exit_status.(exit Lock_stolen));
   let has_client = sleep_and_check socket in
-  let env = update_status env in
+  let env = update_status env monitor_config in
   if (not has_client) then
     env
   else
@@ -360,4 +364,4 @@ let start_monitoring ~waiting_client monitor_config monitor_starter =
     starter = monitor_starter;
     retries = 0;
   } in
-  check_and_run_loop env monitor_config.lock_file socket
+  check_and_run_loop env monitor_config socket
diff --git a/hphp/hack/src/monitor/serverMonitorUtils.ml b/hphp/hack/src/monitor/serverMonitorUtils.ml
index e11656c..0f9b2bb 100644
--- a/hphp/hack/src/monitor/serverMonitorUtils.ml
+++ b/hphp/hack/src/monitor/serverMonitorUtils.ml
@@ -14,6 +14,12 @@ type monitor_config =
     socket_file: string;
     (** This lock is held when a monitor is alive. *)
     lock_file: string;
+    (** The path to the server log file *)
+    server_log_file: string;
+    (** The path to the monitor log file *)
+    monitor_log_file: string;
+    (** The path to the load script log file *)
+    load_script_log_file: string;
   }
 
 (**
diff --git a/hphp/hack/src/monitor/serverProcessTools.ml b/hphp/hack/src/monitor/serverProcessTools.ml
index 537d69b..a28086c 100644
--- a/hphp/hack/src/monitor/serverProcessTools.ml
+++ b/hphp/hack/src/monitor/serverProcessTools.ml
@@ -10,6 +10,7 @@
 
 open Core
 open ServerProcess
+open ServerMonitorUtils
 
 let find_oom_in_dmesg_output process lines =
   let re = Str.regexp (Printf.sprintf
@@ -26,7 +27,7 @@ let check_dmesg_for_oom process =
   let dmesg = Sys_utils.exec_read_lines ~reverse:true "dmesg" in
   find_oom_in_dmesg_output process dmesg
 
-let check_exit_status proc_stat process =
+let check_exit_status proc_stat process monitor_config  =
   match proc_stat with
   | Unix.WEXITED 0 -> ()
   | _ ->
@@ -34,4 +35,9 @@ let check_exit_status proc_stat process =
     Hh_logger.log "%s %s with exit code %d\n" process.name exit_kind exit_code;
     let is_oom = try check_dmesg_for_oom process with _ -> false in
     let time_taken = Unix.time () -. process.start_t in
-    HackEventLogger.bad_exit time_taken proc_stat ~is_oom
+    HackEventLogger.bad_exit
+      time_taken proc_stat
+      (monitor_config.server_log_file,
+      monitor_config.monitor_log_file,
+      monitor_config.load_script_log_file)
+      ~is_oom
diff --git a/hphp/hack/src/naming/naming.ml b/hphp/hack/src/naming/naming.ml
index d83e6ca..8a294c2 100644
--- a/hphp/hack/src/naming/naming.ml
+++ b/hphp/hack/src/naming/naming.ml
@@ -514,8 +514,9 @@ end = struct
     with Not_found ->
       Hashtbl.replace tbl x p
 
-  let bind_class_const (genv, _env) x =
-    bind_class_member genv.class_consts x
+  let bind_class_const (genv, _env) (p, x) =
+    if String.lowercase x = "class" then Errors.illegal_member_variable_class p;
+    bind_class_member genv.class_consts (p, x)
 
   let bind_prop (genv, _env) x =
     bind_class_member genv.class_props x
@@ -1711,11 +1712,13 @@ module Make (GetLocals : GetLocals) = struct
       let p, cn = Namespaces.elaborate_id ((fst env).namespace) NSClass id in
       match cn with
         | x when N.is_vc_kind
-          (TypecheckerOptions.experimental_features (fst env).tcopt) p x ->
+            (TypecheckerOptions.experimental_feature_enabled (fst env).tcopt
+               TypecheckerOptions.experimental_dict) p x ->
           N.ValCollection ((N.get_vc_kind cn),
             (List.map l (afield_value env cn)))
         | x when N.is_kvc_kind
-          (TypecheckerOptions.experimental_features (fst env).tcopt) p x ->
+            (TypecheckerOptions.experimental_feature_enabled (fst env).tcopt
+               TypecheckerOptions.experimental_dict) p x ->
           N.KeyValCollection ((N.get_kvc_kind cn),
             (List.map l (afield_kvalue env cn)))
         | x when x = SN.Collections.cPair ->
diff --git a/hphp/hack/src/naming/naming_special_names.ml b/hphp/hack/src/naming/naming_special_names.ml
index 3bce623..0b08182 100644
--- a/hphp/hack/src/naming/naming_special_names.ml
+++ b/hphp/hack/src/naming/naming_special_names.ml
@@ -161,6 +161,9 @@ module StdlibFunctions = struct
   let is_int      = "\\is_int"
   let is_bool     = "\\is_bool"
   let is_array    = "\\is_array"
+  let is_vec      = "\\is_vec"
+  let is_dict     = "\\is_dict"
+  let is_keyset   = "\\is_keyset"
   let is_float    = "\\is_float"
   let is_string   = "\\is_string"
   let is_null     = "\\is_null"
diff --git a/hphp/hack/src/naming/typecheckerOptions.ml b/hphp/hack/src/naming/typecheckerOptions.ml
index 3d49c43..3a6b3c4 100644
--- a/hphp/hack/src/naming/typecheckerOptions.ml
+++ b/hphp/hack/src/naming/typecheckerOptions.ml
@@ -27,17 +27,21 @@ type t = {
   (* List of <<UserAttribute>> names expected in the codebase *)
   tco_user_attrs : SSet.t option;
 
-  (** Enable experimental features. *)
-  tco_experimental_features : bool;
+  (* Set of experimental features, in lowercase. *)
+  tco_experimental_features : SSet.t;
 }
 
+(* Currently there is only one experimental feature *)
+let experimental_dict = "dict"
+let experimental_all = SSet.add experimental_dict SSet.empty
+
 let default = {
   tco_assume_php = true;
   tco_unsafe_xhp = false;
   tco_user_attrs = None;
-  (** Default true for testing. Actual flag is set by reading from hhconfig,
-   * which defaults to false. *)
-  tco_experimental_features = true;
+  (** Default all features for testing. Actual options are set by reading
+   * from hhconfig, which defaults to empty. *)
+  tco_experimental_features = experimental_all;
 }
 
 (* Use this instead of default when you don't have access to a project .hhconfig
@@ -55,4 +59,4 @@ let user_attrs t = t.tco_user_attrs
 let allowed_attribute t name = match t.tco_user_attrs with
   | None -> true
   | Some attr_names -> SSet.mem name attr_names
-let experimental_features t = t.tco_experimental_features
+let experimental_feature_enabled t s = SSet.mem s t.tco_experimental_features
diff --git a/hphp/hack/src/parsing/namespaces.ml b/hphp/hack/src/parsing/namespaces.ml
index ea96cc3..2b64f6d 100644
--- a/hphp/hack/src/parsing/namespaces.ml
+++ b/hphp/hack/src/parsing/namespaces.ml
@@ -37,7 +37,9 @@ let autoimport_classes = [
   "Collection";
   "Vector";
   "ImmVector";
+  "vec";
   "dict";
+  "keyset";
   "Map";
   "ImmMap";
   "StableMap";
diff --git a/hphp/hack/src/parsing/parsing_service.ml b/hphp/hack/src/parsing/parsing_service.ml
index 153a666..d576a57 100644
--- a/hphp/hack/src/parsing/parsing_service.ml
+++ b/hphp/hack/src/parsing/parsing_service.ml
@@ -9,7 +9,6 @@
  *)
 
 open Core
-open Reordered_argument_collections
 
 (*****************************************************************************)
 (* Helpers *)
@@ -114,8 +113,7 @@ let parse_parallel workers get_next =
       ~next:get_next
 
 (* sequentially parse IDE files opened by persistent connection *)
-let parse_sequential path content (acc, errorl, error_files) =
-  let fn = Relative_path.create Relative_path.Root path in
+let parse_sequential fn content (acc, errorl, error_files) =
   let errorl', {Parser_hack.file_mode; comments; ast}, _ =
     Errors.do_ begin fun () ->
       Parser_hack.program fn content
@@ -160,11 +158,11 @@ let parse_sequential path content (acc, errorl, error_files) =
 let go workers files_map ~get_next =
   let acc = parse_parallel workers get_next in
   let fast, errorl, failed_parsing =
-    SMap.fold files_map ~init:acc ~f:(
-      fun path content (acc, errorl, error_files) ->
-        let fn = Relative_path.create Relative_path.Root path in
+    Relative_path.Map.fold files_map ~init:acc ~f:(
+      fun fn content (acc, errorl, error_files) ->
         if FindUtils.is_php (Relative_path.suffix fn) then
-          parse_sequential path content (acc, errorl, error_files)
+          let content = File_content.get_content content in
+          parse_sequential fn content (acc, errorl, error_files)
         else
           let info = empty_file_info in
           let acc = Relative_path.Map.add acc ~key:fn ~data:info in
diff --git a/hphp/hack/src/parsing/parsing_service.mli b/hphp/hack/src/parsing/parsing_service.mli
index e57b947..3fc0aa7 100644
--- a/hphp/hack/src/parsing/parsing_service.mli
+++ b/hphp/hack/src/parsing/parsing_service.mli
@@ -11,7 +11,7 @@ val empty_file_info: FileInfo.t
 
 val go:
   Worker.t list option ->
-  string Reordered_argument_collections.SMap.t ->
+  File_content.t Relative_path.Map.t ->
   get_next:(unit -> Relative_path.t list) ->
   FileInfo.t Relative_path.Map.t * Errors.t * Relative_path.Set.t
 
diff --git a/hphp/hack/src/procs/worker.ml b/hphp/hack/src/procs/worker.ml
index 60454d2..207f00c 100644
--- a/hphp/hack/src/procs/worker.ml
+++ b/hphp/hack/src/procs/worker.ml
@@ -145,7 +145,9 @@ let slave_main ic oc =
   | e ->
       let e_str = Printexc.to_string e in
       Printf.printf "Exception: %s\n" e_str;
-      EventLogger.worker_exception e_str;
+      EventLogger.log_if_initialized (fun () ->
+        EventLogger.worker_exception e_str
+      );
       print_endline "Potential backtrace:";
       Printexc.print_backtrace stdout;
       exit 2
@@ -177,11 +179,7 @@ let unix_worker_main restore state (ic, oc) =
           | Unix.WEXITED code ->
               Printf.printf "Worker exited (code: %d)\n" code;
               flush stdout;
-
-              (* Propagate out of memory exit codes *)
-              if code = Exit_status.(exit_code Out_of_shared_memory)
-              then Exit_status.(exit Out_of_shared_memory)
-              else raise End_of_file
+              Pervasives.exit code
           | Unix.WSIGNALED x ->
               let sig_str = PrintSignal.string_of_signal x in
               Printf.printf "Worker interrupted with signal: %s\n" sig_str;
@@ -267,7 +265,8 @@ let call w (type a) (type b) (f : a -> b) (x : a) : b handle =
     | _, Unix.WEXITED i when i = Exit_status.(exit_code Out_of_shared_memory) ->
         raise SharedMem.Out_of_shared_memory
     | _, Unix.WEXITED i ->
-        Printf.ksprintf failwith "Subprocess(%d): fail %d" slave_pid i
+        Printf.eprintf "Subprocess(%d): fail %d" slave_pid i;
+        Pervasives.exit i
     | _, Unix.WSTOPPED i ->
         Printf.ksprintf failwith "Subprocess(%d): stopped %d" slave_pid i
     | _, Unix.WSIGNALED i ->
diff --git a/hphp/hack/src/search/fuzzySearchService.ml b/hphp/hack/src/search/fuzzySearchService.ml
index 01dfcbb..c2eaac7 100644
--- a/hphp/hack/src/search/fuzzySearchService.ml
+++ b/hphp/hack/src/search/fuzzySearchService.ml
@@ -247,7 +247,7 @@ let update_term_lookup file add_terms remove_terms =
       try Hashtbl.find !term_lookup term
       with Not_found -> Relative_path.Set.empty
     in
-    Hashtbl.replace !term_lookup term (Relative_path.Set.remove file old_val);
+    Hashtbl.replace !term_lookup term (Relative_path.Set.remove old_val file);
   end remove_terms;
   SSet.iter begin fun term ->
     let old_val =
diff --git a/hphp/hack/src/search/hackSearchService.ml b/hphp/hack/src/search/hackSearchService.ml
index e4ba998..e3ecd3b 100644
--- a/hphp/hack/src/search/hackSearchService.ml
+++ b/hphp/hack/src/search/hackSearchService.ml
@@ -19,6 +19,9 @@ type search_result_type =
   | Typedef
   | Constant
 
+type result =
+  (Pos.absolute, search_result_type) SearchUtils.term list
+
 module SS = SearchService.Make(struct
   type t = search_result_type
   let fuzzy_types = [Class Ast.Cnormal; Function; Constant; Typedef]
diff --git a/hphp/hack/src/server/clientProvider.ml b/hphp/hack/src/server/clientProvider.ml
new file mode 100644
index 0000000..240435c
--- /dev/null
+++ b/hphp/hack/src/server/clientProvider.ml
@@ -0,0 +1,4 @@
+include (val (if Injector_config.use_test_stubbing
+  then (module TestClientProvider : ClientProvider_sig.S)
+  else (module ServerClientProvider : ClientProvider_sig.S)
+))
diff --git a/hphp/hack/src/server/clientProvider.mli b/hphp/hack/src/server/clientProvider.mli
new file mode 100644
index 0000000..23b22e6
--- /dev/null
+++ b/hphp/hack/src/server/clientProvider.mli
@@ -0,0 +1 @@
+include ClientProvider_sig.S
diff --git a/hphp/hack/src/server/clientProvider_sig.ml b/hphp/hack/src/server/clientProvider_sig.ml
new file mode 100644
index 0000000..87bb194
--- /dev/null
+++ b/hphp/hack/src/server/clientProvider_sig.ml
@@ -0,0 +1,32 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+module type S = sig
+  type t
+  type client
+
+  val provider_from_file_descriptor : Unix.file_descr -> t
+  val provider_for_test : unit -> t
+
+  val sleep_and_check : t -> client option -> bool * bool
+  val accept_client : t -> client
+  val read_connection_type : client -> ServerCommandTypes.connection_type
+  val send_response_to_client : client -> 'a -> unit
+  val send_push_message_to_client : client -> ServerCommandTypes.push -> unit
+  val read_client_msg: client -> 'a ServerCommandTypes.command
+  val make_persistent : client -> client
+  val is_persistent : client -> bool
+  val shutdown_client: client -> unit
+
+  (* TODO: temporary way to break the module abstraction. Remove after
+   * converting all the callsites to use methods on this module instead of
+   * directly using channels. *)
+  val get_channels: client -> Timeout.in_channel * out_channel
+end
diff --git a/hphp/hack/src/server/diagnostic_subscription.ml b/hphp/hack/src/server/diagnostic_subscription.ml
new file mode 100644
index 0000000..a1286f0
--- /dev/null
+++ b/hphp/hack/src/server/diagnostic_subscription.ml
@@ -0,0 +1,19 @@
+(**
+ * Copyright (c) 2015, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+type t = {
+  id : int;
+}
+
+let of_id ~id = {
+  id;
+}
+
+let get_id ds = ds.id
diff --git a/hphp/hack/src/server/diagnostic_subscription.mli b/hphp/hack/src/server/diagnostic_subscription.mli
new file mode 100644
index 0000000..97d03f9
--- /dev/null
+++ b/hphp/hack/src/server/diagnostic_subscription.mli
@@ -0,0 +1,15 @@
+(**
+ * Copyright (c) 2015, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+type t
+
+val of_id : id:int -> t
+
+val get_id : t -> int
diff --git a/hphp/hack/src/server/findRefsService.ml b/hphp/hack/src/server/findRefsService.ml
index ce718b5..c910962 100644
--- a/hphp/hack/src/server/findRefsService.ml
+++ b/hphp/hack/src/server/findRefsService.ml
@@ -22,6 +22,7 @@ type action = Ai.ServerFindRefs.action =
   | Class of string
   | Member of string * member
   | Function of string
+  | GConst of string
 
 (* The class containing the member can be specified in two ways:
  * - Class_set - as an explicit, pre-computed set of names, which are then
@@ -37,6 +38,7 @@ type action_internal  =
   | IClass of string
   | IMember of member_class * member
   | IFunction of string
+  | IGConst of string
 
 type result = (string * Pos.absolute) list
 
@@ -48,7 +50,7 @@ let check_if_extends_class tcopt target_class_name class_name =
   let class_ = Typing_lazy_heap.get_class tcopt class_name in
   match class_ with
   | Some { Typing_defs.tc_ancestors = imps; _ }
-      when SMap.mem target_class_name imps -> true
+      when SMap.mem imps target_class_name -> true
   | _ -> false
 
 let is_target_class tcopt target_classes class_name =
@@ -105,6 +107,10 @@ let process_taccess tcopt results_acc target_classes target_typeconst
   results_acc :=
     Pos.Map.add p (class_name ^ "::" ^ tconst_name) !results_acc
 
+let process_gconst_id results_acc target_gconst id =
+  if target_gconst = (snd id)
+  then results_acc := Pos.Map.add (fst id) (snd id) !results_acc
+
 let attach_hooks tcopt results_acc = function
   | IMember (classes, ((Method _ | Property _ | Class_const _) as member)) ->
     let process_member_id =
@@ -121,6 +127,9 @@ let attach_hooks tcopt results_acc = function
   | IClass c ->
     let classes = SSet.singleton c in
     Decl_hooks.attach_class_id_hook (process_class_id results_acc classes)
+  | IGConst cst_name ->
+    Typing_hooks.attach_global_const_hook
+      (process_gconst_id results_acc cst_name)
 
 let detach_hooks () =
   Decl_hooks.remove_all_hooks ();
@@ -135,7 +144,7 @@ let find_child_classes tcopt target_class_name files_info files =
   Relative_path.Set.fold files ~init:SSet.empty ~f:begin fun fn acc ->
     (try
       let { FileInfo.classes; _ } =
-        Relative_path.Map.find_unsafe fn files_info in
+        Relative_path.Map.find_unsafe files_info fn in
       List.fold_left classes ~init:acc ~f:begin fun acc cid ->
         add_if_extends_class tcopt target_class_name (snd cid) acc
       end
@@ -182,6 +191,17 @@ let get_deps_set_function tcopt f_name =
   | None ->
     Relative_path.Set.empty
 
+let get_deps_set_gconst tcopt cst_name =
+  match Typing_lazy_heap.get_gconst tcopt cst_name with
+  | Some cst_ ->
+    let fn = Pos.filename @@ Typing_reason.to_pos @@ fst cst_ in
+    let dep = Typing_deps.Dep.GConst cst_name in
+    let bazooka = Typing_deps.get_bazooka dep in
+    let files = Typing_deps.get_files bazooka in
+    Relative_path.Set.add files fn
+  | None ->
+    Relative_path.Set.empty
+
 let find_refs tcopt target acc fileinfo_l =
   let results_acc = ref Pos.Map.empty in
   attach_hooks tcopt results_acc target;
@@ -226,6 +246,7 @@ let get_definitions tcopt = function
       | Some fun_ -> [fun_name, fun_.ft_pos]
       | None -> []
     end
+  | IGConst _
   | IMember (Subclasses_of _, _)
   | IMember (_, (Property _ | Class_const _ | Typeconst _)) ->
     (* this code path is used only in ServerRefactor, we can update it at some
@@ -255,6 +276,10 @@ let get_dependent_files_function tcopt _workers f_name =
   (* This is performant enough to not need to go parallel for now *)
   get_deps_set_function tcopt f_name
 
+let get_dependent_files_gconst tcopt _workers cst_name =
+  (* This is performant enough to not need to go parallel for now *)
+  get_deps_set_gconst tcopt cst_name
+
 let get_dependent_files tcopt _workers input_set =
   (* This is performant enough to not need to go parallel for now *)
   get_deps_set tcopt input_set
diff --git a/hphp/hack/src/server/hhServerMonitor.ml b/hphp/hack/src/server/hhServerMonitor.ml
index 61f2fa2..f0df13c 100644
--- a/hphp/hack/src/server/hhServerMonitor.ml
+++ b/hphp/hack/src/server/hhServerMonitor.ml
@@ -22,7 +22,7 @@
 open HhServerMonitorConfig
 module SP = ServerProcess
 
-let start_server options handle name log_link daemon_entry =
+let start_server options name log_link daemon_entry =
   let log_fds =
     if ServerArgs.should_detach options then begin
       (try Sys.rename log_link (log_link ^ ".old") with _ -> ());
@@ -43,7 +43,7 @@ let start_server options handle name log_link daemon_entry =
       ~channel_mode:`socket
       log_fds
       daemon_entry
-      (state, handle, options) in
+      (state, options) in
   Hh_logger.log "Just started %s server with pid: %d." name pid;
   let server =
     SP.({
@@ -56,9 +56,9 @@ let start_server options handle name log_link daemon_entry =
     }) in
   server
 
-let start_hh_server options handle =
+let start_hh_server options  =
   let log_link = ServerFiles.log_link (ServerArgs.root options) in
-  start_server options handle Program.hh_server log_link ServerMain.entry
+  start_server options Program.hh_server log_link ServerMain.entry
 
 
 (** Main method of the server monitor daemon. The daemon is responsible for
@@ -83,35 +83,34 @@ let monitor_daemon_main (options: ServerArgs.options) =
   end;
 
   ignore @@ Sys_utils.setsid ();
-
   (* Force hhi files to be extracted and their location saved before workers
    * fork, so everyone can know about the same hhi path. *)
   ignore (Hhi.get_hhi_root());
-
   Relative_path.set_path_prefix Relative_path.Root www_root;
 
-  let config = ServerConfig.(sharedmem_config (load filename options)) in
-  let handle = SharedMem.init config in
-  let first_init = ref true in
+  let config, local_config  =
+   ServerConfig.(load filename options) in
+  HackEventLogger.set_lazy_decl
+   local_config.ServerLocalConfig.lazy_decl;
 
   if ServerArgs.check_mode options then
+    let shared_config = ServerConfig.(sharedmem_config config) in
+    let handle = SharedMem.init shared_config in
+    SharedMem.connect handle ~is_master:true;
     ServerMain.run_once options handle
   else
     let hh_server_monitor_starter = begin fun () ->
-
-      if !first_init then begin
-        first_init := false
-      end else begin
-        SharedMem.reset ()
-      end;
-
-      let typechecker = start_hh_server options handle in
+      ignore (Hhi.get_hhi_root());
+      let typechecker = start_hh_server options in
       [typechecker]
     end in
     let waiting_client = ServerArgs.waiting_client options in
     ServerMonitor.start_monitoring ~waiting_client ServerMonitorUtils.({
       socket_file = ServerFiles.socket_file www_root;
       lock_file = ServerFiles.lock_file www_root;
+      server_log_file = ServerFiles.log_link www_root;
+      monitor_log_file = ServerFiles.monitor_log_link www_root;
+      load_script_log_file = ServerFiles.load_log www_root;
     }) hh_server_monitor_starter
 
 let daemon_entry =
diff --git a/hphp/hack/src/server/identifySymbolService.ml b/hphp/hack/src/server/identifySymbolService.ml
index e93651f..4a37db8 100644
--- a/hphp/hack/src/server/identifySymbolService.ml
+++ b/hphp/hack/src/server/identifySymbolService.ml
@@ -12,6 +12,9 @@ open Core
 open SymbolOccurrence
 open Typing_defs
 
+type result =
+  ((string SymbolOccurrence.t) * (string SymbolDefinition.t option)) list
+
 type cache = (Relative_path.t * FileInfo.t * Ast.def list *
   Relative_path.t SymbolOccurrence.t list) SMap.t
 
diff --git a/hphp/hack/src/server/inferAtPosService.ml b/hphp/hack/src/server/inferAtPosService.ml
index 9aba3c5..1b01f61 100644
--- a/hphp/hack/src/server/inferAtPosService.ml
+++ b/hphp/hack/src/server/inferAtPosService.ml
@@ -8,6 +8,8 @@
  *
  *)
 
+type result = Pos.absolute option * string option
+
 (* Remember (when we care) the type found at a position *)
 let save_infer result_ty result_pos target_line target_column ty pos env =
   if Pos.inside pos target_line target_column && !result_ty = None
diff --git a/hphp/hack/src/server/methodJumps.ml b/hphp/hack/src/server/methodJumps.ml
index edbc6da..a37c428 100644
--- a/hphp/hack/src/server/methodJumps.ml
+++ b/hphp/hack/src/server/methodJumps.ml
@@ -59,7 +59,7 @@ let check_if_extends_class_and_find_methods tcopt target_class_name mthds
   match class_ with
   | None -> acc
   | Some c
-      when SMap.mem target_class_name c.Typing_defs.tc_ancestors ->
+      when SMap.mem c.Typing_defs.tc_ancestors target_class_name ->
         let acc = get_overridden_methods tcopt
                       target_class_name mthds
                       class_name
@@ -90,7 +90,7 @@ let find_extended_classes_in_files tcopt target_class_name mthds
 let find_extended_classes_in_files_parallel tcopt workers target_class_name
       mthds target_class_pos files_info files =
   let classes = Relative_path.Set.fold files ~init:[] ~f:begin fun fn acc ->
-    let { FileInfo.classes; _ } = Relative_path.Map.find_unsafe fn files_info in
+    let { FileInfo.classes; _ } = Relative_path.Map.find_unsafe files_info fn in
     classes :: acc
   end in
 
diff --git a/hphp/hack/src/server/serverBuild.ml b/hphp/hack/src/server/serverBuild.ml
index 03f859e..c64d48d 100644
--- a/hphp/hack/src/server/serverBuild.ml
+++ b/hphp/hack/src/server/serverBuild.ml
@@ -25,7 +25,6 @@ type build_opts = {
   clean_before_build: bool; (* when true, do a clean build *)
   clean: bool; (* when true just clean all generated files *)
   is_push: bool; (* for push builds *)
-  incremental: bool; (* for incremental build *)
   (* user the client is running as; if the server is running as a different user
    * we will probably have hard-to-debug permissions issues, so error out *)
   user: string;
@@ -39,12 +38,10 @@ type build_progress =
   | BUILD_FINISHED
 
 let build_type_of build_opts =
-  let {steps; no_steps; is_push; incremental; _} = build_opts in
+  let {steps; no_steps; is_push; _} = build_opts in
   if steps <> None || no_steps <> None then
     `Steps
   else if is_push then
     `Push
-  else if incremental then
-    `Incremental
   else
     `Full
diff --git a/hphp/hack/src/server/serverCheckUtils.ml b/hphp/hack/src/server/serverCheckUtils.ml
index 20cb5b9..f9019cb 100644
--- a/hphp/hack/src/server/serverCheckUtils.ml
+++ b/hphp/hack/src/server/serverCheckUtils.ml
@@ -13,7 +13,7 @@ let extend_fast fast files_info additional_files =
     match Relative_path.Map.get fast x with
     | None ->
         (try
-           let info = Relative_path.Map.find_unsafe x files_info in
+           let info = Relative_path.Map.find_unsafe files_info x in
            if info.FileInfo.consider_names_just_for_autoload then acc else
            let info_names = FileInfo.simplify info in
            Relative_path.Map.add acc ~key:x ~data:info_names
diff --git a/hphp/hack/src/server/serverCheckpoint.ml b/hphp/hack/src/server/serverCheckpoint.ml
index 339c0cc..00472f0 100644
--- a/hphp/hack/src/server/serverCheckpoint.ml
+++ b/hphp/hack/src/server/serverCheckpoint.ml
@@ -37,6 +37,6 @@ let retrieve_checkpoint x =
 let delete_checkpoint x =
   match SMap.get !checkpoints x with
   | Some _ ->
-      checkpoints := SMap.remove x !checkpoints;
+      checkpoints := SMap.remove !checkpoints x;
       true
   | None -> false
diff --git a/hphp/hack/src/server/serverClientProvider.ml b/hphp/hack/src/server/serverClientProvider.ml
new file mode 100644
index 0000000..0da9d07
--- /dev/null
+++ b/hphp/hack/src/server/serverClientProvider.ml
@@ -0,0 +1,116 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open ServerCommandTypes
+
+type t = Unix.file_descr
+type client =
+  | Non_persistent_client of Timeout.in_channel * out_channel
+  | Persistent_client of Unix.file_descr
+
+let provider_from_file_descriptor x = x
+let provider_for_test () = failwith "for use in tests only"
+
+let sleep_and_check in_fd persistent_client_opt =
+  let l = match persistent_client_opt with
+    | Some (Persistent_client fd) -> [in_fd ; fd]
+    | Some (Non_persistent_client _) ->
+        (* The arguments for "sleep_and_check" are "the source of new clients"
+         * and the "client we already store in the env". We only store
+         * persistent clients *)
+        assert false
+    | None -> [in_fd]
+  in
+  let ready_fd_l, _, _ = Unix.select l [] [] (0.5) in
+  match ready_fd_l with
+  | [_; _] -> true, true
+  | [fd] -> if (fd <> in_fd) then false, true else true, false
+  | _ -> false, false
+
+(** Retrieve channels to client from monitor process. *)
+let accept_client parent_in_fd =
+  let socket = Libancillary.ancil_recv_fd parent_in_fd in
+  Non_persistent_client (
+    (Timeout.in_channel_of_descr socket), (Unix.out_channel_of_descr socket)
+  )
+
+let say_hello oc =
+  let fd = Unix.descr_of_out_channel oc in
+  Marshal_tools.to_fd_with_preamble fd "Hello"
+
+let read_connection_type ic =
+  Timeout.with_timeout
+    ~timeout:1
+    ~on_timeout: (fun _ -> raise Read_command_timeout)
+    ~do_: (fun timeout -> Timeout.input_value ~timeout ic)
+
+let read_connection_type = function
+  | Non_persistent_client (ic, oc) ->
+    say_hello oc;
+    read_connection_type ic
+  | Persistent_client _ ->
+    (* Every client starts as Non_persistent_client, and after we read its
+     * desired connection type, can be turned into Persistent_client
+     * (via make_persistent). *)
+    assert false
+
+let send_response_to_client client response =
+  match client with
+  | Non_persistent_client (_, oc) ->
+    let fd = Unix.descr_of_out_channel oc in
+    Marshal_tools.to_fd_with_preamble fd response
+  | Persistent_client fd ->
+    Marshal_tools.to_fd_with_preamble fd response
+
+let send_push_message_to_client = send_response_to_client
+
+let read_client_msg ic =
+  Timeout.with_timeout
+    ~timeout:1
+    ~on_timeout: (fun _ -> raise Read_command_timeout)
+    ~do_: (fun timeout -> Timeout.input_value ~timeout ic)
+
+let read_client_msg = function
+  | Non_persistent_client (ic, _) -> read_client_msg ic
+  | Persistent_client fd ->
+    (* TODO: this is probably wrong, since for persistent client we'll
+     * construct a new input channel for each message, while the old one
+     * could have already buffered it *)
+    let ic = Timeout.in_channel_of_descr fd in
+    read_client_msg ic
+
+let get_channels = function
+  | Non_persistent_client (ic, oc) -> ic, oc
+  | Persistent_client _ ->
+    (* This function is used to "break" the module abstraction for some things
+     * we don't have mocking for yet, like STREAM and DEBUG request types. We
+     * have mocking for all the features of persistent clients, so this should
+     * never be hit *)
+    assert false
+
+let make_persistent = function
+  | Non_persistent_client (ic, _) ->
+      Persistent_client (Timeout.descr_of_in_channel ic)
+  | Persistent_client _ ->
+      (* See comment on read_connection_type. Non_persistent_client can be
+       * turned into Persistent_client, but not the other way *)
+      assert false
+
+let is_persistent = function
+  | Non_persistent_client _ -> false
+  | Persistent_client _ -> true
+
+let shutdown_client client =
+  let ic, oc = match client with
+    | Non_persistent_client (ic, oc) -> ic, oc
+    | Persistent_client fd ->
+        Timeout.in_channel_of_descr fd, Unix.out_channel_of_descr fd
+  in
+  ServerUtils.shutdown_client (ic, oc)
diff --git a/hphp/hack/src/server/serverColorFile.ml b/hphp/hack/src/server/serverColorFile.ml
index 067e2d2..5a4a367 100644
--- a/hphp/hack/src/server/serverColorFile.ml
+++ b/hphp/hack/src/server/serverColorFile.ml
@@ -11,8 +11,6 @@
 open Core
 open Coverage_level
 
-type result = ((int * int) * Coverage_level.level) list
-
 let to_json input =
   let entries = List.map input begin fun (clr, text) ->
     let color_string = match clr with
diff --git a/hphp/hack/src/server/serverCommand.ml b/hphp/hack/src/server/serverCommand.ml
index 90927ca..2c2d94c 100644
--- a/hphp/hack/src/server/serverCommand.ml
+++ b/hphp/hack/src/server/serverCommand.ml
@@ -9,36 +9,14 @@
  *)
 
 open Utils
-open ServerEnv
+open ServerCommandTypes
 
 module TLazyHeap = Typing_lazy_heap
 
-type connection_type =
-  | Persistent
-  | Non_persistent
-
-type connection_response =
-  | Persistent_client_connected
-  | Persistent_client_alredy_exists
-
-type 'a command =
-  | Rpc of 'a ServerRpc.t
-  | Stream of streamed
-  | Debug
-
-and streamed =
-  | SHOW of string
-  | LIST_FILES
-  | LIST_MODES
-  | BUILD of ServerBuild.build_opts
-
-(** Timeout on reading the command from the client - client probably frozen. *)
-exception Read_command_timeout
-
 (****************************************************************************)
 (* Called by the client *)
 (****************************************************************************)
-let rpc : type a. Timeout.in_channel * out_channel -> a ServerRpc.t -> a
+let rpc : type a. Timeout.in_channel * out_channel -> a t -> a
 = fun (_, oc) cmd ->
   Marshal.to_channel oc (Rpc cmd) [];
   flush oc;
@@ -149,7 +127,7 @@ let stream_response (genv:ServerEnv.genv) env (ic, oc) ~cmd =
       | None -> ServerUtils.shutdown_client (ic, oc)
       | Some build_hook -> begin
         ServerTypeCheck.hook_after_parsing :=
-          Some (fun genv old_env env updates ->
+          Some (fun genv env ->
             (* subtle: an exception there (such as writing on a closed pipe)
              * will not be caught by handle_connection() because
              * we have already returned from handle_connection(), hence
@@ -159,7 +137,7 @@ let stream_response (genv:ServerEnv.genv) env (ic, oc) ~cmd =
               with_context
                 ~enter:(fun () -> ())
                 ~exit:(fun () -> ServerUtils.shutdown_client (ic, oc))
-                ~do_:(fun () -> build_hook genv old_env env updates);
+                ~do_:(fun () -> build_hook genv env);
             with exn ->
               let msg = Printexc.to_string exn in
               Printf.printf "Exn in build_hook: %s" msg;
@@ -169,54 +147,26 @@ let stream_response (genv:ServerEnv.genv) env (ic, oc) ~cmd =
           )
       end)
 
-let say_hello oc =
-  let fd = Unix.descr_of_out_channel oc in
-  Marshal_tools.to_fd_with_preamble fd "Hello"
-
-let read_client_msg ic =
-  Timeout.with_timeout
-    ~timeout:1
-    ~on_timeout: (fun _ -> raise Read_command_timeout)
-    ~do_: (fun timeout -> Timeout.input_value ~timeout ic)
-
-let read_connection_type ic =
-  Timeout.with_timeout
-    ~timeout:1
-    ~on_timeout: (fun _ -> raise Read_command_timeout)
-    ~do_: (fun timeout -> Timeout.input_value ~timeout ic)
-
-let get_persistent_fds env =
-  match env.persistent_client_fd with
-  | Some fd -> fd
-  | None ->
-    failwith ("Persistent channel not found!")
-
-let is_persistent env fd =
-  match env.persistent_client_fd with
-  | Some p_fd -> fd = p_fd
-  | None -> false
-
-let send_response_to_client fd response =
-  Marshal_tools.to_fd_with_preamble fd response
-
-let handle genv env (ic, oc) =
-  let fd = Unix.descr_of_out_channel oc in
-  let msg = read_client_msg ic in
+let handle genv env client =
+  let msg = ClientProvider.read_client_msg client in
   match msg with
   | Rpc cmd ->
       let t = Unix.gettimeofday () in
       let new_env, response = ServerRpc.handle genv env cmd in
       let cmd_string = ServerRpc.to_string cmd in
       HackEventLogger.handled_command cmd_string t;
-      send_response_to_client fd response;
-      if cmd = ServerRpc.DISCONNECT || not @@ is_persistent env fd
-        then ServerUtils.shutdown_client (ic, oc);
-      if cmd = ServerRpc.KILL then ServerUtils.die_nicely ();
+      ClientProvider.send_response_to_client client response;
+      if cmd = ServerCommandTypes.DISCONNECT ||
+          not @@ (ClientProvider.is_persistent client)
+        then ClientProvider.shutdown_client client;
+      if cmd = ServerCommandTypes.KILL then ServerUtils.die_nicely ();
       new_env
   | Stream cmd ->
+      let ic, oc = ClientProvider.get_channels client in
       stream_response genv env (ic, oc) ~cmd;
       env
   | Debug ->
+      let ic, oc = ClientProvider.get_channels client in
       genv.ServerEnv.debug_channels <- Some (ic, oc);
       ServerDebug.say_hello genv;
       env
diff --git a/hphp/hack/src/server/serverCommandTypes.ml b/hphp/hack/src/server/serverCommandTypes.ml
new file mode 100644
index 0000000..34b749b
--- /dev/null
+++ b/hphp/hack/src/server/serverCommandTypes.ml
@@ -0,0 +1,73 @@
+open File_content
+
+type connection_type =
+  | Persistent
+  | Non_persistent
+
+type connection_response =
+  | Persistent_client_connected
+  | Persistent_client_alredy_exists
+
+(* The following datatypes can be interpreted as follows:
+ * MESSAGE_TAG : Argument type (sent from client to server) -> return type t *)
+type _ t =
+  | STATUS : Pos.absolute Errors.error_ list t
+  | INFER_TYPE : ServerUtils.file_input * int * int ->
+      InferAtPosService.result t
+  | COVERAGE_LEVELS : ServerUtils.file_input -> Coverage_level.result t
+  | AUTOCOMPLETE : string -> AutocompleteService.result t
+  | IDENTIFY_FUNCTION : string * int * int -> IdentifySymbolService.result t
+  | OUTLINE : string -> FileOutline.outline t
+  | GET_DEFINITION_BY_ID : string -> string SymbolDefinition.t option t
+  | METHOD_JUMP : (string * bool) -> MethodJumps.result list t
+  | FIND_DEPENDENT_FILES: string list -> string list t
+  | FIND_REFS : FindRefsService.action -> FindRefsService.result t
+  | IDE_FIND_REFS : string * int * int -> FindRefsService.result t
+  | IDE_HIGHLIGHT_REFS : string * int * int -> ServerHighlightRefsTypes.result t
+  | REFACTOR : ServerRefactorTypes.action -> ServerRefactorTypes.patch list t
+  | DUMP_SYMBOL_INFO : string list -> SymbolInfoServiceTypes.result t
+  | DUMP_AI_INFO : string list -> Ai.InfoService.result t
+  | REMOVE_DEAD_FIXMES : int list -> ServerRefactorTypes.patch list t
+  | ARGUMENT_INFO : string * int * int -> ServerArgumentInfo.result t
+  | SEARCH : string * string -> HackSearchService.result t
+  | COVERAGE_COUNTS : string -> ServerCoverageMetricTypes.result t
+  | LINT : string list -> ServerLintTypes.result t
+  | LINT_ALL : int -> ServerLintTypes.result t
+  | CREATE_CHECKPOINT : string -> unit t
+  | RETRIEVE_CHECKPOINT : string -> string list option t
+  | DELETE_CHECKPOINT : string -> bool t
+  | STATS : Stats.t t
+  | KILL : unit t
+  | FIND_LVAR_REFS : string * int * int -> ServerFindLocals.result t
+  | FORMAT : string * int * int -> string Format_hack.return t
+  | TRACE_AI : Ai.TraceService.action -> string t
+  | AI_QUERY : string -> string t
+  | ECHO_FOR_TEST : string -> string t
+  | OPEN_FILE : string -> unit t
+  | CLOSE_FILE : string -> unit t
+  | EDIT_FILE : string * (code_edit list) -> unit t
+  | IDE_AUTOCOMPLETE : string * content_pos -> AutocompleteService.result t
+  | IDE_HIGHLIGHT_REF : string * content_pos ->
+      ServerHighlightRefsTypes.result t
+  | IDE_IDENTIFY_FUNCTION : string * content_pos ->
+      IdentifySymbolService.result t
+  | DISCONNECT : unit t
+  | SUBSCRIBE_DIAGNOSTIC : int -> unit t
+  | UNSUBSCRIBE_DIAGNOSTIC : int -> unit t
+
+type 'a command =
+  | Rpc of 'a t
+  | Stream of streamed
+  | Debug
+
+and streamed =
+  | SHOW of string
+  | LIST_FILES
+  | LIST_MODES
+  | BUILD of ServerBuild.build_opts
+
+type push =
+  | DIAGNOSTIC of int * Pos.absolute Errors.error_ list
+
+(** Timeout on reading the command from the client - client probably frozen. *)
+exception Read_command_timeout
diff --git a/hphp/hack/src/server/serverConfig.ml b/hphp/hack/src/server/serverConfig.ml
index 1dd0c47..3a728ee 100644
--- a/hphp/hack/src/server/serverConfig.ml
+++ b/hphp/hack/src/server/serverConfig.ml
@@ -112,12 +112,27 @@ let load config_filename options =
   let load_script_timeout = int_ "load_script_timeout" ~default:0 config in
   let load_mini_script =
     Option.map (SMap.get config "load_mini_script") maybe_relative_path in
+  let process_experimental sl =
+    match List.map sl String.lowercase with
+    | ["false"] -> SSet.empty
+    | ["true"] -> TypecheckerOptions.experimental_all
+    | features ->
+      begin
+        List.iter features ~f:(fun s ->
+          if not (SSet.mem TypecheckerOptions.experimental_all s)
+          then failwith ("invalid experimental feature " ^ s));
+        List.fold_left features ~f:SSet.add ~init:SSet.empty
+      end in
   let tcopts = { TypecheckerOptions.
     tco_assume_php = bool_ "assume_php" ~default:true config;
     tco_unsafe_xhp = bool_ "unsafe_xhp" ~default:false config;
     tco_user_attrs = config_user_attributes config;
     tco_experimental_features =
-      bool_ "enable_experimental_tc_features" ~default:false config;
+      process_experimental (string_list
+        ~delim:(Str.regexp ",")
+        "enable_experimental_tc_features"
+        ~default:[]
+        config);
   } in
   {
     load_script = load_script;
@@ -126,7 +141,7 @@ let load config_filename options =
     gc_control = make_gc_control config;
     sharedmem_config = make_sharedmem_config config options local_config;
     tc_options = tcopts;
-  }
+  }, local_config
 
 (* useful in testing code *)
 let default_config = {
diff --git a/hphp/hack/src/server/serverConfig.mli b/hphp/hack/src/server/serverConfig.mli
index bd77ef6..655c0b7 100644
--- a/hphp/hack/src/server/serverConfig.mli
+++ b/hphp/hack/src/server/serverConfig.mli
@@ -11,7 +11,7 @@
 type t
 
 val filename : Relative_path.t
-val load : Relative_path.t -> ServerArgs.options -> t
+val load : Relative_path.t -> ServerArgs.options -> t * ServerLocalConfig.t
 val is_compatible : t -> t -> bool
 
 val default_config : t
diff --git a/hphp/hack/src/server/serverCoverageMetric.ml b/hphp/hack/src/server/serverCoverageMetric.ml
index fab727a..bef00f2 100644
--- a/hphp/hack/src/server/serverCoverageMetric.ml
+++ b/hphp/hack/src/server/serverCoverageMetric.ml
@@ -18,8 +18,6 @@ module FileInfoStore = GlobalStorage.Make(struct
   type t = FileInfo.t Relative_path.Map.t
 end)
 
-type result = level_stats SMap.t trie option
-
 (* Count the number of expressions of each kind of Coverage_level. *)
 let count_exprs fn type_acc =
   let level_of_type = level_of_type_mapper fn in
@@ -51,7 +49,7 @@ let accumulate_types fn defs =
   type_acc
 
 let combine v1 v2 =
-  SMap.merge (fun _ cs1 cs2 -> Option.merge cs1 cs2 merge_and_sum) v1 v2
+  SMap.merge ~f:(fun _ cs1 cs2 -> Option.merge cs1 cs2 merge_and_sum) v1 v2
 
 (* Create a trie for a single key. More complicated tries can then be built from
  * path tries using merge_trie* functions *)
@@ -66,7 +64,7 @@ let rec merge_trie x y = match x, y with
   | Node (x, c), Node (y, d) -> Node (combine x y, merge_trie_children c d)
 
 and merge_trie_children x y =
-    SMap.merge (fun _ x y -> merge_trie_opt x y) x y
+    SMap.merge ~f:(fun _ x y -> merge_trie_opt x y) x y
 
 and merge_trie_opt x y = Option.merge x y (merge_trie)
 
diff --git a/hphp/hack/src/server/serverCoverageMetricTypes.ml b/hphp/hack/src/server/serverCoverageMetricTypes.ml
new file mode 100644
index 0000000..8a76b44
--- /dev/null
+++ b/hphp/hack/src/server/serverCoverageMetricTypes.ml
@@ -0,0 +1,12 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open Coverage_level
+type result = level_stats SMap.t trie option
diff --git a/hphp/hack/src/server/serverEnv.ml b/hphp/hack/src/server/serverEnv.ml
index 4af15eb..25af408 100644
--- a/hphp/hack/src/server/serverEnv.ml
+++ b/hphp/hack/src/server/serverEnv.ml
@@ -48,13 +48,15 @@ type env = {
     failed_parsing : Relative_path.Set.t;
     failed_decl    : Relative_path.Set.t;
     failed_check   : Relative_path.Set.t;
-    persistent_client_fd : Unix.file_descr option;
+    persistent_client : ClientProvider.client option;
+    (* Timestamp of last IDE file synchronization command *)
+    last_command_time : float;
     (* The map from full path to synchronized file contents *)
-    edited_files   : File_content.t SMap.t;
+    edited_files   : File_content.t Relative_path.Map.t;
     (* The list of full path of synchronized files need to be type checked *)
-    files_to_check : SSet.t;
+    files_to_check : Relative_path.Set.t;
     (* The diagnostic subscription information of the current client *)
-    diag_subscribe : Diagnostic_subscription.t;
+    diag_subscribe : Diagnostic_subscription.t option;
     (* Highlight information cached for ide related commands *)
     symbols_cache  : IdentifySymbolService.cache;
   }
diff --git a/hphp/hack/src/server/serverEnvBuild.ml b/hphp/hack/src/server/serverEnvBuild.ml
index 3bcda15..a364d22 100644
--- a/hphp/hack/src/server/serverEnvBuild.ml
+++ b/hphp/hack/src/server/serverEnvBuild.ml
@@ -98,9 +98,10 @@ let make_env config =
     failed_parsing = Relative_path.Set.empty;
     failed_decl    = Relative_path.Set.empty;
     failed_check   = Relative_path.Set.empty;
-    persistent_client_fd = None;
-    edited_files   = SMap.empty;
-    files_to_check = SSet.empty;
-    diag_subscribe = Diagnostic_subscription.empty;
+    persistent_client = None;
+    last_command_time = 0.0;
+    edited_files   = Relative_path.Map.empty;
+    files_to_check = Relative_path.Set.empty;
+    diag_subscribe = None;
     symbols_cache  = SMap.empty;
   }
diff --git a/hphp/hack/src/server/serverFindRefs.ml b/hphp/hack/src/server/serverFindRefs.ml
index e26a73a..af7c7c8 100644
--- a/hphp/hack/src/server/serverFindRefs.ml
+++ b/hphp/hack/src/server/serverFindRefs.ml
@@ -60,6 +60,12 @@ let search_member class_name member include_defs genv env =
   in
   search target include_defs files genv env
 
+let search_gconst cst_name include_defs genv env =
+  let cst_name = add_ns cst_name in
+  let files = FindRefsService.get_dependent_files_gconst
+    env.tcopt genv.ServerEnv.workers cst_name in
+  search (FindRefsService.IGConst cst_name) include_defs files genv env
+
 let search_class class_name include_defs genv env =
   let class_name = add_ns class_name in
   let files = FindRefsService.get_dependent_files env.tcopt
@@ -74,6 +80,8 @@ let get_refs action include_defs genv env =
       search_function function_name include_defs genv env
   | FindRefsService.Class class_name ->
       search_class class_name include_defs genv env
+  | FindRefsService.GConst cst_name ->
+      search_gconst cst_name include_defs genv env
 
 let get_refs_with_defs action genv env =
   get_refs action true genv env
@@ -103,6 +111,7 @@ let go_from_file (content, line, char) genv env =
       | SymbolOccurrence.Typeconst (class_name, tconst_name) ->
           Some (FindRefsService.Member
             (class_name, FindRefsService.Typeconst tconst_name))
+      | SymbolOccurrence.GConst -> Some (FindRefsService.GConst name)
       | _ -> None
     end >>= fun action ->
     Some (go action genv env)
diff --git a/hphp/hack/src/server/serverHighlightRefs.ml b/hphp/hack/src/server/serverHighlightRefs.ml
index 1be7c42..851f030 100644
--- a/hphp/hack/src/server/serverHighlightRefs.ml
+++ b/hphp/hack/src/server/serverHighlightRefs.ml
@@ -11,8 +11,6 @@
 open Core
 open ServerEnv
 
-type result = Pos.absolute list
-
 let get_target symbol =
   let open SymbolOccurrence in
   let open FindRefsService in
@@ -31,6 +29,7 @@ let get_target symbol =
   | SymbolOccurrence.Typeconst  (class_name, member_name) ->
       Some (IMember (Subclasses_of class_name,
         FindRefsService.Typeconst member_name))
+  | SymbolOccurrence.GConst -> Some (IGConst symbol.name)
   | _ -> None
 
 let highlight_symbol tcopt (line, char) path file_info symbol =
diff --git a/hphp/hack/src/server/serverHighlightRefs.mli b/hphp/hack/src/server/serverHighlightRefs.mli
index a89ebeb..141ff80 100644
--- a/hphp/hack/src/server/serverHighlightRefs.mli
+++ b/hphp/hack/src/server/serverHighlightRefs.mli
@@ -8,8 +8,8 @@
  *
  *)
 
-type result = Pos.absolute list
+val go_from_file: (string * int * int) -> ServerEnv.env ->
+  ServerHighlightRefsTypes.result
 
-val go_from_file: (string * int * int) -> ServerEnv.env -> result
-
-val go: (string * int * int) -> TypecheckerOptions.t -> result
+val go: (string * int * int) -> TypecheckerOptions.t ->
+  ServerHighlightRefsTypes.result
diff --git a/hphp/hack/src/server/serverHighlightRefsTypes.ml b/hphp/hack/src/server/serverHighlightRefsTypes.ml
new file mode 100644
index 0000000..178f2f0
--- /dev/null
+++ b/hphp/hack/src/server/serverHighlightRefsTypes.ml
@@ -0,0 +1,11 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+ type result = Pos.absolute list
diff --git a/hphp/hack/src/server/serverIdeUtils.ml b/hphp/hack/src/server/serverIdeUtils.ml
index 29ab077..0da1667 100644
--- a/hphp/hack/src/server/serverIdeUtils.ml
+++ b/hphp/hack/src/server/serverIdeUtils.ml
@@ -21,12 +21,6 @@ let canon_set names =
   |> List.map ~f:NamingGlobal.canon_key
   |> List.fold_left ~f:SSet.add ~init:SSet.empty
 
-let report_error exn =
-  let exn_str = Printexc.to_string exn in
-  Printf.printf "Could not auto-complete because of errors: %s\n" exn_str;
-  flush stdout;
-  ()
-
 let oldify_funs names =
   Naming_heap.FunPosHeap.oldify_batch names;
   Naming_heap.FunCanonHeap.oldify_batch @@ canon_set names;
@@ -47,6 +41,10 @@ let oldify_typedefs names =
   Naming_heap.TypeCanonHeap.oldify_batch @@ canon_set names;
   Decl_heap.Typedefs.oldify_batch names
 
+let oldify_consts names =
+  Naming_heap.ConstPosHeap.oldify_batch names;
+  Decl_heap.GConsts.oldify_batch names
+
 let oldify_file name =
   Parser_heap.ParserHeap.oldify_batch @@
     Parser_heap.ParserHeap.KeySet.singleton name
@@ -54,13 +52,14 @@ let oldify_file name =
 let oldify_file_info path file_info =
   oldify_file path;
   let {
-    FileInfo.n_funs; n_classes; n_types; n_consts = _
+    FileInfo.n_funs; n_classes; n_types; n_consts
   } = FileInfo.simplify file_info in
   oldify_funs n_funs;
   oldify_classes n_classes;
-  oldify_typedefs n_types
+  oldify_typedefs n_types;
+  oldify_consts n_consts
 
-let revive funs classes typedefs file_name =
+let revive funs classes typedefs consts file_name =
   Decl_heap.Funs.revive_batch funs;
   Naming_heap.FunPosHeap.revive_batch funs;
   Naming_heap.FunCanonHeap.revive_batch @@ canon_set funs;
@@ -76,14 +75,17 @@ let revive funs classes typedefs file_name =
   Naming_heap.TypeCanonHeap.revive_batch @@ canon_set typedefs;
   Decl_heap.Typedefs.revive_batch typedefs;
 
+  Naming_heap.ConstPosHeap.revive_batch consts;
+  Decl_heap.GConsts.revive_batch consts;
+
   Parser_heap.ParserHeap.revive_batch @@
     Parser_heap.ParserHeap.KeySet.singleton file_name
 
 let revive_file_info path file_info =
   let {
-    FileInfo.n_funs; n_classes; n_types; n_consts = _
+    FileInfo.n_funs; n_classes; n_types; n_consts
   } = FileInfo.simplify file_info in
-  revive n_funs n_classes n_types path
+  revive n_funs n_classes n_types n_consts path
 
 let path = Relative_path.default
 (* This will parse, declare and check all functions and classes in content
@@ -98,38 +100,39 @@ let declare_and_check content ~f =
   let tcopt = TypecheckerOptions.permissive in
   Autocomplete.auto_complete := false;
   Autocomplete.auto_complete_for_global := "";
-  let file_info = try
+  let file_info =
     Errors.ignore_ begin fun () ->
       let {Parser_hack.file_mode = _; comments = _; ast} =
         Parser_hack.program path content
       in
-      let funs, classes, typedefs =
-        List.fold_left ast ~f:begin fun (funs, classes, typedefs) def ->
+      let funs, classes, typedefs, consts =
+        List.fold_left ast ~f:begin fun (funs, classes, typedefs, consts) def ->
         match def with
           | Ast.Fun { Ast.f_name; _ } ->
-            f_name::funs, classes, typedefs
+            f_name::funs, classes, typedefs, consts
           | Ast.Class { Ast.c_name; _ } ->
-            funs, c_name::classes, typedefs
+            funs, c_name::classes, typedefs, consts
           | Ast.Typedef { Ast.t_id; _ } ->
-            funs, classes, t_id::typedefs
-          | _ -> funs, classes, typedefs
-      end ~init:([], [], []) in
+            funs, classes, t_id::typedefs, consts
+          | Ast.Constant { Ast.cst_name; _ } ->
+            funs, classes, typedefs, cst_name::consts
+          | _ -> funs, classes, typedefs, consts
+      end ~init:([], [], [], []) in
 
       let file_info = { FileInfo.empty_t with
-        FileInfo.funs; classes; typedefs;
+        FileInfo.funs; classes; typedefs; consts;
       } in
 
       oldify_file_info path file_info;
 
       Parser_heap.ParserHeap.add path ast;
-      NamingGlobal.make_env ~funs ~classes ~typedefs ~consts:[];
+      NamingGlobal.make_env ~funs ~classes ~typedefs ~consts;
       let nast = Naming.program tcopt ast in
       List.iter nast begin function
         | Nast.Fun f -> Decl.fun_decl f
         | Nast.Class c -> Decl.class_decl tcopt c
         | Nast.Typedef t -> Decl.typedef_decl t
-        (* XXX should probably declare consts here too *)
-        | _ -> ()
+        | Nast.Constant cst -> Decl.const_decl cst
       end;
       (* We must run all the declaration steps first to ensure that the
        * typechecking below sees all the new declarations. Lazy decl
@@ -138,14 +141,11 @@ let declare_and_check content ~f =
       List.iter nast begin function
         | Nast.Fun f -> Typing.fun_def tcopt f;
         | Nast.Class c -> Typing.class_def tcopt c;
-        | Nast.Typedef t -> Typing.typedef_def t
-        | _ -> ()
+        | Nast.Typedef t -> Typing.typedef_def t;
+        | Nast.Constant cst -> Typing.gconst_def cst;
       end;
       file_info
     end
-  with e ->
-    report_error e;
-    FileInfo.empty_t
   in
   let result = f path file_info in
   revive_file_info path file_info;
diff --git a/hphp/hack/src/server/serverIdentifyFunction.ml b/hphp/hack/src/server/serverIdentifyFunction.ml
index bcb80c2..105b6a5 100644
--- a/hphp/hack/src/server/serverIdentifyFunction.ml
+++ b/hphp/hack/src/server/serverIdentifyFunction.ml
@@ -11,9 +11,6 @@
 open Core
 open ServerEnv
 
-type result =
-  ((string SymbolOccurrence.t) * (string SymbolDefinition.t option)) list
-
 (* Identifying a symbol can be a first step to another operation. For example,
  * you can identify symbol and then highlight other "equal" symbols.
  * get_occurrence_and_map is useful for such application, because ~f function
diff --git a/hphp/hack/src/server/serverInferType.ml b/hphp/hack/src/server/serverInferType.ml
index 103f298..27989dc 100644
--- a/hphp/hack/src/server/serverInferType.ml
+++ b/hphp/hack/src/server/serverInferType.ml
@@ -8,8 +8,6 @@
  *
  *)
 
-type result = Pos.absolute option * string option
-
 let go (env:ServerEnv.env) (fn, line, char) =
   let get_result = InferAtPosService.attach_hooks line char in
   ignore @@ ServerIdeUtils.check_file_input
diff --git a/hphp/hack/src/server/serverInit.ml b/hphp/hack/src/server/serverInit.ml
index eb9a1c0..1368f8a 100644
--- a/hphp/hack/src/server/serverInit.ml
+++ b/hphp/hack/src/server/serverInit.ml
@@ -59,8 +59,9 @@ let make_next_files genv : Relative_path.t MultiWorker.nextlist =
     (FindUtils.is_php s)
       (** If experimental disabled, we don't parse hhi files under
        * the experimental directory. *)
-      && (TypecheckerOptions.experimental_features
-        (ServerConfig.typechecker_options genv.config)
+      && (TypecheckerOptions.experimental_feature_enabled
+          (ServerConfig.typechecker_options genv.config)
+          TypecheckerOptions.experimental_dict
         || not (FindUtils.has_ancestor s "experimental"))
 
   end in
@@ -200,7 +201,7 @@ let indexing genv =
 
 let parsing genv env ~get_next t =
   let files_info, errorl, failed =
-    Parsing_service.go genv.workers SMap.empty ~get_next in
+    Parsing_service.go genv.workers Relative_path.Map.empty ~get_next in
   let files_info = Relative_path.Map.union files_info env.files_info in
   let hs = SharedMem.heap_size () in
   Hh_logger.log "Heap size: %d" hs;
@@ -337,15 +338,15 @@ let ai_check genv files_info env t =
   | None -> env, t
 
 let print_hash_stats () =
-  let {SharedMem.used_slots; slots} = SharedMem.dep_stats () in
+  let {SharedMem.used_slots; slots; nonempty_slots = _} = SharedMem.dep_stats () in
   let load_factor = float_of_int used_slots /. float_of_int slots in
   Hh_logger.log "Dependency table load factor: %d / %d (%.02f)"
     used_slots slots load_factor;
 
-  let {SharedMem.used_slots; slots} = SharedMem.hash_stats () in
+  let {SharedMem.used_slots; slots; nonempty_slots} = SharedMem.hash_stats () in
   let load_factor = float_of_int used_slots /. float_of_int slots in
-  Hh_logger.log "Hashtable load factor: %d / %d (%.02f)"
-    used_slots slots load_factor;
+  Hh_logger.log "Hashtable load factor: %d / %d (%.02f) with %d nonempty slots"
+    used_slots slots load_factor nonempty_slots;
   ()
 
 let get_build_targets env =
@@ -355,6 +356,9 @@ let get_build_targets env =
 
 (* entry point *)
 let init ?load_mini_script genv =
+  (* Log lazy declarations *)
+  let lazy_decl = genv.local_config.SLC.lazy_decl
+    && Option.is_none (ServerArgs.ai_mode genv.options) in
   let env = ServerEnvBuild.make_env genv.config in
   let root = ServerArgs.root genv.options in
 
@@ -380,11 +384,9 @@ let init ?load_mini_script genv =
   let env, t = naming env t in
   let fast = FileInfo.simplify_fast env.files_info in
   let fast = Relative_path.Set.fold env.failed_parsing
-    ~f:Relative_path.Map.remove ~init:fast in
+    ~f:(fun x m -> Relative_path.Map.remove m x) ~init:fast in
   let env, t =
-    if genv.local_config.SLC.lazy_decl
-      && Option.is_none (ServerArgs.ai_mode genv.options)
-    then env, t
+    if lazy_decl then env, t
     else type_decl genv env fast t in
 
   let state = state_future >>= fun f ->
diff --git a/hphp/hack/src/server/serverInit.mli b/hphp/hack/src/server/serverInit.mli
index 382dbf4..e0b83a2 100644
--- a/hphp/hack/src/server/serverInit.mli
+++ b/hphp/hack/src/server/serverInit.mli
@@ -16,3 +16,5 @@ val save_state: ServerEnv.env -> string -> unit
  *)
 val init: ?load_mini_script:Path.t -> ServerEnv.genv
   -> ServerEnv.env * bool (* whether the script succeeded *)
+
+val print_hash_stats: unit -> unit
diff --git a/hphp/hack/src/server/serverLint.ml b/hphp/hack/src/server/serverLint.ml
index 2e620fe..dd5b0c0 100644
--- a/hphp/hack/src/server/serverLint.ml
+++ b/hphp/hack/src/server/serverLint.ml
@@ -14,8 +14,6 @@ open Utils
 
 module RP = Relative_path
 
-type result = string Lint.t list
-
 let output_json oc el =
   let errors_json = List.map el Lint.to_json in
   let res =
diff --git a/hphp/hack/src/server/serverLintTypes.ml b/hphp/hack/src/server/serverLintTypes.ml
new file mode 100644
index 0000000..cc984da
--- /dev/null
+++ b/hphp/hack/src/server/serverLintTypes.ml
@@ -0,0 +1,11 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+ type result = string Lint.t list
diff --git a/hphp/hack/src/server/serverMain.ml b/hphp/hack/src/server/serverMain.ml
index 6f2bf36..32e6ffc 100644
--- a/hphp/hack/src/server/serverMain.ml
+++ b/hphp/hack/src/server/serverMain.ml
@@ -10,7 +10,6 @@
 
 open Core
 open ServerEnv
-open ServerUtils
 open Reordered_argument_collections
 open String_utils
 
@@ -19,18 +18,18 @@ type recheck_loop_stats = {
   rechecked_count : int;
   (* includes dependencies *)
   total_rechecked_count : int;
-  reparsed_files : Relative_path.Set.t;
-  check_later : SSet.t;
 }
 
+type main_loop_stats = recheck_loop_stats ref * string ref
+
 let empty_recheck_loop_stats = {
   rechecked_batches = 0;
   rechecked_count = 0;
   total_rechecked_count = 0;
-  reparsed_files = Relative_path.Set.empty;
-  check_later = SSet.empty;
 }
 
+let get_rechecked_count (stats_ref, _) = !stats_ref.rechecked_count
+
 (*****************************************************************************)
 (* Main initialization *)
 (*****************************************************************************)
@@ -64,6 +63,7 @@ module Program =
          be 'restored' in the workers, because they are not 'forked'
          anymore. See `ServerWorker.{save/restore}_state`. *)
       HackSearchService.attach_hooks ();
+
       Sys_utils.set_signal Sys.sigusr1
         (Sys.Signal_handle Typing.debug_print_last_pos);
       Sys_utils.set_signal Sys.sigusr2
@@ -103,13 +103,13 @@ module Program =
         let new_env, total_rechecked = ServerTypeCheck.check genv check_env in
         ServerStamp.touch_stamp_errors (Errors.get_error_list old_env.errorl)
                                        (Errors.get_error_list new_env.errorl);
-        if not @@ Diagnostic_subscription.is_empty new_env.diag_subscribe
-        then begin
-          let id = Diagnostic_subscription.get_id new_env.diag_subscribe in
-          let errors_json = ServerError.get_errorl_json_array new_env.errorl in
-          let res = IdeJson.Diagnostic_response (id, errors_json) in
-          let fd = ServerCommand.get_persistent_fds new_env in
-          ServerCommand.send_response_to_client fd res;
+        Option.iter new_env.diag_subscribe ~f:begin fun sub ->
+          let id = Diagnostic_subscription.get_id sub in
+          let errors = Errors.get_error_list new_env.errorl in
+          let errors = List.map ~f:Errors.to_absolute errors in
+          let res = ServerCommandTypes.DIAGNOSTIC (id, errors) in
+          let client = Utils.unsafe_opt new_env.persistent_client in
+          ClientProvider.send_push_message_to_client client res;
         end;
         new_env, total_rechecked
       end
@@ -120,74 +120,63 @@ module Program =
 (* The main loop *)
 (*****************************************************************************)
 
-let sleep_and_check in_fd per_in_fd =
-  let l = match per_in_fd with
-  | Some fd -> [in_fd ; fd]
-  | None -> [in_fd] in
-  let ready_fd_l, _, _ = Unix.select l [] [] (0.5) in
-  match ready_fd_l with
-  | [_; _] -> true, true
-  | [fd] -> if (fd <> in_fd) then false, true else true, false
-  | _ -> false, false
-
-let handle_connection_ genv env ic oc =
+let handle_connection_ genv env client =
+  let open ServerCommandTypes in
   try
-    ServerCommand.say_hello oc;
-    match ServerCommand.read_connection_type ic with
-    | ServerCommand.Persistent ->
-      let fd = Unix.descr_of_out_channel oc in
-      (match env.persistent_client_fd with
+    match ClientProvider.read_connection_type client with
+    | Persistent ->
+      (match env.persistent_client with
       | Some _ ->
-        ServerCommand.send_response_to_client fd
-          ServerCommand.Persistent_client_alredy_exists;
+        ClientProvider.send_response_to_client client
+          Persistent_client_alredy_exists;
         env
       | None ->
-        ServerCommand.send_response_to_client fd
-          ServerCommand.Persistent_client_connected;
-        { env with persistent_client_fd =
-          Some (Timeout.descr_of_in_channel ic)})
-    | ServerCommand.Non_persistent ->
-      ServerCommand.handle genv env (ic, oc)
+        ClientProvider.send_response_to_client client
+          Persistent_client_connected;
+        { env with persistent_client =
+            Some (ClientProvider.make_persistent client)})
+    | Non_persistent ->
+      ServerCommand.handle genv env client
   with
-  | Sys_error("Broken pipe") | ServerCommand.Read_command_timeout ->
-    shutdown_client (ic, oc);
+  | Sys_error("Broken pipe") | Read_command_timeout ->
+    ClientProvider.shutdown_client client;
     env
   | e ->
     let msg = Printexc.to_string e in
     EventLogger.master_exception msg;
     Printf.fprintf stderr "Error: %s\n%!" msg;
     Printexc.print_backtrace stderr;
-    shutdown_client (ic, oc);
+    ClientProvider.shutdown_client client;
     env
 
-let handle_persistent_connection_ genv env ic oc =
+let handle_persistent_connection_ genv env client =
    try
-     ServerCommand.handle genv env (ic, oc)
+     ServerCommand.handle genv env client
    with
-   | Sys_error("Broken pipe") | ServerCommand.Read_command_timeout ->
-     shutdown_client (ic, oc);
+   | Sys_error("Broken pipe") | ServerCommandTypes.Read_command_timeout ->
+     ClientProvider.shutdown_client client;
      {env with
-     persistent_client_fd = None;
-     edited_files = SMap.empty;
-     diag_subscribe = Diagnostic_subscription.empty;
+     persistent_client = None;
+     edited_files = Relative_path.Map.empty;
+     diag_subscribe = None;
      symbols_cache = SMap.empty}
    | e ->
      let msg = Printexc.to_string e in
      EventLogger.master_exception msg;
      Printf.fprintf stderr "Error: %s\n%!" msg;
      Printexc.print_backtrace stderr;
-     shutdown_client (ic, oc);
+     ClientProvider.shutdown_client client;
      {env with
-     persistent_client_fd = None;
-     edited_files = SMap.empty;
-     diag_subscribe = Diagnostic_subscription.empty;
+     persistent_client = None;
+     edited_files = Relative_path.Map.empty;
+     diag_subscribe = None;
      symbols_cache = SMap.empty}
 
-let handle_connection genv env ic oc is_persistent =
+let handle_connection genv env client is_persistent =
   ServerIdle.stamp_connection ();
   try match is_persistent with
-    | true -> handle_persistent_connection_ genv env ic oc
-    | false -> handle_connection_ genv env ic oc
+    | true -> handle_persistent_connection_ genv env client
+    | false -> handle_connection_ genv env client
   with
   | Unix.Unix_error (e, _, _) ->
      Printf.fprintf stderr "Unix error: %s\n" (Unix.error_message e);
@@ -208,7 +197,7 @@ let recheck genv old_env updates =
   let config_in_updates =
     Relative_path.Set.mem updates ServerConfig.filename in
   if config_in_updates then begin
-    let new_config = ServerConfig.(load filename genv.options) in
+    let new_config, _ = ServerConfig.(load filename genv.options) in
     if not (ServerConfig.is_compatible genv.config new_config) then begin
       Hh_logger.log
         "%s changed in an incompatible way; please restart %s.\n"
@@ -231,100 +220,105 @@ let recheck genv old_env updates =
 let rec recheck_loop acc genv env =
   let t = Unix.gettimeofday () in
   let raw_updates = genv.notifier () in
-  let check_later, raw_updates = match acc.rechecked_batches with
-  | 0 ->
-    let check_later, check_now = SSet.partition (fun s ->
-      File_content.being_edited @@ SMap.find_unsafe s env.edited_files)
-      env.files_to_check in
-    check_later, SSet.union raw_updates check_now
-  | _ -> acc.check_later, raw_updates in
-  if SSet.is_empty raw_updates then
-    acc, { env with files_to_check = check_later }
+
+  let is_idle = t -. env.last_command_time > 0.5 in
+
+  let disk_recheck = not (SSet.is_empty raw_updates) in
+  let ide_recheck =
+    (not @@ Relative_path.Set.is_empty env.files_to_check) && is_idle in
+  if (not disk_recheck) && (not ide_recheck) then
+    acc, env
   else begin
     HackEventLogger.notifier_returned t (SSet.cardinal raw_updates);
     let updates = Program.process_updates genv env raw_updates in
+    let updates = Relative_path.Set.union updates env.files_to_check in
     let env, rechecked, total_rechecked = recheck genv env updates in
     let acc = {
       rechecked_batches = acc.rechecked_batches + 1;
       rechecked_count =
         acc.rechecked_count + Relative_path.Set.cardinal rechecked;
       total_rechecked_count = acc.total_rechecked_count + total_rechecked;
-      reparsed_files = Relative_path.Set.union updates acc.reparsed_files;
-      check_later;
     } in
     recheck_loop acc genv env
   end
 
 let recheck_loop = recheck_loop empty_recheck_loop_stats
 
-(** Retrieve channels to client from monitor process. *)
-let get_client_channels parent_in_fd =
-  let socket = Libancillary.ancil_recv_fd parent_in_fd in
-  (Timeout.in_channel_of_descr socket), (Unix.out_channel_of_descr socket)
+let serve_one_iteration genv env client_provider stats_refs =
+  let last_stats, recheck_id = stats_refs in
+  ServerMonitorUtils.exit_if_parent_dead ();
+  let has_client, has_persistent =
+    ClientProvider.sleep_and_check client_provider env.persistent_client in
+  let has_parsing_hook = !ServerTypeCheck.hook_after_parsing <> None in
+  if not has_persistent && not has_client && not has_parsing_hook
+  then begin
+    (* Ugly hack: We want GC_SHAREDMEM_RAN to record the last rechecked
+     * count so that we can figure out if the largest reclamations
+     * correspond to massive rebases. However, the logging call is done in
+     * the SharedMem module, which doesn't know anything about Server stuff.
+     * So we wrap the call here. *)
+    HackEventLogger.with_rechecked_stats
+      !last_stats.rechecked_batches
+      !last_stats.rechecked_count
+      !last_stats.total_rechecked_count
+      ServerIdle.go;
+    recheck_id := Random_id.short_string ();
+  end;
+  let start_t = Unix.gettimeofday () in
+  HackEventLogger.with_id ~stage:`Recheck !recheck_id @@ fun () ->
+  let stats, env = recheck_loop genv env in
+  if stats.rechecked_count > 0 then begin
+    HackEventLogger.recheck_end start_t has_parsing_hook
+      stats.rechecked_batches
+      stats.rechecked_count
+      stats.total_rechecked_count;
+    Hh_logger.log "Recheck id: %s" !recheck_id;
+  end;
+  last_stats := stats;
+  let env = if has_client then
+    (try
+      let client = ClientProvider.accept_client client_provider in
+      HackEventLogger.got_client_channels start_t;
+      (try
+        let env = handle_connection genv env client false in
+        HackEventLogger.handled_connection start_t;
+        env
+      with
+      | e ->
+        HackEventLogger.handle_connection_exception e;
+        Hh_logger.log "Handling client failed. Ignoring.";
+        env)
+    with
+    | e ->
+      HackEventLogger.get_client_channels_exception e;
+      Hh_logger.log
+        "Getting Client FDs failed. Ignoring.";
+      env)
+  else env in
+  if has_persistent then
+    let client = Utils.unsafe_opt env.persistent_client in
+    HackEventLogger.got_persistent_client_channels start_t;
+    (try
+      let env = handle_connection genv env client true in
+      HackEventLogger.handled_persistent_connection start_t;
+      env
+    with
+    | e ->
+      HackEventLogger.handle_persistent_connection_exception e;
+      Hh_logger.log "Handling persistent client failed. Ignoring.";
+      env)
+  else env
+
+let empty_stats () =
+  (ref empty_recheck_loop_stats,
+  ref (Random_id.short_string ()))
 
 let serve genv env in_fd _ =
+  let client_provider = ClientProvider.provider_from_file_descriptor in_fd in
   let env = ref env in
-  let last_stats = ref empty_recheck_loop_stats in
-  let recheck_id = ref (Random_id.short_string ()) in
+  let stats = empty_stats () in
   while true do
-    ServerMonitorUtils.exit_if_parent_dead ();
-    let per_fd = !env.persistent_client_fd in
-    let has_client, has_persistent = sleep_and_check in_fd per_fd in
-    let has_parsing_hook = !ServerTypeCheck.hook_after_parsing <> None in
-    if not has_persistent && not has_client && not has_parsing_hook
-    then begin
-      (* Ugly hack: We want GC_SHAREDMEM_RAN to record the last rechecked
-       * count so that we can figure out if the largest reclamations
-       * correspond to massive rebases. However, the logging call is done in
-       * the SharedMem module, which doesn't know anything about Server stuff.
-       * So we wrap the call here. *)
-      HackEventLogger.with_rechecked_stats
-        !last_stats.rechecked_batches
-        !last_stats.rechecked_count
-        !last_stats.total_rechecked_count
-        ServerIdle.go;
-      recheck_id := Random_id.short_string ();
-    end;
-    let start_t = Unix.gettimeofday () in
-    HackEventLogger.with_id ~stage:`Recheck !recheck_id @@ fun () ->
-    let stats, new_env = recheck_loop genv !env in
-    if stats.rechecked_count > 0 then begin
-      HackEventLogger.recheck_end start_t has_parsing_hook
-        stats.rechecked_batches
-        stats.rechecked_count
-        stats.total_rechecked_count;
-      Hh_logger.log "Recheck id: %s" !recheck_id;
-    end;
-    env := new_env;
-    last_stats := stats;
-    if has_client then
-      (try
-        let ic, oc = get_client_channels in_fd in
-        HackEventLogger.got_client_channels start_t;
-        (try
-          env := handle_connection genv !env ic oc false;
-          HackEventLogger.handled_connection start_t;
-        with
-        | e ->
-          HackEventLogger.handle_connection_exception e;
-          Hh_logger.log "Handling client failed. Ignoring.")
-      with
-      | e ->
-        HackEventLogger.get_client_channels_exception e;
-        Hh_logger.log
-          "Getting Client FDs failed. Ignoring.");
-    if has_persistent then
-      let fd = ServerCommand.get_persistent_fds !env in
-      let ic, oc =
-        Timeout.in_channel_of_descr fd, Unix.out_channel_of_descr fd in
-      HackEventLogger.got_persistent_client_channels start_t;
-      (try
-        env := handle_connection genv !env ic oc true;
-        HackEventLogger.handled_persistent_connection start_t;
-      with
-      | e ->
-        HackEventLogger.handle_persistent_connection_exception e;
-        Hh_logger.log "Handling persistent client failed. Ignoring.");
+    env := serve_one_iteration genv !env client_provider stats;
   done
 
 let program_init genv =
@@ -359,16 +353,17 @@ let setup_server options handle =
    * overhead *)
   let gc_control = Gc.get () in
   Gc.set {gc_control with Gc.max_overhead = 200};
-  let config = ServerConfig.(load filename options) in
+  let config, local_config = ServerConfig.(load filename options) in
   let {ServerLocalConfig.
     cpu_priority;
     io_priority;
     enable_on_nfs;
+    lazy_decl;
     _
-  } as local_config = ServerLocalConfig.load () in
+  } as local_config = local_config in
   if Sys_utils.is_test_mode ()
   then EventLogger.init (Daemon.devnull ()) 0.0
-  else HackEventLogger.init root (Unix.gettimeofday ());
+  else HackEventLogger.init root (Unix.gettimeofday ()) lazy_decl;
   let root_s = Path.to_string root in
   if Sys_utils.is_nfs root_s && not enable_on_nfs then begin
     Hh_logger.log "Refusing to run on %s: root is on NFS!" root_s;
@@ -401,9 +396,12 @@ let run_once options handle =
  * The server monitor will pass client connections to this process
  * via ic.
  *)
-let daemon_main_exn (handle, options) (ic, oc) =
+let daemon_main_exn options (ic, oc) =
   let in_fd = Daemon.descr_of_in_channel ic in
   let out_fd = Daemon.descr_of_out_channel oc in
+  let config, _ = ServerConfig.(load filename options) in
+  let handle = SharedMem.init (ServerConfig.sharedmem_config config) in
+  SharedMem.connect handle ~is_master:true;
 
   let genv = setup_server options handle in
   if ServerArgs.check_mode genv.options then
@@ -412,15 +410,19 @@ let daemon_main_exn (handle, options) (ic, oc) =
   let env = MainInit.go options (fun () -> program_init genv) in
   serve genv env in_fd out_fd
 
-let daemon_main (state, handle, options) (ic, oc) =
-  (* Even though the server monitor set up the shared memory, the server daemon
-   * is master here *)
-  SharedMem.connect handle ~is_master:true;
+let daemon_main (state, options) (ic, oc) =
+  (* Restore the root directory and other global states from monitor *)
   ServerGlobalState.restore state;
-  try daemon_main_exn (handle, options) (ic, oc)
-  with SharedMem.Out_of_shared_memory ->
+  try daemon_main_exn options (ic, oc)
+  with
+  | SharedMem.Out_of_shared_memory ->
+    ServerInit.print_hash_stats ();
     Printf.eprintf "Error: failed to allocate in the shared heap.\n%!";
     Exit_status.(exit Out_of_shared_memory)
+  | SharedMem.Hash_table_full ->
+    ServerInit.print_hash_stats ();
+    Printf.eprintf "Error: failed to allocate in the shared hashtable.\n%!";
+    Exit_status.(exit Hash_table_full)
 
 let entry =
   Daemon.register_entry_point "ServerMain.daemon_main" daemon_main
diff --git a/hphp/hack/src/server/serverMain.mli b/hphp/hack/src/server/serverMain.mli
index b988705..498164ed 100644
--- a/hphp/hack/src/server/serverMain.mli
+++ b/hphp/hack/src/server/serverMain.mli
@@ -12,6 +12,19 @@
  * to the underlying file descriptor -- but we have to declare some type for
  * these phantom types because OCaml doesn't allow polymorphic values that
  * are not functions. *)
-val entry: (ServerGlobalState.t * SharedMem.handle * ServerArgs.options, unit, unit) Daemon.entry
+val entry: (ServerGlobalState.t * ServerArgs.options, unit, unit) Daemon.entry
 
 val run_once: ServerArgs.options -> SharedMem.handle -> 'a
+
+(* Things exposed for tests *)
+type main_loop_stats
+
+val empty_stats: unit -> main_loop_stats
+val get_rechecked_count: main_loop_stats -> int
+
+val serve_one_iteration:
+  ServerEnv.genv ->
+  ServerEnv.env ->
+  ClientProvider.t ->
+  main_loop_stats ->
+  ServerEnv.env
diff --git a/hphp/hack/src/server/serverRefactor.ml b/hphp/hack/src/server/serverRefactor.ml
index 45d5671..165b04d 100644
--- a/hphp/hack/src/server/serverRefactor.ml
+++ b/hphp/hack/src/server/serverRefactor.ml
@@ -10,22 +10,7 @@
 
 open Core
 open ServerEnv
-
-type patch =
-  | Insert of insert_patch
-  | Remove of Pos.absolute
-  | Replace of insert_patch
-
-and insert_patch = {
-  pos: Pos.absolute;
-  text: string;
-}
-
-type action =
-  | ClassRename of string * string (* old_name * new_name *)
-  | MethodRename of string * string * string
-    (* class_name * old_name * new_name*)
-  | FunctionRename of string * string (* old_name * new_name *)
+open ServerRefactorTypes
 
 let get_fixme_patches codes (env: env) =
   let fixmelist = Errors.get_applied_fixmes env.errorl in
diff --git a/hphp/hack/src/server/serverRefactorTypes.ml b/hphp/hack/src/server/serverRefactorTypes.ml
new file mode 100644
index 0000000..fdff3f3
--- /dev/null
+++ b/hphp/hack/src/server/serverRefactorTypes.ml
@@ -0,0 +1,25 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+ type patch =
+  | Insert of insert_patch
+  | Remove of Pos.absolute
+  | Replace of insert_patch
+
+and insert_patch = {
+  pos: Pos.absolute;
+  text: string;
+}
+
+type action =
+  | ClassRename of string * string (* old_name * new_name *)
+  | MethodRename of string * string * string
+    (* class_name * old_name * new_name*)
+  | FunctionRename of string * string (* old_name * new_name *)
diff --git a/hphp/hack/src/server/serverRpc.ml b/hphp/hack/src/server/serverRpc.ml
index cf1a500..af88549 100644
--- a/hphp/hack/src/server/serverRpc.ml
+++ b/hphp/hack/src/server/serverRpc.ml
@@ -9,53 +9,10 @@
  *)
 
 open Core
+open Reordered_argument_collections
 open ServerEnv
 open File_content
-
-(* The following datatypes can be interpreted as follows:
- * MESSAGE_TAG : Argument type (sent from client to server) -> return type t *)
-type _ t =
-  | STATUS : Pos.absolute Errors.error_ list t
-  | INFER_TYPE : ServerUtils.file_input * int * int -> ServerInferType.result t
-  | COVERAGE_LEVELS : ServerUtils.file_input -> ServerColorFile.result t
-  | AUTOCOMPLETE : string -> AutocompleteService.result t
-  | IDENTIFY_FUNCTION : string * int * int -> ServerIdentifyFunction.result t
-  | OUTLINE : string -> FileOutline.outline t
-  | GET_DEFINITION_BY_ID : string -> string SymbolDefinition.t option t
-  | METHOD_JUMP : (string * bool) -> MethodJumps.result list t
-  | FIND_DEPENDENT_FILES: string list -> string list t
-  | FIND_REFS : FindRefsService.action -> FindRefsService.result t
-  | IDE_FIND_REFS : string * int * int -> FindRefsService.result t
-  | IDE_HIGHLIGHT_REFS : string * int * int -> ServerHighlightRefs.result t
-  | REFACTOR : ServerRefactor.action -> ServerRefactor.patch list t
-  | DUMP_SYMBOL_INFO : string list -> SymbolInfoService.result t
-  | DUMP_AI_INFO : string list -> Ai.InfoService.result t
-  | REMOVE_DEAD_FIXMES : int list -> ServerRefactor.patch list t
-  | ARGUMENT_INFO : string * int * int -> ServerArgumentInfo.result t
-  | SEARCH : string * string -> ServerSearch.result t
-  | COVERAGE_COUNTS : string -> ServerCoverageMetric.result t
-  | LINT : string list -> ServerLint.result t
-  | LINT_ALL : int -> ServerLint.result t
-  | CREATE_CHECKPOINT : string -> unit t
-  | RETRIEVE_CHECKPOINT : string -> string list option t
-  | DELETE_CHECKPOINT : string -> bool t
-  | STATS : Stats.t t
-  | KILL : unit t
-  | FIND_LVAR_REFS : string * int * int -> ServerFindLocals.result t
-  | FORMAT : string * int * int -> string Format_hack.return t
-  | TRACE_AI : Ai.TraceService.action -> string t
-  | AI_QUERY : string -> string t
-  | ECHO_FOR_TEST : string -> string t
-  | OPEN_FILE : string -> unit t
-  | CLOSE_FILE : string -> unit t
-  | EDIT_FILE : string * (code_edit list) -> unit t
-  | IDE_AUTOCOMPLETE : string * content_pos -> AutocompleteService.result t
-  | IDE_HIGHLIGHT_REF : string * content_pos -> ServerHighlightRefs.result t
-  | IDE_IDENTIFY_FUNCTION : string * content_pos ->
-      ServerIdentifyFunction.result t
-  | DISCONNECT : unit t
-  | SUBSCRIBE_DIAGNOSTIC : int -> unit t
-  | UNSUBSCRIBE_DIAGNOSTIC : int -> unit t
+open ServerCommandTypes
 
 let handle : type a. genv -> env -> a t -> env * a =
   fun genv env -> function
@@ -123,57 +80,69 @@ let handle : type a. genv -> env -> a t -> env * a =
     | ECHO_FOR_TEST msg ->
         env, msg
     | OPEN_FILE path ->
-        let path = Relative_path.path_of_prefix Relative_path.Root ^ path in
+        let path = Relative_path.(concat Root path) in
         let content =
-          try Sys_utils.cat path with _ -> "" in
+          try Sys_utils.cat (Relative_path.to_absolute path) with _ -> "" in
         let fc = of_content ~content in
-        let edited_files_ = (SMap.add path fc env.edited_files) in
-        let files_to_check_ = (SSet.add path env.files_to_check) in
-        let new_env = {env with edited_files = edited_files_;
-          files_to_check = files_to_check_} in
+        let edited_files = Relative_path.Map.add env.edited_files path fc in
+        let files_to_check = Relative_path.Set.add env.files_to_check path in
+        let last_command_time = Unix.gettimeofday () in
+        let new_env = { env with
+          edited_files; files_to_check; last_command_time;
+        } in
         new_env, ()
     | CLOSE_FILE path ->
-        let path = Relative_path.path_of_prefix Relative_path.Root ^ path in
-        let edited_files_ = SMap.remove path env.edited_files in
-        let files_to_check_ = (SSet.remove path env.files_to_check) in
-        let new_env = {env with edited_files = edited_files_;
-          files_to_check = files_to_check_} in
+        let path = Relative_path.(concat Root path) in
+        let edited_files = Relative_path.Map.remove env.edited_files path in
+        let files_to_check =
+          Relative_path.Set.remove env.files_to_check path in
+        let last_command_time = Unix.gettimeofday () in
+        let new_env = { env with
+          edited_files; files_to_check; last_command_time
+        } in
         new_env, ()
     | EDIT_FILE (path, edits) ->
-        let path = Relative_path.path_of_prefix Relative_path.Root ^ path in
-        let fc = try SMap.find_unsafe path env.edited_files
+        let path = Relative_path.(concat Root path) in
+        let fc = try Relative_path.Map.find_unsafe env.edited_files path
         with Not_found ->
-          let content = try Sys_utils.cat path with _ -> "" in
+          let content =
+            try Sys_utils.cat (Relative_path.to_absolute path) with _ -> "" in
           of_content ~content in
         let edited_fc = edit_file fc edits in
-        let edited_files_ = (SMap.add path edited_fc env.edited_files) in
-        let files_to_check_ = (SSet.add path env.files_to_check) in
-        let new_env = {env with edited_files = edited_files_;
-          files_to_check = files_to_check_} in
+        let edited_files =
+          Relative_path.Map.add env.edited_files path edited_fc in
+        let files_to_check =
+          Relative_path.Set.add env.files_to_check path in
+        let last_command_time = Unix.gettimeofday () in
+        let new_env = { env with
+          edited_files; files_to_check; last_command_time
+        } in
         new_env, ()
     | IDE_AUTOCOMPLETE (path, pos) ->
-        let path = Relative_path.path_of_prefix Relative_path.Root ^ path in
+        let path = Relative_path.(concat Root path) in
         let fc = try
-        SMap.find_unsafe path env.edited_files
+        Relative_path.Map.find_unsafe env.edited_files path
         with Not_found ->
-        let content = try Sys_utils.cat path with _ -> "" in
+        let content =
+          try Sys_utils.cat (Relative_path.to_absolute path) with _ -> "" in
         of_content content in
         let edits = [{range = Some {st = pos; ed = pos}; text = "AUTO332"}] in
         let edited_fc = edit_file fc edits in
         let content = get_content edited_fc in
         env, ServerAutoComplete.auto_complete env.tcopt content
     | IDE_HIGHLIGHT_REF (path, {line; column}) ->
+        let relative_path = Relative_path.(concat Root path) in
         let path = Relative_path.path_of_prefix Relative_path.Root ^ path in
-        begin match SMap.exists (fun p _ -> p = path) env.edited_files with
+        begin match Relative_path.Map.mem env.edited_files relative_path with
         | true ->
-          begin match SMap.exists (fun p _ -> p = path) env.symbols_cache with
+          begin match SMap.exists env.symbols_cache (fun p _ -> p = path) with
           | true ->
             env, ServerHighlightRefs.go_from_file (path, line, column) env
           | false ->
-            let content = File_content.get_content @@ SMap.find_unsafe path
-              env.edited_files in
+            let content = File_content.get_content @@
+              Relative_path.Map.find_unsafe env.edited_files relative_path in
             let res = ServerIdentifyFunction.get_full_occurrence_pair content in
-            let symbols_cache_ = SMap.add path res env.symbols_cache in
+            let symbols_cache_ = SMap.add env.symbols_cache path res in
             let env = {env with symbols_cache = symbols_cache_} in
             env, ServerHighlightRefs.go_from_file (path, line, column) env
           end
@@ -182,17 +151,18 @@ let handle : type a. genv -> env -> a t -> env * a =
           env, ServerHighlightRefs.go (content, line, column) env.tcopt
         end
     | IDE_IDENTIFY_FUNCTION (path, {line; column}) ->
+        let relative_path = Relative_path.(concat Root path) in
         let path = Relative_path.path_of_prefix Relative_path.Root ^ path in
-        begin match SMap.exists (fun p _ -> p = path) env.edited_files with
+        begin match Relative_path.Map.mem env.edited_files relative_path with
         | true ->
-          begin match SMap.exists (fun p _ -> p = path) env.symbols_cache with
+          begin match SMap.exists env.symbols_cache (fun p _ -> p = path) with
           | true ->
             env, ServerIdentifyFunction.go_from_file (path, line, column) env
           | false ->
-            let content = File_content.get_content @@ SMap.find_unsafe path
-              env.edited_files in
+            let content = File_content.get_content @@
+              Relative_path.Map.find_unsafe env.edited_files relative_path in
             let res = ServerIdentifyFunction.get_full_occurrence_pair content in
-            let symbols_cache_ = SMap.add path res env.symbols_cache in
+            let symbols_cache_ = SMap.add env.symbols_cache path res in
             let env = {env with symbols_cache = symbols_cache_} in
             env, ServerIdentifyFunction.go_from_file (path, line, column) env
           end
@@ -202,18 +172,22 @@ let handle : type a. genv -> env -> a t -> env * a =
         end
     | DISCONNECT ->
         let new_env = {env with
-        persistent_client_fd = None;
-        edited_files = SMap.empty;
-        diag_subscribe = Diagnostic_subscription.empty;
+        persistent_client = None;
+        edited_files = Relative_path.Map.empty;
+        diag_subscribe = None;
         symbols_cache = SMap.empty} in
         new_env, ()
     | SUBSCRIBE_DIAGNOSTIC id ->
-        let new_env =
-          {env with diag_subscribe = Diagnostic_subscription.of_id id} in
+        let new_env = { env with
+          diag_subscribe = Some (Diagnostic_subscription.of_id id)
+        } in
         new_env, ()
     | UNSUBSCRIBE_DIAGNOSTIC id ->
-        let new_env = {env with diag_subscribe =
-            Diagnostic_subscription.unsubscribe env.diag_subscribe id} in
+        let diag_subscribe = match env.diag_subscribe with
+          | Some x when Diagnostic_subscription.get_id x = id -> None
+          | x -> x
+        in
+        let new_env = { env with diag_subscribe } in
         new_env, ()
 
 let to_string : type a. a t -> _ = function
diff --git a/hphp/hack/src/server/serverSearch.ml b/hphp/hack/src/server/serverSearch.ml
index d449c05..8f891a6 100644
--- a/hphp/hack/src/server/serverSearch.ml
+++ b/hphp/hack/src/server/serverSearch.ml
@@ -12,9 +12,6 @@ open Core
 module SS = HackSearchService
 module SUtils = SearchUtils
 
-type result =
-  (Pos.absolute, HackSearchService.search_result_type) SearchUtils.term list
-
 let scope_string_from_type result_type =
   match result_type with
   | SS.Method (_, scope)
diff --git a/hphp/hack/src/server/serverTypeCheck.ml b/hphp/hack/src/server/serverTypeCheck.ml
index 00df60a..a3ef962 100644
--- a/hphp/hack/src/server/serverTypeCheck.ml
+++ b/hphp/hack/src/server/serverTypeCheck.ml
@@ -108,7 +108,7 @@ let add_old_decls old_files_info fast =
 let reparse_infos files_info fast =
   Relative_path.Map.fold fast ~f:begin fun x _y acc ->
     try
-      let info = Relative_path.Map.find_unsafe x files_info in
+      let info = Relative_path.Map.find_unsafe files_info x in
       if info.FileInfo.consider_names_just_for_autoload then acc else
       Relative_path.Map.add acc ~key:x ~data:info
     with Not_found -> acc
@@ -144,28 +144,29 @@ let remove_decls env fast_parsed =
 (*****************************************************************************)
 
 let remove_failed fast failed =
-  Relative_path.Set.fold failed ~init:fast ~f:Relative_path.Map.remove
+  Relative_path.Set.fold failed ~init:fast
+    ~f:(fun x m -> Relative_path.Map.remove m x)
 
 (*****************************************************************************)
 (* Parses the set of modified files *)
 (*****************************************************************************)
 
 let parsing genv env =
-  let files_map = SSet.fold env.files_to_check ~init:SMap.empty
-    ~f:(fun path map ->
-      let content = File_content.get_content @@ SMap.find_unsafe path
-        env.edited_files in
-      SMap.add map path content) in
-  let to_check = SSet.fold env.files_to_check ~init:env.failed_parsing
-    ~f:(fun path set ->
-      let fn = Relative_path.create Relative_path.Root path in
-      Relative_path.Set.add set fn) in
-  Parser_heap.ParserHeap.remove_batch env.failed_parsing;
+  let files_map = Relative_path.Map.filter env.edited_files
+    (fun path _ -> Relative_path.Set.mem env.files_to_check path) in
+
+  let to_check =
+    Relative_path.Set.union env.files_to_check env.failed_parsing in
+
+  let disk_files = Relative_path.Set.filter env.failed_parsing
+    (fun x -> not @@ Relative_path.Map.mem env.edited_files x) in
+
+  Parser_heap.ParserHeap.remove_batch disk_files;
   Fixmes.HH_FIXMES.remove_batch to_check;
   HackSearchService.MasterApi.clear_shared_memory to_check;
   SharedMem.collect `gentle;
   let get_next = MultiWorker.next
-   genv.workers (Relative_path.Set.elements env.failed_parsing) in
+    genv.workers (Relative_path.Set.elements disk_files) in
   Parsing_service.go genv.workers files_map ~get_next
 
 (*****************************************************************************)
@@ -211,25 +212,14 @@ let hook_after_parsing = ref None
 
 let type_check genv env =
 
-  (* PREPARE FOR PARSING *)
-  let failed_parsing_ide, failed_parsing_ = Relative_path.Set.partition
-    (fun fn -> let path = Relative_path.to_absolute fn in
-      SMap.exists (fun p _ -> p = path) env.edited_files) env.failed_parsing in
-  let files_to_check_ = Relative_path.Set.fold failed_parsing_ide
-    ~init:SSet.empty ~f:(fun fn set ->
-      SSet.add set (Relative_path.to_absolute fn)) in
-  let check_now = SSet.filter files_to_check_ (fun s -> not @@
-      File_content.being_edited @@ SMap.find_unsafe s env.edited_files) in
-  let env = {env with failed_parsing = failed_parsing_;
-    files_to_check = check_now} in
-  let reparse_count = Relative_path.Set.cardinal env.failed_parsing +
-  SSet.cardinal env.files_to_check in
+  let reparse_count = Relative_path.Set.cardinal env.failed_parsing in
   Printf.eprintf "******************************************\n";
   Hh_logger.log "Files to recompute: %d" reparse_count;
 
   (* RESET HIGHLIGHTS CACHE FOR RECHECKED IDE FILES *)
-  let symbols_cache = SSet.fold env.files_to_check ~init:env.symbols_cache
-    ~f:(fun path map -> SMap.remove path map) in
+  let symbols_cache = Relative_path.Set.fold env.files_to_check
+    ~init:env.symbols_cache
+    ~f:(fun path map -> SMap.remove map (Relative_path.to_absolute path)) in
 
   (* PARSING *)
   let start_t = Unix.gettimeofday () in
@@ -242,14 +232,13 @@ let type_check genv env =
 
   (* UPDATE FILE INFO *)
   let old_env = env in
-  let updates = old_env.failed_parsing in
   let files_info = update_file_info env fast_parsed in
   HackEventLogger.updating_deps_end t;
   let t = Hh_logger.log_duration "Updating deps" t in
 
   (* BUILDING AUTOLOADMAP *)
   Option.iter !hook_after_parsing begin fun f ->
-    f genv old_env { env with files_info } updates
+    f genv { env with files_info }
   end;
   HackEventLogger.parsing_hook_end t;
   let t = Hh_logger.log_duration "Parsing Hook" t in
@@ -335,9 +324,10 @@ let type_check genv env =
     failed_parsing = Relative_path.Set.union failed_naming failed_parsing;
     failed_decl = Relative_path.Set.union failed_decl lazy_decl_failed;
     failed_check = failed_check;
-    persistent_client_fd = old_env.persistent_client_fd;
+    persistent_client = old_env.persistent_client;
+    last_command_time = old_env.last_command_time;
     edited_files = old_env.edited_files;
-    files_to_check = SSet.empty;
+    files_to_check = Relative_path.Set.empty;
     diag_subscribe = old_env.diag_subscribe;
     symbols_cache;
   } in
diff --git a/hphp/hack/src/server/serverTypeCheck.mli b/hphp/hack/src/server/serverTypeCheck.mli
index 3454a12..b5edf8c 100644
--- a/hphp/hack/src/server/serverTypeCheck.mli
+++ b/hphp/hack/src/server/serverTypeCheck.mli
@@ -13,8 +13,8 @@ val type_check: ServerEnv.genv -> ServerEnv.env -> ServerEnv.env * int
 (* just add also some debugging information on stdout *)
 val check: ServerEnv.genv -> ServerEnv.env -> ServerEnv.env * int
 
-val hook_after_parsing: (ServerEnv.genv -> (* old *) ServerEnv.env ->
-    (* new *) ServerEnv.env -> Relative_path.Set.t -> unit) option ref
+val hook_after_parsing: (ServerEnv.genv ->
+    (* new *) ServerEnv.env -> unit) option ref
 
 (****************************************************************************)
 (* Debugging: Declared here to stop ocamlc yelling at us for unused defs *)
diff --git a/hphp/hack/src/server/serverUtils.ml b/hphp/hack/src/server/serverUtils.ml
index 562feb0..1a11490 100644
--- a/hphp/hack/src/server/serverUtils.ml
+++ b/hphp/hack/src/server/serverUtils.ml
@@ -24,6 +24,9 @@ type file_input =
 let hh_monitor_config root = ServerMonitorUtils.({
   lock_file = ServerFiles.lock_file root;
   socket_file = ServerFiles.socket_file root;
+  server_log_file = ServerFiles.log_link root;
+  monitor_log_file = ServerFiles.monitor_log_link root;
+  load_script_log_file = ServerFiles.load_log root;
 })
 
 let shut_down_server root =
diff --git a/hphp/hack/src/server/symbolInfoService.ml b/hphp/hack/src/server/symbolInfoService.ml
index 695a0af..9e20c82 100644
--- a/hphp/hack/src/server/symbolInfoService.ml
+++ b/hphp/hack/src/server/symbolInfoService.ml
@@ -9,14 +9,10 @@
  *)
 
 open Core
+open SymbolInfoServiceTypes
 
 (* This module dumps all the symbol info(like fun-calls) in input files *)
 
-type result = {
-  fun_calls: SymbolFunCallService.result list;
-  symbol_types: SymbolTypeService.result list;
-}
-
 let recheck_naming filename_l =
   List.iter filename_l begin fun file ->
     match Parser_heap.ParserHeap.get file with
diff --git a/hphp/hack/src/server/symbolInfoServiceTypes.ml b/hphp/hack/src/server/symbolInfoServiceTypes.ml
new file mode 100644
index 0000000..ce3e51a
--- /dev/null
+++ b/hphp/hack/src/server/symbolInfoServiceTypes.ml
@@ -0,0 +1,14 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+ type result = {
+  fun_calls: SymbolFunCallService.result list;
+  symbol_types: SymbolTypeService.result list;
+}
diff --git a/hphp/hack/src/server/symbolTypeService.ml b/hphp/hack/src/server/symbolTypeService.ml
index c04c939..e8c807e 100644
--- a/hphp/hack/src/server/symbolTypeService.ml
+++ b/hphp/hack/src/server/symbolTypeService.ml
@@ -91,7 +91,7 @@ let generate_types lvar_map type_map =
     let ident = Pos.Map.find_unsafe lvar_pos lvar_map in
     let types_in_line = SymbolUtils.LineMap.get key line_map in
     let lvar_rekey_map = Relative_path.Map.find_unsafe
-      (Pos.filename lvar_pos) file_lvar_rekeying_map in
+      file_lvar_rekeying_map (Pos.filename lvar_pos) in
     let lvar_type = match types_in_line with
     | Some types_list ->
         find_match_pos_in_list lvar_pos types_list
diff --git a/hphp/hack/src/server/testClientProvider.ml b/hphp/hack/src/server/testClientProvider.ml
new file mode 100644
index 0000000..a53c67f
--- /dev/null
+++ b/hphp/hack/src/server/testClientProvider.ml
@@ -0,0 +1,132 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open ServerCommandTypes
+
+module type RefsType = sig
+
+  val clear: unit -> unit
+
+  val set_new_client_type: connection_type option -> unit
+
+  val set_client_request: 'a ServerCommandTypes.t option -> unit
+  val set_client_response: 'a option -> unit
+
+  val set_persistent_client_request: 'a ServerCommandTypes.t option -> unit
+  val set_persistent_client_response: 'a option  -> unit
+  val set_push_message: ServerCommandTypes.push option -> unit
+
+  val get_new_client_type: unit -> connection_type option
+
+  val get_client_request: unit -> 'a ServerCommandTypes.t option
+  val get_client_response: unit -> 'a option
+
+  val get_persistent_client_request: unit -> 'b
+  val get_persistent_client_response: unit -> 'a option
+  val get_push_message: unit -> ServerCommandTypes.push option
+end
+
+module Refs : RefsType = struct
+
+  let new_client_type = ref None
+
+  (* Those references are used for mocking the results of Marshal.from_channel
+   * function, which is untypeable. Hence, Obj.magic *)
+  let client_request = Obj.magic (ref None)
+  let client_response = Obj.magic (ref None)
+  let persistent_client_request = Obj.magic (ref None)
+  let persistent_client_response = Obj.magic (ref None)
+
+  let push_message = ref None
+
+  let set_new_client_type x = new_client_type := x
+  let set_client_request x = client_request := x
+  let set_client_response x = client_response := x
+  let set_persistent_client_request x = persistent_client_request := x
+  let set_persistent_client_response x = persistent_client_response := x
+  let set_push_message x = push_message := x
+
+  let get_new_client_type () = !new_client_type
+  let get_client_response () = !client_response
+  let get_client_request () = !client_request
+  let get_persistent_client_request () = !persistent_client_request
+  let get_persistent_client_response () = !persistent_client_response
+  let get_push_message () = !push_message
+
+  let clear () =
+    set_new_client_type None;
+    set_client_request None;
+    set_client_response None;
+    set_persistent_client_request None;
+    set_persistent_client_response None;
+    set_persistent_client_response None;
+    set_push_message None;
+end
+
+let clear = Refs.clear
+
+let mock_new_client_type x = Refs.set_new_client_type (Some x)
+
+let mock_client_request x = Refs.set_client_request (Some x)
+
+let mock_persistent_client_request x =
+  Refs.set_persistent_client_request (Some x)
+
+let get_mocked_new_client_type () = Refs.get_new_client_type ()
+
+let get_mocked_client_request = function
+  | Non_persistent -> Refs.get_client_request ()
+  | Persistent-> Refs.get_persistent_client_request ()
+
+let record_client_response x = function
+  | Non_persistent -> Refs.set_client_response (Some x)
+  | Persistent ->  Refs.set_persistent_client_response (Some x)
+
+let get_client_response = function
+  | Non_persistent -> Refs.get_client_response ()
+  | Persistent -> Refs.get_persistent_client_response ()
+
+let record_push_message x = Refs.set_push_message (Some x)
+
+let get_push_message = Refs.get_push_message
+
+type t = unit
+type client = connection_type
+
+let provider_from_file_descriptor _ = ()
+let provider_for_test _ = ()
+
+let sleep_and_check _ _ =
+  Option.is_some (get_mocked_new_client_type ()),
+  Option.is_some (get_mocked_client_request Persistent)
+
+let not_implemented () = failwith "not implemented"
+
+let accept_client _ = Non_persistent
+
+let say_hello _ = not_implemented ()
+
+let read_connection_type _ = Utils.unsafe_opt (get_mocked_new_client_type ())
+
+let send_response_to_client c x = record_client_response x c
+
+let send_push_message_to_client _ x = record_push_message x
+
+let read_client_msg c = Rpc (Utils.unsafe_opt (get_mocked_client_request c))
+
+let get_channels _ = not_implemented ()
+
+let is_persistent = function
+  | Persistent -> true
+  | Non_persistent -> false
+
+let make_persistent _ = ServerCommandTypes.Persistent
+
+let shutdown_client _ = ()
diff --git a/hphp/hack/src/stubs/ai.ml b/hphp/hack/src/stubs/ai.ml
index 90bafe8..0f52d8d 100644
--- a/hphp/hack/src/stubs/ai.ml
+++ b/hphp/hack/src/stubs/ai.ml
@@ -61,6 +61,7 @@ module ServerFindRefs = struct
     | Class of string
     | Member of string * member
     | Function of string
+    | GConst of string
 
   let go _  _ _ = []
 end
@@ -76,6 +77,7 @@ module TraceService = struct
     | Class of string
     | Member of string * member
     | Function of string
+    | GConst of string
 
   let go _ _ _ _ = ""
 end
diff --git a/hphp/hack/src/stubs/buildMain.ml b/hphp/hack/src/stubs/buildMain.ml
index 727d3d8..b05ddcb 100644
--- a/hphp/hack/src/stubs/buildMain.ml
+++ b/hphp/hack/src/stubs/buildMain.ml
@@ -8,6 +8,6 @@
  *
  *)
 
-let go _ _ _ _ = Some (fun _ _ _ _ -> ())
+let go _ _ _ _ = Some (fun _ _ -> ())
 let incremental_update _ _ _ _ = ()
 let get_live_targets _ = []
diff --git a/hphp/hack/src/stubs/hackEventLogger.ml b/hphp/hack/src/stubs/hackEventLogger.ml
index 4f54f09..88221f4 100644
--- a/hphp/hack/src/stubs/hackEventLogger.ml
+++ b/hphp/hack/src/stubs/hackEventLogger.ml
@@ -9,8 +9,9 @@
  *)
 
 let set_use_watchman _ = ()
-let bad_exit _ _ ~is_oom:_ = ()
-let init _ _ = ()
+let set_lazy_decl _ = ()
+let bad_exit _ _ _ ~is_oom:_ = ()
+let init _ _ _ = ()
 let init_monitor _ _ = ()
 let init_end _ = ()
 let init_really_end _ = ()
diff --git a/hphp/hack/src/typed_ast/typed_ast.ml b/hphp/hack/src/typed_ast/typed_ast.ml
new file mode 100644
index 0000000..f5cc68e
--- /dev/null
+++ b/hphp/hack/src/typed_ast/typed_ast.ml
@@ -0,0 +1,27 @@
+let rec save_ty pos_ty_map ty pos t_env =
+  let ty = to_tast_ty t_env ty in
+  pos_ty_map := Pos.Map.add pos ty !pos_ty_map
+
+and to_tast_ty t_env ty = match ty with
+    | _, Typing_defs.Tprim n_prim -> Typed_ast_defs.TPrim n_prim
+    | _, Typing_defs.Tclass (name, tyl) ->
+      Typed_ast_defs.TClass (name, to_tast_tyl t_env tyl)
+    | _, Typing_defs.Toption ty ->
+      let ty = to_tast_ty t_env ty in
+      (match ty with
+      | Typed_ast_defs.TAny -> Typed_ast_defs.TNull
+      | _ -> Typed_ast_defs.TOption ty)
+    | _, Typing_defs.Tunresolved tyl ->
+      Typed_ast_defs.TUnion (to_tast_tyl t_env tyl)
+    (** Locl types in the map should be expanded already. *)
+    | _, Typing_defs.Tvar _ ->
+      (** We discard the env from expanding. I don't think we need it since
+       * it's only being modified as a perf optimization - shortening tvar
+       * expansion paths. *)
+      let _, ty = Typing_env.expand_type t_env ty in
+      to_tast_ty t_env ty
+    | _, Typing_defs.Tany -> Typed_ast_defs.TAny
+    | _, _ -> Typed_ast_defs.TNotImpl
+
+and to_tast_tyl t_env tyl =
+  List.map (to_tast_ty t_env) tyl
diff --git a/hphp/hack/src/typed_ast/typed_ast_defs.ml b/hphp/hack/src/typed_ast/typed_ast_defs.ml
new file mode 100644
index 0000000..44e383b
--- /dev/null
+++ b/hphp/hack/src/typed_ast/typed_ast_defs.ml
@@ -0,0 +1,14 @@
+(** Like Typing_defs.locl ty, but without TVar, and with explicit null type. *)
+type tast_ty_ =
+  (** This type not yet implemented in Typed AST. *)
+  | TNotImpl
+  | TAny
+  (** During typechecking, the null value gives rise to an unresolved optional.
+   * But we know an expression whose unresolved type hasn't been refined
+   * can only have a null value - so we have a singleton type for the
+   * null value. *)
+  | TNull
+  | TClass of Nast.sid * tast_ty_ list
+  | TUnion of tast_ty_ list
+  | TOption of tast_ty_
+  | TPrim of Nast.tprim
diff --git a/hphp/hack/src/typed_ast/typed_ast_printer.ml b/hphp/hack/src/typed_ast/typed_ast_printer.ml
new file mode 100644
index 0000000..5a63680
--- /dev/null
+++ b/hphp/hack/src/typed_ast/typed_ast_printer.ml
@@ -0,0 +1,174 @@
+open Core
+open Nast
+open Typed_ast_defs
+
+(** Like Haskell's ">=>". Function composition in reverse.
+ *
+ * This symbol is borrowed from Ocaml Batteries Included, which
+ * chooses % as the first character because of Ocaml's infix precedence
+ * rules, which allows this to play well with pipes. *)
+let ( %> ) f g = fun x -> g (f x)
+
+type string_builder = {
+  acc : string;
+  indent : int;
+  (** True if whitespace must be inserted on the next "append" *)
+  needs_whitespace : bool;
+  ty_map : Typed_ast_defs.tast_ty_ Pos.Map.t;
+}
+
+let rec append str builder =
+  if builder.needs_whitespace then
+    { builder with acc = builder.acc ^ " " ^ str}
+  else
+    { builder with acc = builder.acc ^ str; needs_whitespace = true }
+
+(** Like append but ignores needs_whitespace. *)
+and append_raw str builder =
+  { builder with acc = builder.acc ^ str }
+
+(** Ensures the next append does not add whitespace before it. *)
+and no_whitespace builder =
+  { builder with needs_whitespace = false }
+
+and repeat n c builder =
+  { builder with acc = builder.acc ^ (String.make n c) }
+
+and newline builder =
+  { builder with acc = builder.acc ^ "\n"; needs_whitespace = false }
+  |> repeat builder.indent ' '
+
+and with_indent f builder =
+  let old_indent = builder.indent in
+  let builder = f { builder with indent = builder.indent + 1 } in
+  { builder with indent = old_indent }
+
+and paren f =
+  with_indent ((append_raw "(") %> no_whitespace %> f %> (append_raw ")"))
+
+(** List.fold_left has the wrong param order in the ~f to do
+  * easy composition and piping. Here we flip it. *)
+and fold f xs builder =
+  List.fold_left xs ~init:builder ~f:begin fun builder x ->
+    f x builder
+  end
+
+let t_prim n_ty = append (match n_ty with
+  | Nast.Tvoid -> "Tvoid"
+  | Nast.Tint -> "Tint"
+  | Nast.Tbool -> "Tbool"
+  | Nast.Tfloat -> "Tbool"
+  | Nast.Tstring -> "Tstring"
+  | Nast.Tresource -> "Tresource"
+  | Nast.Tnum -> "Tnum"
+  | Nast.Tarraykey -> "Tarraykey"
+  | Nast.Tnoreturn -> "Tnoreturn"
+  )
+
+let rec ty p builder = builder |> match (Pos.Map.get p builder.ty_map) with
+  | None -> append "TAny"
+  | Some t -> ty_ t
+
+and ty_ = function
+  | TNotImpl -> append "TNotImpl"
+  | TAny -> append "TAny"
+  | TNull -> append "TNull"
+  | TOption ty -> paren (
+    append "TOption"
+    %> ty_ ty
+  )
+  | TClass ((_, name), tyl) -> paren (
+    append "TClass"
+    %> append name
+    %> append "<"
+    %> (fold ty_ tyl)
+    %> append ">"
+  )
+  | TUnion tyl -> paren (
+    append "TUnion"
+    %> (fold ty_ tyl)
+  )
+  | TPrim n_ty -> paren (
+    t_prim n_ty
+    %> append "TPrim"
+  )
+
+let rec expr (p, n_e) builder = builder |>
+  paren ((ty p) %> (append "expr")
+    %> (match n_e with
+      | Id (_, id) ->
+          (append "Id")
+          %> (append id)
+      | Lvar (_, id) ->
+          (append "Lvar")
+          %> (append (Local_id.to_string id))
+      | Int _ ->
+          (append "Int")
+      | Binop (_, e1, e2) ->
+          (append "binop")
+          %> expr e1
+          %> expr e2
+      | Call (_call_type, n_fun, n_args, n_unpacked_args) ->
+          (append "Call")
+          %> expr n_fun
+          %> fold expr n_args
+          %> fold expr n_unpacked_args
+      | Fun_id (_p, id) ->
+          (append "Fun_id")
+          %> (append id)
+      | Method_id (e, (_p, id)) ->
+          (append "Method_id")
+          %> (append id)
+          %> expr e
+      | _ -> (append "other")))
+
+let rec stmt t_stmt builder = builder |>
+  paren ((append "stmt")
+    %> begin match t_stmt with
+      | Expr t_expr -> newline %> expr t_expr
+      | If (e, b1, b2) -> paren (
+        append "If"
+          %> newline
+          %> expr e
+          %> newline
+          %> block b1
+          %> newline
+          %> block b2
+        )
+      | While (e, b) -> paren (
+        append "While"
+          %> newline
+          %> expr e
+          %> newline
+          %> block b
+        )
+      | _ -> append "other stmt"
+    end)
+  %> newline
+
+(** Full point-free-form doesn't work with recursive lets. *)
+and block statements =
+  fold stmt statements
+
+let rec print_string ty_map ((n_funs : Nast.fun_ list), _, _, _) =
+  let result = List.fold_left n_funs
+    ~init:{acc = ""; indent = 0; needs_whitespace = false; ty_map = ty_map}
+    ~f:begin fun builder n_fun ->
+      builder |> fun_ n_fun |> newline
+    end
+  in
+  result.acc
+
+and fun_ {Nast.f_name; f_body; _} builder =
+  builder |> (paren ( (append "fun")
+    %> newline
+    %> (paren (append ("name: " ^ (snd (f_name)))))
+    %> newline
+    %> func_body f_body))
+
+and func_body f_body builder = builder |>
+  (paren ( (append "body:")
+    %> newline
+    %> (match f_body with
+      | NamedBody named_body -> block named_body.fnb_nast
+      | UnnamedBody _ -> assert false)))
diff --git a/hphp/hack/src/typing/coverage_level.ml b/hphp/hack/src/typing/coverage_level.ml
index 85a87a3..cda2588 100644
--- a/hphp/hack/src/typing/coverage_level.ml
+++ b/hphp/hack/src/typing/coverage_level.ml
@@ -26,6 +26,8 @@ type level =
                  concrete type parameters *)
   | Checked   (* Completely checked code *)
 
+type result = ((int * int) * level) list
+
 let string_of_level = function
   | Checked   -> "checked"
   | Partial   -> "partial"
@@ -139,7 +141,8 @@ let incr_reason_stats r p reason_stats =
     | Rnullsafe_op _ -> "Rnullsafe_op"
     | Rtconst_no_cstr _ -> "Rtconst_no_cstr"
     | Rused_as_map _ -> "Rused_as_map"
-    | Rused_as_shape _ -> "Rused_as_shape" in
+    | Rused_as_shape _ -> "Rused_as_shape"
+    | Rpredicated _ -> "Rpredicated" in
   let pos_stats_map = match SMap.get string_key reason_stats with
     | Some x -> x
     | None -> Pos.Map.empty in
diff --git a/hphp/hack/src/typing/typing.ml b/hphp/hack/src/typing/typing.ml
index e6a9bb4..e0bb419 100644
--- a/hphp/hack/src/typing/typing.ml
+++ b/hphp/hack/src/typing/typing.ml
@@ -3650,9 +3650,18 @@ and condition env tparamet =
       let env = condition env false e1 in
       let env = condition env false e2 in
       env
-  | _, Call (Cnormal, (_, Id (_, f)), [lv], [])
+  | _, Call (Cnormal, (p, Id (_, f)), [lv], [])
     when tparamet && f = SN.StdlibFunctions.is_array ->
-      is_array env lv
+      is_array env `PHPArray p f lv
+  | _, Call (Cnormal, (p, Id (_, f)), [lv], [])
+    when tparamet && f = SN.StdlibFunctions.is_vec ->
+      is_array env `HackVec p f lv
+  | _, Call (Cnormal, (p, Id (_, f)), [lv], [])
+    when tparamet && f = SN.StdlibFunctions.is_dict ->
+      is_array env `HackDict p f lv
+  | _, Call (Cnormal, (p, Id (_, f)), [lv], [])
+    when tparamet && f = SN.StdlibFunctions.is_keyset ->
+      is_array env `HackKeyset p f lv
   | _, Call (Cnormal, (_, Id (_, f)), [lv], [])
     when tparamet && f = SN.StdlibFunctions.is_int ->
       is_type env lv Tint
@@ -3792,15 +3801,29 @@ and is_type env e tprim =
       Env.set_local env x (Reason.Rwitness p, Tprim tprim)
     | _ -> env
 
-and is_array env = function
-  | p, Class_get (cname, (_, member_name)) ->
+and is_array env ty p pf (_, lv) =
+  let r = Reason.Rpredicated (p, pf) in
+  let tarrkey () = Env.fresh_abstract_type ~constr:(r, Tprim Tarraykey) r in
+  let tfresh () = Env.fresh_abstract_type r in
+  let ty =
+    match ty with
+    | `HackDict ->
+      Tclass ((Pos.none, SN.Collections.cDict), [tarrkey (); tfresh ()])
+    | `HackVec ->
+      Tclass ((Pos.none, SN.Collections.cVec), [tfresh ()])
+    | `HackKeyset ->
+      Tclass ((Pos.none, SN.Collections.cKeyset), [tarrkey ()])
+    | `PHPArray ->
+      Tarraykind AKany in
+  match lv with
+  | Class_get (cname, (_, member_name)) ->
       let env, local = Env.FakeMembers.make_static p env cname member_name in
-      Env.set_local env local (Reason.Rwitness p, Tarraykind AKany)
-  | p, Obj_get ((_, This | _, Lvar _ as obj), (_, Id (_, member_name)), _) ->
+      Env.set_local env local (r, ty)
+  | Obj_get ((_, This | _, Lvar _ as obj), (_, Id (_, member_name)), _) ->
       let env, local = Env.FakeMembers.make p env obj member_name in
-      Env.set_local env local (Reason.Rwitness p, Tarraykind AKany)
-  | _, Lvar (p, x) ->
-      Env.set_local env x (Reason.Rwitness p, Tarraykind AKany)
+      Env.set_local env local (r, ty)
+  | Lvar (_, x) ->
+      Env.set_local env x (r, ty)
   | _ -> env
 
 and string2 env idl =
@@ -3957,6 +3980,7 @@ and class_def_ env c tc =
       Errors.internal_error pc "The parser should not parse final on enums"
     | Ast.Cnormal -> ()
   end;
+  SMap.iter (check_static_method tc.tc_methods) tc.tc_smethods;
   List.iter impl (class_implements_type env c);
   List.iter c.c_vars (class_var_def env ~is_static:false c);
   List.iter c.c_methods (method_def env);
@@ -3969,6 +3993,19 @@ and class_def_ env c tc =
   List.iter c.c_static_methods (method_def env);
   Typing_hooks.dispatch_exit_class_def_hook c tc
 
+and check_static_method obj method_name static_method =
+  if SMap.mem method_name obj
+  then begin
+    let lazy (static_method_reason, _) = static_method.ce_type in
+    let dyn_method = SMap.find_unsafe method_name obj in
+    let lazy (dyn_method_reason, _) = dyn_method.ce_type in
+    Errors.static_dynamic
+      (Reason.to_pos static_method_reason)
+      (Reason.to_pos dyn_method_reason)
+      method_name
+  end
+  else ()
+
 and check_extend_abstract_meth ~is_final p smap =
   SMap.iter begin fun x ce ->
     match ce.ce_type with
@@ -4160,6 +4197,24 @@ and typedef_def typedef =
     ignore (check_shape_keys_validity env pos (ShapeMap.keys fdm))
   | _ -> ()
 
+and gconst_def cst =
+  Typing_hooks.dispatch_global_const_hook cst.cst_name;
+  match cst.cst_value with
+  | None -> ()
+  | Some value ->
+    let filename = Pos.filename (fst cst.cst_name) in
+    let dep = Typing_deps.Dep.GConst (snd cst.cst_name) in
+    let env =
+      Typing_env.empty TypecheckerOptions.default filename (Some dep) in
+    let env = Typing_env.set_mode env cst.cst_mode in
+    let env, value_type = expr env value in
+    match cst.cst_type with
+    | Some hint ->
+      let ty = TI.instantiable_hint env hint in
+      let env, dty = Phase.localize_with_self env ty in
+      ignore @@ Typing_utils.sub_type env value_type dty
+    | None -> ()
+
 (* Calls the method of a class, but allows the f callback to override the
  * return value type *)
 and overload_function p env class_id method_id el uel f =
diff --git a/hphp/hack/src/typing/typing.mli b/hphp/hack/src/typing/typing.mli
index 353ac2e..4f5151b 100644
--- a/hphp/hack/src/typing/typing.mli
+++ b/hphp/hack/src/typing/typing.mli
@@ -20,6 +20,8 @@ val class_def:
   TypecheckerOptions.t -> Nast.class_ -> unit
 val typedef_def:
   Nast.typedef -> unit
+val gconst_def:
+  Nast.gconst -> unit
 
 val expr:
   Typing_env.env -> Nast.expr ->
diff --git a/hphp/hack/src/typing/typing_dependent_type.ml b/hphp/hack/src/typing/typing_dependent_type.ml
index 7a11359..03364ee 100644
--- a/hphp/hack/src/typing/typing_dependent_type.ml
+++ b/hphp/hack/src/typing/typing_dependent_type.ml
@@ -14,6 +14,7 @@ open Typing_defs
 module ExprDepTy = struct
   module N = Nast
   module Env = Typing_env
+  module TUtils = Typing_utils
 
   let to_string dt = AbstractKind.to_string (AKdependent dt)
 
@@ -111,9 +112,14 @@ module ExprDepTy = struct
         List.exists tyl (should_apply env)
     | Tclass ((_, x), _) ->
         let class_ = Env.get_class env x in
+        (* If a class is both final and variant, we must treat it as non-final
+         * since we can't statically guarantee what the runtime type
+         * will be.
+         *)
         Option.value_map class_
           ~default:false
-          ~f:(fun {tc_final; _} -> not tc_final)
+          ~f:(fun class_ty ->
+              not (TUtils.class_is_final_and_not_contravariant class_ty))
     | Tanon _ | Tobject | Tmixed | Tprim _ | Tshape _ | Ttuple _
     | Tarraykind _ | Tfun _ | Tabstract (_, None) | Tany ->
         false
diff --git a/hphp/hack/src/typing/typing_enum.ml b/hphp/hack/src/typing/typing_enum.ml
index 82f4fdd..ec05e24 100644
--- a/hphp/hack/src/typing/typing_enum.ml
+++ b/hphp/hack/src/typing/typing_enum.ml
@@ -150,11 +150,11 @@ let check_enum_exhaustiveness pos tc caselist coming_from_unresolved =
     List.fold_left ~f:(get_constant tc) ~init:(SMap.empty, false) caselist in
   let consts = SMap.remove SN.Members.mClass tc.tc_consts in
   let all_cases_handled = SMap.cardinal seen = SMap.cardinal consts in
-  match (all_cases_handled, has_default && not coming_from_unresolved) with
-    | false, false ->
+  match (all_cases_handled, has_default, coming_from_unresolved) with
+    | false, false, _ ->
       let const_list = SMap.keys consts in
       let unhandled =
         List.filter const_list (function k -> not (SMap.mem k seen)) in
       Errors.enum_switch_nonexhaustive pos unhandled tc.tc_pos
-    | true, true -> Errors.enum_switch_redundant_default pos tc.tc_pos
+    | true, true, false -> Errors.enum_switch_redundant_default pos tc.tc_pos
     | _ -> ()
diff --git a/hphp/hack/src/typing/typing_env.ml b/hphp/hack/src/typing/typing_env.ml
index e4833a6..86c64dd 100644
--- a/hphp/hack/src/typing/typing_env.ml
+++ b/hphp/hack/src/typing/typing_env.ml
@@ -90,6 +90,10 @@ let fresh () =
 let fresh_type () =
   Reason.none, Tvar (Ident.tmp())
 
+let fresh_abstract_type ?constr r =
+  let name = Printf.sprintf "Tfresh%d" (fresh ()) in
+  r, Tabstract (AKgeneric name, constr)
+
 let add_subst env x x' =
   if x <> x'
   then { env with subst = IMap.add x x' env.subst }
diff --git a/hphp/hack/src/typing/typing_env.mli b/hphp/hack/src/typing/typing_env.mli
index 65650c9..caf09c6 100644
--- a/hphp/hack/src/typing/typing_env.mli
+++ b/hphp/hack/src/typing/typing_env.mli
@@ -49,6 +49,7 @@ and tfun = env -> env
 val fresh : unit -> int
 val fresh_type : unit -> locl ty
 val fresh_unresolved_type : env -> env * locl ty
+val fresh_abstract_type : ?constr: locl ty -> Reason.t -> locl ty
 val add_subst : env -> int -> int -> env
 val get_var : env -> int -> env * int
 val rename : env -> int -> int -> env
diff --git a/hphp/hack/src/typing/typing_extends.ml b/hphp/hack/src/typing/typing_extends.ml
index 3301657..a1da5e1 100644
--- a/hphp/hack/src/typing/typing_extends.ml
+++ b/hphp/hack/src/typing/typing_extends.ml
@@ -18,6 +18,7 @@ open Typing_defs
 open Typing_ops
 
 module Env = Typing_env
+module Dep = Typing_deps.Dep
 module TUtils = Typing_utils
 module Inst = Decl_instantiate
 module Phase = Typing_phase
@@ -64,7 +65,8 @@ let check_visibility parent_class_elt class_elt =
     Errors.visibility_extends vis pos parent_pos parent_vis
 
 (* Check that all the required members are implemented *)
-let check_members_implemented check_private parent_reason reason parent_members members =
+let check_members_implemented check_private parent_reason reason
+    (parent_members, members, _) =
   SMap.iter begin fun member_name class_elt ->
     match class_elt.ce_visibility with
       | Vprivate _ when not check_private -> ()
@@ -153,6 +155,7 @@ let check_override env ?(ignore_fun_return = false)
   if check_params then
     match parent_class_elt.ce_type, class_elt.ce_type with
     | lazy (r_parent, Tfun ft_parent), lazy (r_child, Tfun ft_child) ->
+      (* Add deps here when we override *)
       let subtype_funs = SubType.subtype_method ~check_return:(
           (not ignore_fun_return) &&
           (class_known || check_partially_known_method_returns)
@@ -179,12 +182,19 @@ let filter_privates members =
     else SMap.add name class_elt acc
   end members SMap.empty
 
-let check_members check_private env parent_class class_ parent_members members =
+let check_members check_private env (parent_class, psubst) (class_, subst)
+    (parent_members, members, dep) =
   let parent_members = if check_private then parent_members
     else filter_privates parent_members in
   SMap.iter begin fun member_name parent_class_elt ->
     match SMap.get member_name members with
-    | Some class_elt  ->
+    | Some class_elt ->
+      let parent_class_elt = Inst.instantiate_ce psubst parent_class_elt in
+      let class_elt = Inst.instantiate_ce subst class_elt in
+      if parent_class_elt.ce_origin <> class_elt.ce_origin then
+        Typing_deps.add_idep
+          (Dep.Class class_.tc_name)
+          (dep parent_class_elt.ce_origin member_name);
       check_override env parent_class class_ parent_class_elt class_elt
     | None -> ()
   end parent_members
@@ -196,17 +206,18 @@ let check_members check_private env parent_class class_ parent_members members =
 (*****************************************************************************)
 
 (* Instantiation basically applies the substitution *)
-let instantiate_members subst members =
-  SMap.map (Inst.instantiate_ce subst) members
-
 let instantiate_consts subst consts =
   SMap.map (Inst.instantiate_cc subst) consts
 
-let make_all_members class_ = [
-  class_.tc_props;
-  class_.tc_sprops;
-  class_.tc_methods;
-  class_.tc_smethods;
+let make_all_members ~child_class ~parent_class = [
+  parent_class.tc_props, child_class.tc_props,
+  (fun x y -> Dep.Prop (x, y));
+  parent_class.tc_sprops, child_class.tc_sprops,
+  (fun x y -> Dep.SProp (x, y));
+  parent_class.tc_methods, child_class.tc_methods,
+  (fun x y -> Dep.Method (x, y));
+  parent_class.tc_smethods, child_class.tc_smethods,
+  (fun x y -> Dep.SMethod (x, y));
 ]
 
 (* The phantom class element that represents the default constructor:
@@ -249,11 +260,19 @@ let check_constructors env parent_class class_ psubst subst =
       | Some parent_cstr, Some cstr ->
         let parent_cstr = Inst.instantiate_ce psubst parent_cstr in
         let cstr = Inst.instantiate_ce subst cstr in
+        if parent_cstr.ce_origin <> cstr.ce_origin then
+          Typing_deps.add_idep
+            (Dep.Class class_.tc_name)
+            (Dep.Cstr parent_cstr.ce_origin);
         check_override env ~ignore_fun_return:true parent_class class_ parent_cstr cstr
       | None, Some cstr when explicit_consistency ->
         let parent_cstr = default_constructor_ce parent_class in
         let parent_cstr = Inst.instantiate_ce psubst parent_cstr in
         let cstr = Inst.instantiate_ce subst cstr in
+        if parent_cstr.ce_origin <> cstr.ce_origin then
+          Typing_deps.add_idep
+            (Dep.Class class_.tc_name)
+            (Dep.Cstr parent_cstr.ce_origin);
         check_override env ~ignore_fun_return:true parent_class class_ parent_cstr cstr
       | None, _ -> ()
   ) else ()
@@ -356,17 +375,14 @@ let check_class_implements env parent_class class_ =
   let psubst = Inst.make_subst parent_class.tc_tparams parent_tparaml in
   let subst = Inst.make_subst class_.tc_tparams tparaml in
   check_consts env parent_class class_ psubst subst;
-  let pmemberl = make_all_members parent_class in
-  let memberl = make_all_members class_ in
+  let memberl = make_all_members ~parent_class ~child_class:class_ in
   check_constructors env parent_class class_ psubst subst;
-  let pmemberl = List.map pmemberl (instantiate_members psubst) in
-  let memberl = List.map memberl (instantiate_members subst) in
   let check_privates:bool = (parent_class.tc_kind = Ast.Ctrait) in
   if not fully_known then () else
-    List.iter2_exn pmemberl memberl
+    List.iter memberl
       (check_members_implemented check_privates parent_pos pos);
-  List.iter2_exn pmemberl memberl
-    (check_members check_privates env parent_class class_);
+  List.iter memberl
+    (check_members check_privates env (parent_class, psubst) (class_, subst));
   ()
 
 (*****************************************************************************)
diff --git a/hphp/hack/src/typing/typing_reason.ml b/hphp/hack/src/typing/typing_reason.ml
index 42e8a33..4a79800 100644
--- a/hphp/hack/src/typing/typing_reason.ml
+++ b/hphp/hack/src/typing/typing_reason.ml
@@ -68,6 +68,7 @@ type t =
   | Rtconst_no_cstr  of Nast.sid
   | Rused_as_map     of Pos.t
   | Rused_as_shape   of Pos.t
+  | Rpredicated      of Pos.t * string
 
 and expr_dep_type_reason =
   | ERexpr of int
@@ -184,6 +185,8 @@ let rec to_string prefix r =
   | Rused_as_map _ -> [(p, prefix ^ " because it is used as map here")]
   | Rused_as_shape _ ->
       [(p, prefix ^ " because it is used as shape-like array here")]
+  | Rpredicated (p, f) ->
+      [(p, prefix ^ " from the condition on the predicate " ^ f)]
 
 and to_pos = function
   | Rnone     -> Pos.none
@@ -239,6 +242,7 @@ and to_pos = function
   | Rtconst_no_cstr (p, _) -> p
   | Rused_as_map p -> p
   | Rused_as_shape p -> p
+  | Rpredicated (p, _) -> p
 
 (* This is a mapping from internal expression ids to a standardized int.
  * Used for outputting cleaner error messages to users
diff --git a/hphp/hack/src/typing/typing_suggest_service.ml b/hphp/hack/src/typing/typing_suggest_service.ml
index 514c424..717e9cb 100644
--- a/hphp/hack/src/typing/typing_suggest_service.ml
+++ b/hphp/hack/src/typing/typing_suggest_service.ml
@@ -20,7 +20,7 @@ module Env = Typing_env
 module SN = Naming_special_names
 
 let insert_resolved_result fn acc result =
-  let pl = try Relative_path.Map.find_unsafe fn acc with Not_found -> [] in
+  let pl = try Relative_path.Map.find_unsafe acc fn with Not_found -> [] in
   let pl = result :: pl in
   Relative_path.Map.add acc ~key:fn ~data:pl
 
@@ -182,7 +182,7 @@ let collate_types fast all_types =
     (* Discard patches from files we aren't concerned about. This can happen if
      * a file we do care about calls a function in a file we don't, causing us
      * to infer a parameter type in the target file. *)
-    if Relative_path.Map.mem fn fast
+    if Relative_path.Map.mem fast fn
     then Hashtbl.add tbl (fn, line, k) (env, ty);
   end;
   tbl
diff --git a/hphp/hack/src/typing/typing_unify.ml b/hphp/hack/src/typing/typing_unify.ml
index 9c675fd..405e6d5 100644
--- a/hphp/hack/src/typing/typing_unify.ml
+++ b/hphp/hack/src/typing/typing_unify.ml
@@ -208,11 +208,13 @@ and unify_ env r1 ty1 r2 ty2 =
       Some (_, Tclass ((_, x) as id, _) as ty)), _ ->
     let class_ = Env.get_class env x in
       (* For final class C, there is no difference between abstract<X> and X.
-       * The one exception is for new types, because it is considered a distinct
-       * type from X.
+       * Two exceptions are for new types, because they are considered a
+       * distinct type from X, and for variant classes, since we can't
+       * statically guarantee their runtime type.
        *)
       (match class_ with
-      | Some {tc_final = true; _} ->
+       | Some(class_ty)
+          when TUtils.class_is_final_and_not_contravariant class_ty ->
           let env, ty = unify env ty (r2, ty2) in
           env, snd ty
       | _ ->
diff --git a/hphp/hack/src/typing/typing_utils.ml b/hphp/hack/src/typing/typing_utils.ml
index bfb16bc..a793e03 100644
--- a/hphp/hack/src/typing/typing_utils.ml
+++ b/hphp/hack/src/typing/typing_utils.ml
@@ -361,6 +361,15 @@ let unwrap_class_type = function
 
 let try_unwrap_class_type x = Option.try_with (fun () -> unwrap_class_type x)
 
+let class_is_final_and_not_contravariant class_ty =
+  class_ty.tc_final &&
+    List.for_all
+      class_ty.tc_tparams
+      ~f:(begin function
+          (Ast.Invariant | Ast.Covariant), _, _ -> true
+          | _, _, _ -> false
+          end)
+
 (*****************************************************************************)
 (* Check if a type is not fully constrained *)
 (*****************************************************************************)
diff --git a/hphp/hack/src/typing/typing_variance.ml b/hphp/hack/src/typing/typing_variance.ml
index a461208..9ae46e4 100644
--- a/hphp/hack/src/typing/typing_variance.ml
+++ b/hphp/hack/src/typing/typing_variance.ml
@@ -310,6 +310,23 @@ let check_variance env tparam =
       let emsg = detailed_message "covariant (+)" pos2 stack2 in
       Errors.declared_contravariant pos1 pos2 emsg
 
+(******************************************************************************)
+(* Checks that a 'this' type is correctly used at a given contravariant       *)
+(* position in a final class.                                                 *)
+(******************************************************************************)
+let check_final_this_pos_variance env_variance rpos class_ty =
+  if class_ty.tc_final then
+    List.iter class_ty.tc_tparams
+      begin fun (typar_variance, id, _) ->
+        match env_variance, typar_variance with
+        | Vcontravariant(_), (Ast.Covariant | Ast.Contravariant)  ->
+           (Errors.contravariant_this
+             rpos
+             (Utils.strip_ns class_ty.tc_name)
+             (snd id))
+        | _ -> ()
+      end
+
 (*****************************************************************************)
 (* Returns the list of type parameter variance for a given class.
  * Performing that operation adds a dependency on the class, because if
@@ -325,7 +342,7 @@ let get_class_variance tcopt root (pos, class_name) =
       [Vcovariant [pos, Rtype_argument (Utils.strip_ns name), Pcovariant]]
   | _ ->
       let dep = Typing_deps.Dep.Class class_name in
-      Typing_deps.add_idep root dep;
+      Typing_deps.add_idep (fst root) dep;
       let tparams =
         if Env.is_typedef class_name
         then
@@ -344,7 +361,7 @@ let get_class_variance tcopt root (pos, class_name) =
 (*****************************************************************************)
 
 let rec class_ tcopt class_name class_type impl =
-  let root = Typing_deps.Dep.Class class_name in
+  let root = (Typing_deps.Dep.Class class_name, Some(class_type)) in
   let tparams = class_type.tc_tparams in
   let env = SMap.empty in
   let env = List.fold_left impl ~f:(type_ tcopt root Vboth) ~init:env in
@@ -366,7 +383,7 @@ let rec class_ tcopt class_name class_type impl =
 and typedef tcopt type_name =
   match TLazyHeap.get_typedef tcopt type_name with
   | Some {td_tparams; td_type; td_pos = _; td_constraint = _; td_vis = _}  ->
-      let root = Typing_deps.Dep.Class type_name in
+     let root = (Typing_deps.Dep.Class type_name, None) in
       let env = SMap.empty in
       let pos = Reason.to_pos (fst td_type) in
       let reason_covariant = [pos, Rtypedef, Pcovariant] in
@@ -437,11 +454,32 @@ and type_ tcopt root variance env (reason, ty) =
     let env = type_option tcopt root variance env ty2 in
     env
   | Tthis ->
-      (* `this` constraints are bivariant (otherwise any class that used the
-       * `this` type would not be able to use covariant type params) *)
-      env
-  | Tgeneric (name, _) ->
-      let pos = Reason.to_pos reason in
+    (* Check that 'this' isn't being improperly referenced in a contravariant
+     * position.
+     *)
+    Option.value_map
+      (snd root)
+      ~default:()
+      ~f:(check_final_this_pos_variance variance (Reason.to_pos reason)) ;
+    (* With the exception of the above check, `this` constraints are bivariant
+     * (otherwise any class that used the `this` type would not be able to use
+     * covariant type params).
+     *)
+    env
+  | Tgeneric (name, constraints) ->
+     let pos = Reason.to_pos reason in
+     (* As above for 'Tthis', if 'this' appears in any constraints on the type,
+      * check that it's being referenced in a proper position.
+      *)
+     List.iter constraints begin fun (_, (r, _ as ty))  ->
+        match ty with
+        | (_, Tthis) ->
+           Option.value_map
+             (snd root)
+             ~default:()
+             ~f: (check_final_this_pos_variance variance (Reason.to_pos r))
+        | _ -> ()
+      end ;
       (* This section makes the position more precise.
        * Say we find a return type that is a tuple (int, int, T).
        * The whole tuple is in covariant position, and so the position
@@ -458,8 +496,7 @@ and type_ tcopt root variance env (reason, ty) =
             Vcontravariant ((pos, x, y) :: rest)
         | x -> x
       in
-      let env = add_variance env name variance in
-      env
+      add_variance env name variance
   | Toption ty ->
       type_ tcopt root variance env ty
   | Tprim _ -> env
diff --git a/hphp/hack/src/utils/collections/myMap.ml b/hphp/hack/src/utils/collections/myMap.ml
index 601b8e5..3ec8b94 100644
--- a/hphp/hack/src/utils/collections/myMap.ml
+++ b/hphp/hack/src/utils/collections/myMap.ml
@@ -8,42 +8,7 @@
  *
  *)
 
-module type S = sig
-  type +'a t
-  type key
-
-  val empty: 'a t
-  val singleton: key -> 'a -> 'a t
-  val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
-  val exists: (key -> 'a -> bool) -> 'a t -> bool
-  val for_all: (key -> 'a -> bool) -> 'a t -> bool
-  val mem: key -> 'a t -> bool
-  val add: key -> 'a -> 'a t -> 'a t
-  val get: key -> 'a t -> 'a option
-  val iter: (key -> 'a -> unit) -> 'a t -> unit
-  val remove: key -> 'a t -> 'a t
-  val map: ('a -> 'b) -> 'a t -> 'b t
-  val mapi: (key -> 'a -> 'b) -> 'a t -> 'b t
-  val find_unsafe: key -> 'a t -> 'a
-  val is_empty: 'a t -> bool
-  val union: 'a t -> 'a t -> 'a t
-  val partition: (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
-  val cardinal : 'a t -> int
-  val compare: 'a t -> 'a t -> int
-  val equal: 'a t -> 'a t -> bool
-  val filter: (key -> 'a -> bool) -> 'a t -> 'a t
-  val merge : (key -> 'a option -> 'b option -> 'c option)
-    -> 'a t -> 'b t -> 'c t
-  val choose : 'a t -> key * 'a
-  val split: key -> 'a t -> 'a t * 'a option * 'a t
-  val keys: 'a t -> key list
-  val values: 'a t -> 'a list
-  val min_binding : 'a t -> key * 'a
-
-  val map_env: ('c -> 'a -> 'c * 'b) -> 'c -> 'a t -> 'c * 'b t
-  val elements: 'a t -> (key * 'a) list
-end
-
+module type S = MyMap_sig.S
 module Make(Ord: Map.OrderedType) : S with type key = Ord.t = struct
   include Map.Make(Ord)
   let get x t =
diff --git a/hphp/hack/src/utils/collections/myMap.mli b/hphp/hack/src/utils/collections/myMap.mli
index e893804..96d469f 100644
--- a/hphp/hack/src/utils/collections/myMap.mli
+++ b/hphp/hack/src/utils/collections/myMap.mli
@@ -8,40 +8,6 @@
  *
  *)
 
-module type S = sig
-  type +'a t
-  type key
-
-  val empty: 'a t
-  val singleton: key -> 'a -> 'a t
-  val fold: (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
-  val exists: (key -> 'a -> bool) -> 'a t -> bool
-  val for_all: (key -> 'a -> bool) -> 'a t -> bool
-  val mem: key -> 'a t -> bool
-  val add: key -> 'a -> 'a t -> 'a t
-  val get: key -> 'a t -> 'a option
-  val iter: (key -> 'a -> unit) -> 'a t -> unit
-  val remove: key -> 'a t -> 'a t
-  val map: ('a -> 'b) -> 'a t -> 'b t
-  val mapi: (key -> 'a -> 'b) -> 'a t -> 'b t
-  val find_unsafe: key -> 'a t -> 'a
-  val is_empty: 'a t -> bool
-  val union: 'a t -> 'a t -> 'a t
-  val partition: (key -> 'a -> bool) -> 'a t -> 'a t * 'a t
-  val cardinal : 'a t -> int
-  val compare: 'a t -> 'a t -> int
-  val equal: 'a t -> 'a t -> bool
-  val filter: (key -> 'a -> bool) -> 'a t -> 'a t
-  val merge : (key -> 'a option -> 'b option -> 'c option)
-    -> 'a t -> 'b t -> 'c t
-  val choose : 'a t -> key * 'a
-  val split: key -> 'a t -> 'a t * 'a option * 'a t
-  val keys: 'a t -> key list
-  val values: 'a t -> 'a list
-  val min_binding : 'a t -> key * 'a
-
-  val map_env: ('c -> 'a -> 'c * 'b) -> 'c -> 'a t -> 'c * 'b t
-  val elements: 'a t -> (key * 'a) list
-end
-
+module type S = MyMap_sig.S
 module Make (Ord : Map.OrderedType) : S with type key = Ord.t
+
diff --git a/hphp/hack/src/utils/collections/myMap_sig.ml b/hphp/hack/src/utils/collections/myMap_sig.ml
new file mode 100644
index 0000000..38ffb5c
--- /dev/null
+++ b/hphp/hack/src/utils/collections/myMap_sig.ml
@@ -0,0 +1,23 @@
+(**
+ * Copyright (c) 2015, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+module type S = sig
+  include Map.S
+
+  val get: key -> 'a t -> 'a option
+  val find_unsafe: key -> 'a t -> 'a
+  val union: 'a t -> 'a t -> 'a t
+  val compare: 'a t -> 'a t -> int
+  val equal: 'a t -> 'a t -> bool
+  val keys: 'a t -> key list
+  val values: 'a t -> 'a list
+  val elements: 'a t -> (key * 'a) list
+  val map_env: ('c -> 'a -> 'c * 'b) -> 'c -> 'a t -> 'c * 'b t
+end
diff --git a/hphp/hack/src/utils/collections/reordered_argument_collections.ml b/hphp/hack/src/utils/collections/reordered_argument_collections.ml
index 190f8c8..c007eb7 100644
--- a/hphp/hack/src/utils/collections/reordered_argument_collections.ml
+++ b/hphp/hack/src/utils/collections/reordered_argument_collections.ml
@@ -14,8 +14,13 @@ module Reordered_argument_map (S : MyMap.S) = struct
   let filter m ~f = filter f m
   let fold m ~init ~f = fold f m init
   let get m k = get k m
+  let find_unsafe m k = find_unsafe k m
   let iter m ~f = iter f m
   let map m ~f = map f m
+  let mem m v = mem v m
+  let remove m v = remove v m
+  let exists m ~f = exists f m
+  let merge m1 m2 ~f = merge f m1 m2
 end
 
 module Reordered_argument_set (S : Set.S) = struct
@@ -25,6 +30,8 @@ module Reordered_argument_set (S : Set.S) = struct
   let fold s ~init ~f = fold f s init
   let iter s ~f = iter f s
   let mem s v = mem v s
+  let remove s v = remove v s
+  let exists s ~f = exists f s
 end
 
 module SSet = Reordered_argument_set(SSet)
diff --git a/hphp/hack/src/utils/diagnostic_subscription.ml b/hphp/hack/src/utils/diagnostic_subscription.ml
deleted file mode 100644
index 508d1ba..0000000
--- a/hphp/hack/src/utils/diagnostic_subscription.ml
+++ /dev/null
@@ -1,36 +0,0 @@
-(**
- * Copyright (c) 2015, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the "hack" directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- *
- *)
-
- type t = {
-   id : int option;
- }
-
-let empty = {
-  id = None;
-}
-
-let of_id ~id = {
-  id = Some id;
-}
-
-let is_empty ds =
-  match ds.id with
-  | Some _ -> false
-  | None -> true
-
-let get_id ds =
-  match ds.id with
-  | Some x -> x
-  | None -> 0
-
-let unsubscribe ds id =
-  match ds.id with
-  | Some x when x = id -> empty
-  | _ -> ds
diff --git a/hphp/hack/src/utils/diagnostic_subscription.mli b/hphp/hack/src/utils/diagnostic_subscription.mli
deleted file mode 100644
index f8b6a41..0000000
--- a/hphp/hack/src/utils/diagnostic_subscription.mli
+++ /dev/null
@@ -1,21 +0,0 @@
-(**
- * Copyright (c) 2015, Facebook, Inc.
- * All rights reserved.
- *
- * This source code is licensed under the BSD-style license found in the
- * LICENSE file in the "hack" directory of this source tree. An additional grant
- * of patent rights can be found in the PATENTS file in the same directory.
- *
- *)
-
-type t
-
-val empty : t
-
-val of_id : id:int -> t
-
-val is_empty : t -> bool
-
-val get_id : t -> int
-
-val unsubscribe : t -> int -> t
diff --git a/hphp/hack/src/utils/disk/disk.ml b/hphp/hack/src/utils/disk/disk.ml
new file mode 100644
index 0000000..8f8f885
--- /dev/null
+++ b/hphp/hack/src/utils/disk/disk.ml
@@ -0,0 +1,8 @@
+module Stub = struct
+  let cat = TestDisk.get
+end
+
+include (val (if Injector_config.use_test_stubbing
+  then (module Stub : Disk_sig.S)
+  else (module RealDisk : Disk_sig.S)
+))
diff --git a/hphp/hack/src/utils/disk/disk.mli b/hphp/hack/src/utils/disk/disk.mli
new file mode 100644
index 0000000..04fb804
--- /dev/null
+++ b/hphp/hack/src/utils/disk/disk.mli
@@ -0,0 +1 @@
+include Disk_sig.S
diff --git a/hphp/hack/src/utils/disk/disk_sig.ml b/hphp/hack/src/utils/disk/disk_sig.ml
new file mode 100644
index 0000000..7f2c4cf
--- /dev/null
+++ b/hphp/hack/src/utils/disk/disk_sig.ml
@@ -0,0 +1,3 @@
+module type S = sig
+  val cat : string -> string
+end
diff --git a/hphp/hack/src/utils/disk/realDisk.ml b/hphp/hack/src/utils/disk/realDisk.ml
new file mode 100644
index 0000000..d45ff34
--- /dev/null
+++ b/hphp/hack/src/utils/disk/realDisk.ml
@@ -0,0 +1,8 @@
+let cat filename =
+  let ic = open_in_bin filename in
+  let len = in_channel_length ic in
+  let buf = Buffer.create len in
+  Buffer.add_channel buf ic len;
+  let content = Buffer.contents buf in
+  close_in ic;
+  content
diff --git a/hphp/hack/src/utils/disk/testDisk.ml b/hphp/hack/src/utils/disk/testDisk.ml
new file mode 100644
index 0000000..03a26d6
--- /dev/null
+++ b/hphp/hack/src/utils/disk/testDisk.ml
@@ -0,0 +1,4 @@
+let files = ref SMap.empty
+
+let get x = SMap.find_unsafe x !files
+let set x y = files := SMap.add x y !files
diff --git a/hphp/hack/src/utils/disk/testDisk.mli b/hphp/hack/src/utils/disk/testDisk.mli
new file mode 100644
index 0000000..69474a4
--- /dev/null
+++ b/hphp/hack/src/utils/disk/testDisk.mli
@@ -0,0 +1,2 @@
+val get : string -> string
+val set : string -> string -> unit
diff --git a/hphp/hack/src/utils/errors.ml b/hphp/hack/src/utils/errors.ml
index a8d2066..1ecf16a 100644
--- a/hphp/hack/src/utils/errors.ml
+++ b/hphp/hack/src/utils/errors.ml
@@ -58,6 +58,22 @@ module Common = struct
   let get_lazy_decl_flag err_flags =
     err_flags.lazy_decl_err
 
+  (* Log important data if lazy_decl triggers a crash *)
+  let lazy_decl_error_logging error error_list to_absolute to_string =
+    (* Print the current error list, which should be empty *)
+    Printf.eprintf "%s" "Error list(should be empty):\n";
+    List.iter !error_list ~f:(fun err ->
+        let msg = err |> to_absolute |> to_string in Printf.eprintf "%s\n" msg);
+    Printf.eprintf "%s" "Offending error:\n";
+    Printf.eprintf "%s" error;
+
+    (* Print out a larger stack trace *)
+    Printf.eprintf "%s" "Callstack:\n";
+    Printf.eprintf "%s" (Printexc.raw_backtrace_to_string
+      (Printexc.get_callstack 500));
+    (* Exit with special error code so we can see the log after *)
+    Exit_status.exit Exit_status.Lazy_decl_bug
+
   (*****************************************************************************)
   (* Error code printing. *)
   (*****************************************************************************)
@@ -120,16 +136,6 @@ module NonTracingErrors: Errors_modes = struct
   let in_lazy_decl = ref false
   let has_lazy_decl_error = ref false
 
-  let add_error error =
-    if !accumulate_errors then
-      begin
-        error_list := error :: !error_list;
-        has_lazy_decl_error := !has_lazy_decl_error || !in_lazy_decl
-      end
-    else
-      (* We have an error, but haven't handled it in any way *)
-      assert_false_log_backtrace ()
-
   let try_with_result f1 f2 =
     Common.try_with_result f1 f2 error_list accumulate_errors
 
@@ -184,6 +190,19 @@ module NonTracingErrors: Errors_modes = struct
       Pos.compare (get_pos x) (get_pos y)
     end err
 
+  let add_error error =
+    if !accumulate_errors then
+      begin
+        error_list := error :: !error_list;
+        has_lazy_decl_error := !has_lazy_decl_error || !in_lazy_decl
+      end
+    else
+      (* We have an error, but haven't handled it in any way *)
+      let msg = error |> to_absolute |> to_string in
+      if !in_lazy_decl then
+        Common.lazy_decl_error_logging msg error_list to_absolute to_string
+      else assert_false_log_backtrace (Some msg)
+
 end
 
 (** Errors with backtraces embedded. They are revealed with to_string. *)
@@ -200,16 +219,6 @@ module TracingErrors: Errors_modes = struct
   let in_lazy_decl = ref false
   let has_lazy_decl_error = ref false
 
-  let add_error error =
-    if !accumulate_errors then
-      begin
-        error_list := error :: !error_list;
-        has_lazy_decl_error := !has_lazy_decl_error || !in_lazy_decl
-      end
-    else
-    (* We have an error, but haven't handled it in any way *)
-      assert_false_log_backtrace ()
-
   let try_with_result f1 f2 =
     Common.try_with_result f1 f2 error_list accumulate_errors
 
@@ -266,6 +275,19 @@ module TracingErrors: Errors_modes = struct
     );
     Buffer.contents buf
 
+  let add_error error =
+    if !accumulate_errors then
+      begin
+        error_list := error :: !error_list;
+        has_lazy_decl_error := !has_lazy_decl_error || !in_lazy_decl
+      end
+    else
+    (* We have an error, but haven't handled it in any way *)
+      let msg = error |> to_absolute |> to_string in
+      if !in_lazy_decl then
+        Common.lazy_decl_error_logging msg error_list to_absolute to_string
+      else assert_false_log_backtrace (Some msg)
+
   let get_sorted_error_list (err,_) =
     List.sort ~cmp:begin fun x y ->
       Pos.compare (get_pos x) (get_pos y)
@@ -432,6 +454,7 @@ module Naming                               = struct
   let invalid_instanceof                    = 2067 (* DONT MODIFY!!!! *)
   let name_is_reserved                      = 2068 (* DONT MODIFY!!!! *)
   let dollardollar_unused                   = 2069 (* DONT MODIFY!!!! *)
+  let illegal_member_variable_class         = 2070 (* DONT MODIFY!!!! *)
 
   (* EXTEND HERE WITH NEW VALUES IF NEEDED *)
 end
@@ -627,6 +650,7 @@ module Typing                               = struct
   let unification_cycle                     = 4155 (* DONT MODIFY!!!! *)
   let keyset_set                            = 4156 (* DONT MODIFY!!!! *)
   let eq_incompatible_types                 = 4157 (* DONT MODIFY!!!! *)
+  let contravariant_this                    = 4158 (* DONT MODIFY!!!! *)
   (* EXTEND HERE WITH NEW VALUES IF NEEDED *)
 end
 
@@ -902,6 +926,12 @@ let illegal_fun pos =
     "literal string representing a valid function name." in
   add Naming.illegal_fun pos msg
 
+let illegal_member_variable_class pos =
+  let msg = "Cannot declare a constant named 'class'. \
+             The name 'class' is reserved for the class \
+             constant that represents the name of the class" in
+  add Naming.illegal_member_variable_class pos msg
+
 let illegal_meth_fun pos =
   let msg = "String argument to fun() contains ':';"^
     " for static class methods, use"^
@@ -1906,6 +1936,12 @@ let declared_contravariant pos1 pos2 emsg =
  ] @ emsg
  )
 
+let contravariant_this pos class_name tp =
+  add Typing.contravariant_this pos (
+    "The \"this\" type cannot be used in this " ^
+    "contravariant position because its enclosing class \"" ^ class_name ^
+    "\" " ^ "is final and has a variant type parameter \"" ^ tp ^ "\"")
+
 let cyclic_typeconst pos sl =
   let sl = List.map sl strip_ns in
   add Typing.cyclic_typeconst pos
@@ -1957,7 +1993,7 @@ let should_be_override pos class_id id =
 let override_per_trait class_name id m_pos =
     let c_pos, c_name = class_name in
     let err_msg =
-      ("Method "^(Utils.strip_ns c_name)^"::"^id^" is should be an override \
+      ("Method "^(Utils.strip_ns c_name)^"::"^id^" should be an override \
         per the declaring trait; no non-private parent definition found \
         or overridden parent is defined in non-<?hh code")
     in add_list Typing.override_per_trait [
@@ -2095,7 +2131,7 @@ let invalid_classname p =
 
 let illegal_type_structure pos errmsg =
   let msg =
-    "The two arguments to typc_structure() must be:"
+    "The two arguments to type_structure() must be:"
     ^"\n - first: ValidClassname::class or an object of that class"
     ^"\n - second: a single-quoted string literal containing the name"
     ^" of a type constant of that class"
diff --git a/hphp/hack/src/utils/errors_sig.ml b/hphp/hack/src/utils/errors_sig.ml
index 379cdea..2e1acb3 100644
--- a/hphp/hack/src/utils/errors_sig.ml
+++ b/hphp/hack/src/utils/errors_sig.ml
@@ -77,6 +77,7 @@ module type S = sig
   val dynamic_method_call : Pos.t -> unit
   val nullsafe_property_write_context : Pos.t -> unit
   val illegal_fun : Pos.t -> unit
+  val illegal_member_variable_class : Pos.t -> unit
   val illegal_meth_fun : Pos.t -> unit
   val illegal_inst_meth : Pos.t -> unit
   val illegal_meth_caller : Pos.t -> unit
@@ -207,6 +208,7 @@ module type S = sig
   val option_mixed : Pos.t -> unit
   val declared_covariant : Pos.t -> Pos.t -> (Pos.t * string) list -> unit
   val declared_contravariant : Pos.t -> Pos.t -> (Pos.t * string) list -> unit
+  val contravariant_this: Pos.t -> string -> string -> unit
   val wrong_extend_kind : Pos.t -> string -> Pos.t -> string -> unit
   val unsatisfied_req : Pos.t -> string -> Pos.t -> unit
   val cyclic_class_def : SSet.t -> Pos.t -> unit
diff --git a/hphp/hack/src/utils/exit_status.ml b/hphp/hack/src/utils/exit_status.ml
index 1497b77..dfe4b2d 100644
--- a/hphp/hack/src/utils/exit_status.ml
+++ b/hphp/hack/src/utils/exit_status.ml
@@ -47,7 +47,9 @@ type t =
   | IDE_typechecker_died
   | Redecl_heap_overflow
   | Out_of_shared_memory
+  | Hash_table_full
   | IDE_persistent_client_already_exists
+  | Lazy_decl_bug
 
 exception Exit_with of t
 
@@ -71,6 +73,7 @@ let exit_code = function
   | Lock_stolen -> 11
   | Lost_parent_monitor -> 12
   | Out_of_shared_memory -> 15
+  | Hash_table_full -> 16
   | Interrupted -> -6
   | Missing_hhi -> 97
   | Socket_error -> 98
@@ -91,6 +94,7 @@ let exit_code = function
   | IDE_init_failure -> 205
   | IDE_typechecker_died -> 206
   | IDE_persistent_client_already_exists -> 207
+  | Lazy_decl_bug -> 208
 
 
 let exit t =
@@ -136,8 +140,11 @@ let to_string = function
   | IDE_typechecker_died -> "IDE_typechecker_died"
   | Redecl_heap_overflow -> "Redecl_heap_overflow"
   | Out_of_shared_memory -> "Out_of_shared_memory"
+  | Hash_table_full -> "Hash_table_full"
   | IDE_persistent_client_already_exists ->
     "IDE_persistent_client_already_exists"
+  | Lazy_decl_bug -> "Lazy_decl_bug"
+
 
 let unpack = function
   | Unix.WEXITED n -> "exit", n
diff --git a/hphp/hack/src/utils/file_content.ml b/hphp/hack/src/utils/file_content.ml
index 49d1dbf..b3d5a47 100644
--- a/hphp/hack/src/utils/file_content.ml
+++ b/hphp/hack/src/utils/file_content.ml
@@ -34,12 +34,8 @@ let of_content ~content = {
   content;
 }
 
-let get_time t = t.time
-
 let get_content t = t.content
 
-let being_edited t = Unix.gettimeofday () -. t.time < 0.5
-
 let nth_line lines n =
   match List.nth lines n with
   | Some s -> s
diff --git a/hphp/hack/src/utils/file_content.mli b/hphp/hack/src/utils/file_content.mli
index 788ef04..29e2843 100644
--- a/hphp/hack/src/utils/file_content.mli
+++ b/hphp/hack/src/utils/file_content.mli
@@ -25,10 +25,6 @@ type code_edit = {
 
 val of_content : content:string -> t
 
-val get_time : t -> float
-
 val get_content : t -> string
 
-val being_edited : t -> bool
-
 val edit_file : t -> code_edit list -> t
diff --git a/hphp/hack/src/utils/measure.ml b/hphp/hack/src/utils/measure.ml
index 6c6a6c8..52dfcd9 100644
--- a/hphp/hack/src/utils/measure.ml
+++ b/hphp/hack/src/utils/measure.ml
@@ -246,7 +246,9 @@ let pretty_num f =
   then Printf.sprintf "%.3fM" (f /. 1000000.0)
   else if f > 1000.0
   then Printf.sprintf "%.3fK" (f /. 1000.0)
-  else Printf.sprintf "%d" (int_of_float f)
+  else if f = (floor f)
+  then Printf.sprintf "%d" (int_of_float f)
+  else Printf.sprintf "%f" f
 
 let print_entry_stats ?record name =
   let record = get_record record in
diff --git a/hphp/hack/src/utils/relative_path.ml b/hphp/hack/src/utils/relative_path.ml
index 6101a46..5abe68c 100644
--- a/hphp/hack/src/utils/relative_path.ml
+++ b/hphp/hack/src/utils/relative_path.ml
@@ -86,7 +86,7 @@ let create prefix s =
   if not (string_starts_with s prefix_s)
   then begin
     Printf.eprintf "%s is not a prefix of %s" prefix_s s;
-    assert_false_log_backtrace ();
+    assert_false_log_backtrace None;
   end;
   prefix, Representation.from (
     String.sub s prefix_len (String.length s - prefix_len))
diff --git a/hphp/hack/src/utils/sys_utils.ml b/hphp/hack/src/utils/sys_utils.ml
index 4528e2a..1ae961b 100644
--- a/hphp/hack/src/utils/sys_utils.ml
+++ b/hphp/hack/src/utils/sys_utils.ml
@@ -10,6 +10,8 @@
 
 open Core
 
+exception NotADirectory of string
+
 external realpath: string -> string option = "hh_realpath"
 external is_nfs: string -> bool = "hh_is_nfs"
 
@@ -76,14 +78,7 @@ let close_out_no_fail fn oc =
     Printf.fprintf stderr "Could not close: '%s' (%s)\n" fn e;
     exit 3
 
-let cat filename =
-  let ic = open_in_bin filename in
-  let len = in_channel_length ic in
-  let buf = Buffer.create len in
-  Buffer.add_channel buf ic len;
-  let content = Buffer.contents buf in
-  close_in ic;
-  content
+let cat = Disk.cat
 
 let cat_no_fail filename =
   let ic = open_in_bin_no_fail filename in
@@ -288,6 +283,14 @@ let try_touch ~follow_symlinks file =
   with _ ->
     ()
 
+let rec mkdir_p = function
+  | "" -> failwith "Unexpected empty directory, should never happen"
+  | d when not (Sys.file_exists d) ->
+    mkdir_p (Filename.dirname d);
+    Unix.mkdir d 0o770;
+  | d when Sys.is_directory d -> ()
+  | d -> raise (NotADirectory d)
+
 (* Emulate "mkdir -p", i.e., no error if already exists. *)
 let mkdir_no_fail dir =
   with_umask 0 begin fun () ->
diff --git a/hphp/hack/src/utils/tty.ml b/hphp/hack/src/utils/tty.ml
index 514fc96..f1b1a02 100644
--- a/hphp/hack/src/utils/tty.ml
+++ b/hphp/hack/src/utils/tty.ml
@@ -72,7 +72,7 @@ let style_num = function
   | NormalWithBG (text, bg) -> (text_num text) ^ ";" ^ (background_num bg)
   | BoldWithBG (text, bg) -> (text_num text) ^ ";" ^ (background_num bg) ^ ";1"
 
-let print_one ?(color_mode=Color_Auto) c s =
+let print_one ?(color_mode=Color_Auto) ?(out_channel=stdout) c s =
   let should_color = match color_mode with
     | Color_Always -> true
     | Color_Never -> false
@@ -84,14 +84,14 @@ let print_one ?(color_mode=Color_Auto) c s =
             Unix.isatty Unix.stdout && term <> "dumb"
       end in
   if should_color
-  then Printf.printf "\x1b[%sm%s\x1b[0m" (style_num c) (s)
-  else Printf.printf "%s" s
+  then Printf.fprintf out_channel "\x1b[%sm%s\x1b[0m" (style_num c) (s)
+  else Printf.fprintf out_channel "%s" s
 
-let cprint ?(color_mode=Color_Auto) strs =
-  List.iter strs (fun (c, s) -> print_one ~color_mode c s)
+let cprint ?(color_mode=Color_Auto) ?(out_channel=stdout) strs =
+  List.iter strs (fun (c, s) -> print_one ~color_mode ~out_channel c s)
 
-let cprintf ?(color_mode=Color_Auto) c =
-  Printf.ksprintf (print_one ~color_mode c)
+let cprintf ?(color_mode=Color_Auto) ?(out_channel=stdout) c =
+  Printf.ksprintf (print_one ~color_mode ~out_channel c)
 
 let (spinner, spinner_used) =
   let state = ref 0 in
diff --git a/hphp/hack/src/utils/tty.mli b/hphp/hack/src/utils/tty.mli
index 4be36f6..27c5668 100644
--- a/hphp/hack/src/utils/tty.mli
+++ b/hphp/hack/src/utils/tty.mli
@@ -35,11 +35,11 @@ type color_mode =
   | Color_Auto
 
 (*
- * Print a sequence of colorized strings to stdout, using ANSI color escapes
- * codes.
+ * Print a sequence of colorized strings to stdout/stderr, using ANSI color
+ * escapes codes.
  *)
-val cprint : ?color_mode:color_mode -> (style * string) list -> unit
-val cprintf : ?color_mode:color_mode -> style ->
+val cprint : ?color_mode:color_mode -> ?out_channel:out_channel -> (style * string) list -> unit
+val cprintf : ?color_mode:color_mode -> ?out_channel:out_channel -> style ->
   ('a, unit, string, unit) format4 -> 'a
 
 (* These two functions provide a four-state TTY-friendly spinner that
diff --git a/hphp/hack/src/utils/utils.ml b/hphp/hack/src/utils/utils.ml
index 7eee8b7..9277049 100644
--- a/hphp/hack/src/utils/utils.ml
+++ b/hphp/hack/src/utils/utils.ml
@@ -172,7 +172,9 @@ let with_context ~enter ~exit ~do_ =
  * performance doesn't matter) we do want the backtrace. "assert false" is one
  * of such conditions.
  *)
-let assert_false_log_backtrace () =
+let assert_false_log_backtrace msg =
+  Printf.eprintf "assert false with backtrace:\n";
+  Option.iter msg ~f:(Printf.eprintf "%s\n");
   Printf.eprintf "%s" (Printexc.raw_backtrace_to_string
     (Printexc.get_callstack 100));
   assert false
diff --git a/hphp/hack/test/find_refs/global_const.flags b/hphp/hack/test/find_refs/global_const.flags
new file mode 100644
index 0000000..558161a
--- /dev/null
+++ b/hphp/hack/test/find_refs/global_const.flags
@@ -0,0 +1 @@
+6 6
diff --git a/hphp/hack/test/find_refs/global_const.php b/hphp/hack/test/find_refs/global_const.php
new file mode 100644
index 0000000..1d66c2b
--- /dev/null
+++ b/hphp/hack/test/find_refs/global_const.php
@@ -0,0 +1,7 @@
+<?hh
+
+const FOO = "string"
+
+function test() {
+  FOO;
+}
diff --git a/hphp/hack/test/find_refs/global_const.php.exp b/hphp/hack/test/find_refs/global_const.php.exp
new file mode 100644
index 0000000..2f1162b
--- /dev/null
+++ b/hphp/hack/test/find_refs/global_const.php.exp
@@ -0,0 +1 @@
+FOO File "global_const.php", line 6, characters 3-5:
diff --git a/hphp/hack/test/full_fidelity/cases/test_array_key_value_precedence.exp b/hphp/hack/test/full_fidelity/cases/test_array_key_value_precedence.exp
index f27284e..ec0c351 100644
--- a/hphp/hack/test/full_fidelity/cases/test_array_key_value_precedence.exp
+++ b/hphp/hack/test/full_fidelity/cases/test_array_key_value_precedence.exp
@@ -10,7 +10,7 @@
 prefix_unary_operator((whitespace)
 (await)(whitespace))
 (binary_operator(variable((variable)(whitespace)))
-((->)(whitespace))
+((.)(whitespace))
 (array_intrinsic_expression(
 (array)(whitespace))
 ((lparen))
diff --git a/hphp/hack/test/full_fidelity/cases/test_array_key_value_precedence.php b/hphp/hack/test/full_fidelity/cases/test_array_key_value_precedence.php
index 37a5421..dcadab0 100644
--- a/hphp/hack/test/full_fidelity/cases/test_array_key_value_precedence.php
+++ b/hphp/hack/test/full_fidelity/cases/test_array_key_value_precedence.php
@@ -1,4 +1,4 @@
 <?hh
 function f(){
-  await $x -> array ($a => b *= 1);
+  await $x . array ($a => b *= 1);
 }
diff --git a/hphp/hack/test/full_fidelity/cases/test_function_call.exp b/hphp/hack/test/full_fidelity/cases/test_function_call.exp
index 76df654..ff9a8a9 100644
--- a/hphp/hack/test/full_fidelity/cases/test_function_call.exp
+++ b/hphp/hack/test/full_fidelity/cases/test_function_call.exp
@@ -13,10 +13,10 @@ qualified_name((whitespace)(name)))
 ((lparen))(variable((variable)))((rparen)))
 ((;)(end_of_line)))
 (expression_statement(
-binary_operator(
+member_selection_expression(
 function_call_expression(
 qualified_name((whitespace)(name)))((lparen))(missing)((rparen)(whitespace)))
-((->)(whitespace))(qualified_name((name))))
+((->)(whitespace))((name)))
 ((;)(end_of_line)))
 (expression_statement(binary_operator(
 function_call_expression(
diff --git a/hphp/hack/test/full_fidelity/cases/test_inclusion_directive.exp b/hphp/hack/test/full_fidelity/cases/test_inclusion_directive.exp
new file mode 100644
index 0000000..09d9fb4
--- /dev/null
+++ b/hphp/hack/test/full_fidelity/cases/test_inclusion_directive.exp
@@ -0,0 +1,52 @@
+(script(header((<))((?))((name)(end_of_line)))
+(namespace_declaration
+((namespace)(whitespace))
+((name)(whitespace))
+(namespace_body(({)(end_of_line))
+(list
+(inclusion_directive
+((whitespace)(include)(whitespace))
+(missing)
+(literal
+((single_quoted_string_literal)))
+(missing)
+((;)(end_of_line)))
+(inclusion_directive
+((whitespace)(include_once)(whitespace))
+(missing)
+(literal((single_quoted_string_literal)))
+(missing)((;)(end_of_line)))
+(inclusion_directive
+((whitespace)(require)(whitespace))
+(missing)
+(literal((single_quoted_string_literal)))
+(missing)((;)
+(end_of_line)))
+(inclusion_directive
+((whitespace)
+(require_once)(whitespace))(missing)
+(literal
+((single_quoted_string_literal)))(missing)
+((;)(end_of_line)))
+(inclusion_directive
+((whitespace)(include)(whitespace))
+((lparen))
+(literal((single_quoted_string_literal)))
+((rparen))((;)(end_of_line)))
+(inclusion_directive((whitespace)
+(include_once)(whitespace))
+((lparen))
+(literal((single_quoted_string_literal)))
+((rparen))((;)(end_of_line)))
+(inclusion_directive
+((whitespace)(require)(whitespace))
+((lparen))
+(literal((single_quoted_string_literal)))
+((rparen))
+((;)(end_of_line)))
+(inclusion_directive
+((whitespace)
+(require_once)(whitespace))
+((lparen))
+(literal((single_quoted_string_literal)))
+((rparen))((;)(end_of_line))))((})))))
diff --git a/hphp/hack/test/full_fidelity/cases/test_inclusion_directive.php b/hphp/hack/test/full_fidelity/cases/test_inclusion_directive.php
new file mode 100644
index 0000000..8a5b2ad
--- /dev/null
+++ b/hphp/hack/test/full_fidelity/cases/test_inclusion_directive.php
@@ -0,0 +1,11 @@
+<?hh
+namespace N {
+  include 's';
+  include_once 'd';
+  require 's';
+  require_once 'd';
+  include ('s');
+  include_once ('d');
+  require ('s');
+  require_once ('d');
+}
diff --git a/hphp/hack/test/full_fidelity/cases/test_list_precedence.exp b/hphp/hack/test/full_fidelity/cases/test_list_precedence.exp
index e691941..2af3751 100644
--- a/hphp/hack/test/full_fidelity/cases/test_list_precedence.exp
+++ b/hphp/hack/test/full_fidelity/cases/test_list_precedence.exp
@@ -36,13 +36,13 @@ variable((variable)(whitespace)))
 ((=)(whitespace))
 (literal((decimal_literal))))
 ((,)(whitespace)))
-(list_item(
-binary_operator(
-prefix_unary_operator(
+(list_item
+(prefix_unary_operator(
 (await)(whitespace))
-(variable((variable)(whitespace))))
+(binary_operator(
+variable((variable)(whitespace)))
 ((=)(whitespace))
-(literal((decimal_literal))))
+(literal((decimal_literal)))))
 (missing)))
 ((rparen)))))
 ((;)(end_of_line))))
diff --git a/hphp/hack/test/full_fidelity/cases/test_statements.exp b/hphp/hack/test/full_fidelity/cases/test_statements.exp
index bbd28c9..078c260 100644
--- a/hphp/hack/test/full_fidelity/cases/test_statements.exp
+++ b/hphp/hack/test/full_fidelity/cases/test_statements.exp
@@ -25,11 +25,11 @@
                         ((whitespace)(case)(whitespace))
                         (literal((decimal_literal)))
                         ((:)(whitespace))
-                        (break_statement((break))((;)(end_of_line))))
+                        (break_statement((break))(missing)((;)(end_of_line))))
                       (default_statement
                         ((whitespace)(default))
                         ((:)(whitespace))
-                        (break_statement((break))((;)(end_of_line)))))
+                        (break_statement((break))(missing)((;)(end_of_line)))))
                     ((whitespace)(})(end_of_line))))
               (missing)
               (else_clause
@@ -59,7 +59,7 @@
                           ((;)(end_of_line))))
                       (continue_statement
                         ((whitespace)(continue))
-                        ((;)(end_of_line))))
+                        (missing)((;)(end_of_line))))
                     ((whitespace)(})(whitespace)))
                   ((while)(whitespace))
                   ((lparen))
diff --git a/hphp/hack/test/full_fidelity/full_fidelity_unit_test.ml b/hphp/hack/test/full_fidelity/full_fidelity_unit_test.ml
index e5cfc45..56e20ea 100644
--- a/hphp/hack/test/full_fidelity/full_fidelity_unit_test.ml
+++ b/hphp/hack/test/full_fidelity/full_fidelity_unit_test.ml
@@ -130,6 +130,7 @@ let minimal_tests =
     "test_type_alias";
     "test_global_constant";
     "test_closure_type";
+    "test_inclusion_directive";
     "test_awaitable_creation";
   ] ~f:mapper
 
diff --git a/hphp/hack/test/h2tp/convert_hack_test_inputs_base.py b/hphp/hack/test/h2tp/convert_hack_test_inputs_base.py
index 0930650..889b438 100644
--- a/hphp/hack/test/h2tp/convert_hack_test_inputs_base.py
+++ b/hphp/hack/test/h2tp/convert_hack_test_inputs_base.py
@@ -410,6 +410,8 @@ OTHER_UNPARSEABLE_FILES = [
     'keyset/must_be_arraykey.php',
     'keyset/unset_on_alias.php',
     'keyset/unset.php',
+    'keyset/is_keyset.php',
+    'keyset/is_keyset_fail.php',
     'dynamic_new1.php',
     'dynamic_new3.php',
     'dynamic_new5.php',
diff --git a/hphp/hack/test/highlight_refs/global_const.flags b/hphp/hack/test/highlight_refs/global_const.flags
new file mode 100644
index 0000000..7dfbee1
--- /dev/null
+++ b/hphp/hack/test/highlight_refs/global_const.flags
@@ -0,0 +1 @@
+4 8
diff --git a/hphp/hack/test/highlight_refs/global_const.php b/hphp/hack/test/highlight_refs/global_const.php
new file mode 100644
index 0000000..46b535e
--- /dev/null
+++ b/hphp/hack/test/highlight_refs/global_const.php
@@ -0,0 +1,8 @@
+<?hh // strict
+// Copyright 2004-present Facebook. All Rights Reserved.
+
+const FOO = "string"
+
+function test() {
+  FOO;
+}
diff --git a/hphp/hack/test/highlight_refs/global_const.php.exp b/hphp/hack/test/highlight_refs/global_const.php.exp
new file mode 100644
index 0000000..5b79f3a
--- /dev/null
+++ b/hphp/hack/test/highlight_refs/global_const.php.exp
@@ -0,0 +1,2 @@
+line 7, characters 3-5
+1 total results
diff --git a/hphp/hack/test/identify_symbol/global_const_assign.php b/hphp/hack/test/identify_symbol/global_const_assign.php
index aa1830f..a2e61f4 100644
--- a/hphp/hack/test/identify_symbol/global_const_assign.php
+++ b/hphp/hack/test/identify_symbol/global_const_assign.php
@@ -1,5 +1,4 @@
 <?hh
 
 const FOO = "string";
-const BAR = FOO; // identifying FOO will not work because we
-                 // don't typecheck global constants in IDE mode
+const BAR = FOO;
diff --git a/hphp/hack/test/identify_symbol/global_const_assign.php.exp b/hphp/hack/test/identify_symbol/global_const_assign.php.exp
index b0047fa..21d5626 100644
--- a/hphp/hack/test/identify_symbol/global_const_assign.php.exp
+++ b/hphp/hack/test/identify_symbol/global_const_assign.php.exp
@@ -1 +1,5 @@
-None
+\FOO
+GlobalConst
+line 4, characters 13-15
+defined: line 3, characters 7-9
+definition span: line 3, character 7 - line 3, character 20
diff --git a/hphp/hack/test/identify_symbol/special_function.php.exp b/hphp/hack/test/identify_symbol/special_function.php.exp
index 2f1fc28..b2724e2 100644
--- a/hphp/hack/test/identify_symbol/special_function.php.exp
+++ b/hphp/hack/test/identify_symbol/special_function.php.exp
@@ -1,5 +1,5 @@
 \meth_caller
 Function
 line 5, characters 5-27
-defined: line 122, characters 10-20
-definition span: line 122, character 1 - line 122, character 58
+defined: line 125, characters 10-20
+definition span: line 125, character 1 - line 125, character 58
diff --git a/hphp/hack/test/incremental/test_inconsistent_state.ml b/hphp/hack/test/incremental/test_inconsistent_state.ml
new file mode 100644
index 0000000..a51c1b8
--- /dev/null
+++ b/hphp/hack/test/incremental/test_inconsistent_state.ml
@@ -0,0 +1,75 @@
+open Integration_test_base_types
+open ServerEnv
+
+module Test = Integration_test_base
+
+let init_disk_changes = [
+"base.php",
+"<?hh // strict
+abstract class Base {
+  public static function meth(): void {}
+}";
+
+"parent.php",
+"<?hh // strict
+abstract class Parent extends Base {
+}";
+
+"achild.php",
+"<?hh // strict
+
+class AChild extends Parent {
+  public static function test(): void {
+    $achild = new self();
+    $achild->__meth();
+  }
+
+  private function __meth(): void {}
+}
+";
+]
+
+let next_disk_changes = [
+
+"base.php",
+"<?hh // strict
+abstract class Base {
+}
+";
+
+"achild.php",
+"<?hh // strict
+
+class AChild extends Parent {
+  public static function test(): void {
+    $achild = new self();
+    $achild->meth();
+  }
+
+  private function meth(): void {}
+}
+";
+
+]
+
+let errors_to_string errors =
+  List.fold_left begin fun str error ->
+    str ^ Errors.(error |> to_absolute |> to_string)
+  end "" @@ errors
+
+let () =
+  let env = Test.setup_server () in
+
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    disk_changes = init_disk_changes;
+  }) in
+  let errors = Errors.get_sorted_error_list env.errorl in
+  if errors <> [] then
+    Test.fail ("Expected no errors. Got:\n" ^ errors_to_string errors);
+
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    disk_changes = next_disk_changes;
+  }) in
+  let errors = Errors.get_sorted_error_list env.errorl in
+  if errors <> [] then
+    Test.fail ("Expected no errors. Got:\n" ^ errors_to_string errors)
diff --git a/hphp/hack/test/incremental/test_method_override.ml b/hphp/hack/test/incremental/test_method_override.ml
new file mode 100644
index 0000000..233d292
--- /dev/null
+++ b/hphp/hack/test/incremental/test_method_override.ml
@@ -0,0 +1,86 @@
+open Integration_test_base_types
+open ServerEnv
+
+module Test = Integration_test_base
+
+let init_base_content = "<?hh // strict
+abstract class Base {
+  public static function meth(int $x): void {}
+}"
+
+let err_base_content = "<?hh // strict
+abstract class Base {
+  public static function meth(): void {}
+}"
+
+let make_disk_changes base_content = [
+"base.php", base_content;
+
+"parent.php",
+"<?hh // strict
+
+abstract class Parent extends Base {
+}";
+
+"child1.php",
+"<?hh // strict
+
+class Child1 extends Parent {
+  public static function meth(int $x): void {}
+
+  public static function callParentMeth(): void {
+    parent::meth(9);
+  }
+}";
+
+"child2.php",
+"<?hh // strict
+
+class Child2 extends Parent {
+  public static function meth(int $x): void {}
+}";
+]
+
+let errors_to_string errors =
+  List.fold_left begin fun str error ->
+    str ^ Errors.(error |> to_absolute |> to_string)
+  end "" @@ errors
+
+let () =
+  let env = Test.setup_server () in
+
+  (* Initially we expect no errors *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    disk_changes = make_disk_changes init_base_content;
+  }) in
+  let errors = Errors.get_sorted_error_list env.errorl in
+  if errors <> [] then
+    Test.fail ("Expected no errors. Got:\n" ^ errors_to_string errors);
+
+  (* We expect errors when we change base.php to err_base_content *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    disk_changes = make_disk_changes err_base_content;
+  }) in
+  let expected_errors = Errors.get_sorted_error_list env.errorl in
+  if expected_errors = [] then
+    Test.fail "Expected there to be errors!";
+
+  (* We reset the disk changes to the initial state. Should be no errors *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    disk_changes = make_disk_changes init_base_content;
+  }) in
+  let errors = Errors.get_sorted_error_list env.errorl in
+  if errors <> [] then
+    Test.fail ("Expected no errors. Got:\n" ^ errors_to_string errors);
+
+  (* We now change only base.php. We expect the same errors as before *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    disk_changes = ["base.php", err_base_content];
+  }) in
+  let incremental_errors = Errors.get_sorted_error_list env.errorl in
+  if incremental_errors <> expected_errors then
+    Test.fail (
+      "Incremental mode gave different errors than a full type check.\n\n" ^
+      "Full Type Check Errors:\n" ^ errors_to_string expected_errors ^ "\n" ^
+      "Incremental Mode Errors:\n" ^ errors_to_string incremental_errors
+    )
diff --git a/hphp/hack/test/integration/common_tests.py b/hphp/hack/test/integration/common_tests.py
index a27da3b..9284ac5 100644
--- a/hphp/hack/test/integration/common_tests.py
+++ b/hphp/hack/test/integration/common_tests.py
@@ -966,175 +966,6 @@ function test2(int $x) { $x = $x*x + 3; return f($x); }
         self.assertEqual(exit_code, 0, msg="Test normal exit status failed")
         self.check_cmd(['No errors!'])
 
-    def test_ide_file_sync(self):
-        """
-        Test ide file sync cmds and autocomplete of "hh_client ide"
-        """
-
-        self.write_load_config()
-        self.check_cmd(['No errors!'])
-        ide_con = self.connect_ide()
-        cmd = (ide_con.open('foo_3.php') +
-                ide_con.edit('foo_3.php', '4', '24', '4', '24', 'some_') +
-                ide_con.auto_complete('foo_3.php', '4', '29') +
-                ide_con.sleep() +
-                ide_con.disconnect())
-        ide_con.write_cmd(cmd)
-        (stdout, _, exit_code) = ide_con.get_return()
-        self.assertEqual(
-            stdout,
-            '{"protocol":"service_framework3_rpc","type":"response","id":789,' +
-            '"result":[{"name":"some_long_function_name","type":"(function():' +
-            ' _)","pos":{"filename":"","line":9,"char_start":18,"char_end":40' +
-            '},"func_details":{"min_arity":0,"return_type":"_","params":[]},"' +
-            'expected_ty":false}]}\n',
-            msg="Autocomplete response content does not match"
-        )
-        self.assertEqual(
-            exit_code,
-            0,
-            msg="Exit status does not match"
-        )
-        self.check_cmd(['{root}foo_3.php:5:9,9: Expected ; (Parsing[1002])'])
-
-    def test_ide_file_sync2(self):
-        """
-        Test ide file sync cmds and autocomplete of "hh_client ide"
-        """
-
-        self.write_load_config()
-        self.check_cmd(['No errors!'])
-        ide_con = self.connect_ide()
-        cmd = (ide_con.open('foo_3.php') +
-                ide_con.edit('foo_3.php', '12', '10', '12', '10', 'function ' +
-                             'some_other_function_name() {}') +
-                ide_con.edit('foo_3.php', '4', '24', '4', '24', 'some_') +
-                ide_con.auto_complete('foo_3.php', '4', '29') +
-                ide_con.sleep() +
-                ide_con.disconnect())
-        ide_con.write_cmd(cmd)
-        (stdout, _, exit_code) = ide_con.get_return()
-        self.assertEqual(
-            stdout,
-            '{"protocol":"service_framework3_rpc","type":"response","id":789,' +
-            '"result":[{"name":"some_long_function_name","type":"(function():' +
-            ' _)","pos":{"filename":"","line":9,"char_start":18,"char_end":40' +
-            '},"func_details":{"min_arity":0,"return_type":"_","params":[]},"' +
-            'expected_ty":false},{"name":"some_other_function_name","type":"(' +
-            'function(): _)","pos":{"filename":"","line":12,"char_start":19,"' +
-            'char_end":42},"func_details":{"min_arity":0,"return_type":"_","p' +
-            'arams":[]},"expected_ty":false}]}\n',
-            msg="Autocomplete response content does not match"
-        )
-        self.assertEqual(
-            exit_code,
-            0,
-            msg="Exit status does not match"
-        )
-        self.check_cmd(['{root}foo_3.php:5:9,9: Expected ; (Parsing[1002])'])
-
-    def test_ide_consistency(self):
-        """
-        Test consistency of ide file sync cmds and autocomplete
-        """
-
-        self.write_load_config()
-        self.check_cmd(['No errors!'])
-        ide_con = self.connect_ide()
-        cmd = (ide_con.open('foo_5.php') +
-                ide_con.edit('foo_5.php', '4', '51', '4', '51',
-                             'public function frob(): void {}') +
-                ide_con.open('foo_4.php') +
-                ide_con.edit('foo_4.php', '4', '30', '4', '30',
-                             '(new ClassToBeIdentified())->') +
-                ide_con.sleep() +
-                ide_con.auto_complete('foo_4.php', '4', '59') +
-                ide_con.disconnect())
-        ide_con.write_cmd(cmd)
-        (stdout, _, exit_code) = ide_con.get_return()
-        self.assertEqualString(
-            stdout,
-            '{{"protocol":"service_framework3_rpc","type":"response","id":789' +
-            ',"result":[{{"name":"frob","type":"(function(): void)","pos":{{"' +
-            'filename":"{root}foo_5.php","line":4,"char_start":67,"char_end":' +
-            '70}},"func_details":{{"min_arity":0,"return_type":"void","params' +
-            '":[]}},"expected_ty":false}}]}}\n',
-            msg="Autocomplete response content does not match"
-        )
-        self.assertEqual(
-            exit_code,
-            0,
-            msg="Exit status does not match"
-        )
-        self.check_cmd([
-            '{root}foo_4.php:4:59,59: Expected expression (Parsing[1002])'])
-
-    def test_ide_consistency_with_errors(self):
-        """
-        Test consistency of ide file sync cmds and autocomplete with errors
-        """
-
-        self.write_load_config()
-        self.check_cmd(['No errors!'])
-        ide_con = self.connect_ide()
-        cmd = (ide_con.open('foo_5.php') +
-                ide_con.edit('foo_5.php', '4', '51', '4', '51',
-                             'public function frob(): void {}thisllcauseerr') +
-                ide_con.open('foo_4.php') +
-                ide_con.edit('foo_4.php', '4', '30', '4', '30',
-                             '(new ClassToBeIdentified())->') +
-                ide_con.sleep() +
-                ide_con.auto_complete('foo_4.php', '4', '59') +
-                ide_con.disconnect())
-        ide_con.write_cmd(cmd)
-        (stdout, _, exit_code) = ide_con.get_return()
-        self.assertEqual(
-            stdout,
-            '{"protocol":"service_framework3_rpc","type":"response","id":789,' +
-            '"result":[]}\n',
-            msg="Autocomplete response content does not match"
-        )
-        self.assertEqual(
-            exit_code,
-            0,
-            msg="Exit status does not match"
-        )
-        self.check_cmd([
-            '{root}foo_4.php:4:59,59: Expected expression (Parsing[1002])',
-            '{root}foo_5.php:4:82,95: Expected modifier (Parsing[1002])'])
-
-    def test_ide_diagnostic_subscription(self):
-        """
-        Test diagnostic subscription of ide connection
-        """
-
-        self.write_load_config()
-        self.check_cmd(['No errors!'])
-        ide_con = self.connect_ide()
-        cmd = (ide_con.subscribe_diagnostic('233') +
-                ide_con.open('foo_5.php') +
-                ide_con.edit('foo_5.php', '4', '51', '4', '51',
-                             'this will cause err') +
-                ide_con.sleep() +
-                ide_con.sleep() +
-                ide_con.disconnect())
-        ide_con.write_cmd(cmd)
-        (stdout, _, exit_code) = ide_con.get_return()
-        self.assertEqualString(
-            stdout,
-            '{{"protocol":"service_framework3_rpc","type":"next","id":233,"er' +
-            'rors":[{{"message":[{{"descr":"Expected modifier","path":"{root}' +
-            'foo_5.php","line":4,"start":51,"end":54,"code":1002}}]}}]}}\n',
-            msg="Diagnostics response does not match"
-        )
-        self.assertEqual(
-            exit_code,
-            0,
-            msg="Exit status does not match"
-        )
-        self.check_cmd([
-            '{root}foo_5.php:4:51,54: Expected modifier (Parsing[1002])'])
-
     def test_ide_highlight_ref(self):
         """
         Test highlight reference for ide files
diff --git a/hphp/hack/test/integration_ml/ide/test_ide_consistency.ml b/hphp/hack/test/integration_ml/ide/test_ide_consistency.ml
new file mode 100644
index 0000000..7d199c3
--- /dev/null
+++ b/hphp/hack/test/integration_ml/ide/test_ide_consistency.ml
@@ -0,0 +1,95 @@
+(**
+ * Copyright (c) 2015, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open Integration_test_base_types
+open ServerCommandTypes
+
+module Test = Integration_test_base
+
+let foo_name = "foo.php"
+
+let foo_contents = "<?hh
+class C {
+  public function foo() {
+
+  }
+}
+"
+
+let foo_contents_with_parse_error = "<?hh
+class C {
+  public function bar() {PARSE_ERROR
+
+  }
+}
+"
+
+let bar_name = "bar.php"
+
+let bar_contents = "<?hh
+function test() {
+  (new C())->f
+}
+"
+
+let run_and_check_autocomplete env =
+  (* Simulate time passing to trigger recheck recheck *)
+  let env = ServerEnv.{ env with last_command_time = 0.0 } in
+
+  let env, loop_output = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (IDE_AUTOCOMPLETE
+      (bar_name, File_content.{line = 3; column = 15})
+    )
+  }) in
+  (match loop_output.persistent_client_response with
+  | Some [x] when x.AutocompleteService.res_name = "foo" -> ()
+  | _ -> Test.fail "Unexpected or missing autocomplete response");
+  env, loop_output
+
+let () =
+
+  let env = Test.setup_server () in
+  let env = Test.connect_persistent_client env in
+
+  (* Create and put content in two files *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (OPEN_FILE foo_name)
+  }) in
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (OPEN_FILE bar_name)
+  }) in
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (EDIT_FILE
+      (foo_name, [File_content.{range = None; text = foo_contents;}])
+    )
+  }) in
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (EDIT_FILE
+      (bar_name, [File_content.{range = None; text = bar_contents;}])
+    )
+  }) in
+
+  (* Check that autocompletions in one file are aware of definitions in
+   * another one*)
+  let env, loop_output = run_and_check_autocomplete env in
+  if loop_output.rechecked_count != 2 then
+    Test.fail "Expected 2 files to be rechecked";
+
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (EDIT_FILE
+      (foo_name, [File_content.{
+        range = None; text = foo_contents_with_parse_error;}])
+    )
+  }) in
+  (* If C had parse errors, we'll not update it's declarations, so
+   * the result will not change *)
+  let _, loop_output = run_and_check_autocomplete env in
+  if loop_output.rechecked_count != 1 then
+    Test.fail "Expected 1 file to be rechecked";
diff --git a/hphp/hack/test/integration_ml/ide/test_ide_diagnostic_subscription.ml b/hphp/hack/test/integration_ml/ide/test_ide_diagnostic_subscription.ml
new file mode 100644
index 0000000..ceb9263
--- /dev/null
+++ b/hphp/hack/test/integration_ml/ide/test_ide_diagnostic_subscription.ml
@@ -0,0 +1,52 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open Integration_test_base_types
+open ServerCommandTypes
+
+module Test = Integration_test_base
+
+let diagnostic_subscription_id = 223
+
+let foo_name = "foo.php"
+
+let foo_contents = "<?hh
+{
+"
+
+let () =
+
+  let env = Test.setup_server () in
+  let env = Test.connect_persistent_client env in
+
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (
+      SUBSCRIBE_DIAGNOSTIC diagnostic_subscription_id
+    )
+  }) in
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (OPEN_FILE foo_name)
+  }) in
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (EDIT_FILE
+      (foo_name, [File_content.{range = None; text = foo_contents;}])
+    )
+  }) in
+  let env = ServerEnv.{ env with last_command_time = 0.0 } in
+  let _, loop_outputs = Test.(run_loop_once env default_loop_input) in
+  match loop_outputs.push_message with
+  | Some (DIAGNOSTIC (id, [error]))
+        when id = diagnostic_subscription_id ->
+      let error = Errors.to_string error in
+      Test.assertEqual
+        ("File \"/foo.php\", line 3, characters 1-0:\n" ^
+        "Expected } (Parsing[1002])\n")
+        error
+  | _ -> Test.fail "Expected push diagnostic with single error"
diff --git a/hphp/hack/test/integration_ml/ide/test_ide_disk.ml b/hphp/hack/test/integration_ml/ide/test_ide_disk.ml
new file mode 100644
index 0000000..f8e9904
--- /dev/null
+++ b/hphp/hack/test/integration_ml/ide/test_ide_disk.ml
@@ -0,0 +1,112 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open Integration_test_base_types
+open ServerCommandTypes
+open ServerEnv
+
+module Test = Integration_test_base
+
+let foo_name = "foo.php"
+
+let foo_no_errors = "<?hh
+function foo() {
+
+}
+"
+
+let foo_with_errors = "<?hh
+{"
+
+let bar_name = "bar.php"
+
+let foo2_definition = "function foo2() {}\n"
+
+let bar_contents = "<?hh
+function test() {
+  fo
+}
+"
+
+let check_has_no_errors env =
+  match Errors.get_error_list env.errorl with
+  | [] -> ()
+  | _ -> Test.fail "Expected to have no errors"
+
+let check_has_errors env =
+  match Errors.get_error_list env.errorl with
+  | [] -> Test.fail "Expected to have errors"
+  | _ -> ()
+
+let () =
+
+  let env = Test.setup_server () in
+  let env = Test.setup_disk env [
+    foo_name, foo_no_errors
+  ] in
+  let env = Test.connect_persistent_client env in
+  (* There are no errors initially *)
+  check_has_no_errors env;
+
+  (* Open pre-existing file in editor *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (OPEN_FILE foo_name)
+  }) in
+
+  (* Update disk contents to contain errors *)
+  let env, loop_output = Test.(run_loop_once env {default_loop_input with
+    disk_changes = [
+      foo_name, foo_with_errors
+    ]
+  }) in
+  assert loop_output.did_read_disk_changes;
+  (* But since file is open in editor, contents from disk are ignored *)
+  check_has_no_errors env;
+
+  (* We edit the file to content with errors *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (EDIT_FILE
+      (foo_name, [File_content.{range = None; text = foo_with_errors;}])
+    )
+  }) in
+  (* Sending a command just schedules a recheck, but it doesn't happen
+   * immediately *)
+  check_has_no_errors env;
+  (* Simulate time passing since last command to trigger a recheck *)
+  let env = { env with last_command_time = 0.0 } in
+  (* Next iteration executes the recheck and generates the errors *)
+  let env, _ = Test.(run_loop_once env default_loop_input) in
+  check_has_errors env;
+
+  (* Edit file back to have no errors *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (EDIT_FILE
+      (foo_name, [File_content.{range = None; text = foo_no_errors;}])
+    )
+  }) in
+  let env = { env with last_command_time = 0.0 } in
+  let env, _ = Test.(run_loop_once env default_loop_input) in
+  check_has_no_errors env;
+  (* We close the file, disk contents should be taken into account again *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (CLOSE_FILE foo_name)
+  }) in
+
+  let env = { env with last_command_time = 0.0 } in
+  (* TODO: this should be unnecessary, closing the file should recheck the disk
+   * contents automatically *)
+  let env, _  = Test.(run_loop_once env {default_loop_input with
+    disk_changes = [
+      foo_name, foo_with_errors
+    ]
+  }) in
+  assert loop_output.did_read_disk_changes;
+  (* Disk errors are now reflected *)
+  check_has_errors env;
diff --git a/hphp/hack/test/integration_ml/ide/test_ide_file_sync.ml b/hphp/hack/test/integration_ml/ide/test_ide_file_sync.ml
new file mode 100644
index 0000000..3a66852
--- /dev/null
+++ b/hphp/hack/test/integration_ml/ide/test_ide_file_sync.ml
@@ -0,0 +1,95 @@
+(**
+ * Copyright (c) 2015, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open Integration_test_base_types
+open ServerCommandTypes
+
+module Test = Integration_test_base
+
+let foo_name = "foo.php"
+
+let foo_no_errors = "<?hh
+function foo() {
+
+}
+"
+
+let foo_with_errors = "<?hh
+{"
+
+let bar_name = "bar.php"
+
+let foo2_definition = "function foo2() {}\n"
+
+let bar_contents = "<?hh
+function test() {
+  fo
+}
+"
+
+let build_code_edit st_line st_column ed_line ed_column text =
+  File_content.{
+    range = Some {
+      st = {
+        line = st_line;
+        column = st_column;
+      };
+      ed = {
+        line = ed_line;
+        column = ed_column;
+      };
+    };
+    text;
+  }
+
+let () =
+
+  let env = Test.setup_server () in
+  let env = Test.setup_disk env [
+    foo_name, foo_no_errors
+  ] in
+  let env = Test.connect_persistent_client env in
+
+  (* Open a new file in editor *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (OPEN_FILE bar_name)
+  }) in
+  (* Start typing in the new file *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (EDIT_FILE
+      (bar_name, [File_content.{range = None; text = bar_contents;}])
+    )
+  }) in
+  (* Request completions *)
+  let env, loop_output = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (IDE_AUTOCOMPLETE
+      (bar_name, File_content.{line = 3; column = 5})
+    )
+  }) in
+  (match loop_output.persistent_client_response with
+  | Some [x] when x.AutocompleteService.res_name = "foo" -> ()
+  | _ -> Test.fail "Unexpected or missing autocomplete response");
+
+  (* Add a new definition to the file *)
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (EDIT_FILE
+      (bar_name, [build_code_edit 2 1 2 1 foo2_definition])
+    )
+  }) in
+
+  (* Check that new definition is among the completions *)
+  let _, loop_output = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some (IDE_AUTOCOMPLETE
+      (bar_name, File_content.{line = 4; column = 5})
+    )
+  }) in
+  (match loop_output.persistent_client_response with
+  | Some [_; _] -> ()
+  | _ -> Test.fail "Expected two completions")
diff --git a/hphp/hack/test/integration_ml/ide/test_identify_symbol.ml b/hphp/hack/test/integration_ml/ide/test_identify_symbol.ml
new file mode 100644
index 0000000..ed8fb37
--- /dev/null
+++ b/hphp/hack/test/integration_ml/ide/test_identify_symbol.ml
@@ -0,0 +1,62 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open Integration_test_base_types
+
+module Test = Integration_test_base
+
+let foo_contents = "<?hh
+
+function foo() {
+
+}
+"
+
+let bar_contents = "<?hh
+
+function test() {
+  foo();
+}"
+
+let identify_foo_request =
+  ServerCommandTypes.IDENTIFY_FUNCTION (bar_contents, 4, 4)
+
+let check_identify_foo_response = function
+  | Some [_, Some def] ->
+    let string_pos = Pos.string def.SymbolDefinition.pos in
+    let expected_pos = "File \"/foo.php\", line 3, characters 10-12:" in
+    Test.assertEqual expected_pos string_pos
+  | _ -> Test.fail "Expected to find exactly one definition"
+
+let () =
+
+  let env = Test.setup_server () in
+  let env = Test.setup_disk env [
+    "foo.php", foo_contents
+  ] in
+
+  let env, loop_output = Test.(run_loop_once env { default_loop_input with
+    new_client = Some (RequestResponse identify_foo_request)
+  }) in
+  check_identify_foo_response loop_output.new_client_response;
+
+  let env, _ = Test.(run_loop_once env { default_loop_input with
+    new_client = Some ConnectPersistent
+  }) in
+
+  (match env.ServerEnv.persistent_client with
+  | Some _ -> ()
+  | None -> Test.fail "Expected persistent client to be connected");
+
+  let _, loop_output = Test.(run_loop_once env { default_loop_input with
+    persistent_client_request = Some identify_foo_request
+  }) in
+
+  check_identify_foo_response loop_output.persistent_client_response
diff --git a/hphp/hack/test/integration_ml/integration_test_base.ml b/hphp/hack/test/integration_ml/integration_test_base.ml
new file mode 100644
index 0000000..134383e
--- /dev/null
+++ b/hphp/hack/test/integration_ml/integration_test_base.ml
@@ -0,0 +1,104 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open Core
+open Integration_test_base_types
+open ServerCommandTypes
+
+let root = "/"
+let stats = ServerMain.empty_stats ()
+let genv = ref ServerEnvBuild.default_genv
+
+let setup_server () =
+  Printexc.record_backtrace true;
+  EventLogger.init (Daemon.devnull ()) 0.0;
+  Relative_path.set_path_prefix Relative_path.Root (Path.make root);
+  HackSearchService.attach_hooks ();
+  let _ = SharedMem.init GlobalConfig.default_sharedmem_config in
+  ServerEnvBuild.make_env !genv.ServerEnv.config
+
+let default_loop_input = {
+  disk_changes = [];
+  new_client = None;
+  persistent_client_request = None;
+}
+
+let run_loop_once env inputs =
+  TestClientProvider.clear();
+  Option.iter inputs.new_client (function
+  | RequestResponse x ->
+    TestClientProvider.mock_new_client_type Non_persistent;
+    TestClientProvider.mock_client_request x
+  | ConnectPersistent ->
+    TestClientProvider.mock_new_client_type Persistent);
+
+  Option.iter inputs.persistent_client_request
+    TestClientProvider.mock_persistent_client_request;
+
+  let client_provider = ClientProvider.provider_for_test () in
+
+  let disk_changes =
+    List.map inputs.disk_changes (fun (x, y) -> root ^ x, y) in
+
+  List.iter disk_changes
+    (fun (path, contents) -> TestDisk.set path contents);
+
+  let did_read_disk_changes_ref = ref false in
+
+  let genv = { !genv with
+    ServerEnv.notifier = begin fun () ->
+      if not !did_read_disk_changes_ref then begin
+        did_read_disk_changes_ref := true;
+        SSet.of_list (List.map disk_changes fst)
+      end else SSet.empty
+    end
+  } in
+
+  let env = ServerMain.serve_one_iteration genv env client_provider stats in
+  env, {
+    did_read_disk_changes = !did_read_disk_changes_ref;
+    rechecked_count = ServerMain.get_rechecked_count stats;
+    new_client_response =
+      TestClientProvider.get_client_response Non_persistent;
+    persistent_client_response =
+      TestClientProvider.get_client_response Persistent;
+    push_message = TestClientProvider.get_push_message ();
+  }
+
+let fail x =
+  print_endline x;
+  exit 1
+
+let assertEqual expected got =
+  if expected <> got then fail
+    (Printf.sprintf "Expected:\n%s\nGot:\n%s\n" expected got)
+
+let setup_disk env disk_changes =
+  let env, loop_output = run_loop_once env { default_loop_input with
+    disk_changes
+  } in
+  if not loop_output.did_read_disk_changes then
+    fail "Expected the server to process disk updates";
+  env
+
+let connect_persistent_client env =
+  let env, _ = run_loop_once env { default_loop_input with
+    new_client = Some ConnectPersistent
+  } in
+  match env.ServerEnv.persistent_client with
+  | Some _ -> env
+  | None -> fail "Expected persistent client to be connected"
+
+let assertSingleError expected err_list =
+  match err_list with
+  | [x] ->
+      let error_string = Errors.(to_string (to_absolute x)) in
+      assertEqual expected error_string
+  | _ -> fail "Expected to have exactly one error"
diff --git a/hphp/hack/test/integration_ml/integration_test_base.mli b/hphp/hack/test/integration_ml/integration_test_base.mli
new file mode 100644
index 0000000..ff0cd75
--- /dev/null
+++ b/hphp/hack/test/integration_ml/integration_test_base.mli
@@ -0,0 +1,26 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open Integration_test_base_types
+
+val setup_server: unit -> ServerEnv.env
+
+val setup_disk: ServerEnv.env -> disk_changes_type -> ServerEnv.env
+
+val connect_persistent_client: ServerEnv.env -> ServerEnv.env
+
+val default_loop_input: ('a, 'b) loop_inputs
+
+val run_loop_once: ServerEnv.env -> ('a, 'b) loop_inputs ->
+  (ServerEnv.env * ('a, 'b) loop_outputs)
+
+val fail: string -> unit
+val assertEqual: string -> string -> unit
+val assertSingleError: string -> Errors.error list -> unit
diff --git a/hphp/hack/test/integration_ml/integration_test_base_types.ml b/hphp/hack/test/integration_ml/integration_test_base_types.ml
new file mode 100644
index 0000000..a69db54
--- /dev/null
+++ b/hphp/hack/test/integration_ml/integration_test_base_types.ml
@@ -0,0 +1,29 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+type 'a new_client_type =
+  | RequestResponse of 'a ServerCommandTypes.t
+  | ConnectPersistent
+
+type disk_changes_type = (string * string) list
+
+type ('a, 'b) loop_inputs = {
+  disk_changes : disk_changes_type;
+  new_client : 'a new_client_type option;
+  persistent_client_request : 'b ServerCommandTypes.t option;
+}
+
+type ('a, 'b) loop_outputs = {
+  did_read_disk_changes : bool;
+  rechecked_count : int;
+  new_client_response : 'a option;
+  persistent_client_response : 'b option;
+  push_message : ServerCommandTypes.push option;
+}
diff --git a/hphp/hack/test/integration_ml/test_delete_file.ml b/hphp/hack/test/integration_ml/test_delete_file.ml
new file mode 100644
index 0000000..360c66c
--- /dev/null
+++ b/hphp/hack/test/integration_ml/test_delete_file.ml
@@ -0,0 +1,46 @@
+(*  Delete a file that still has dangling references *)
+open Integration_test_base_types
+open ServerEnv
+
+module Test = Integration_test_base
+
+let foo_contents = "<?hh //strict
+    class Foo {
+        public static function g(): string {
+            return 'a';
+        }
+    }
+"
+
+let bar_contents = "<?hh //strict
+        function h(): string {
+            return Foo::g();
+        }
+"
+
+let () =
+  let env = Test.setup_server () in
+  let env, loop_output = Test.(run_loop_once env { default_loop_input with
+    disk_changes = [
+      "foo.php", foo_contents;
+      "bar.php", bar_contents;
+    ]
+  }) in
+  if not loop_output.did_read_disk_changes then
+    Test.fail "Expected the server to process disk updates";
+  begin
+    match Errors.get_error_list env.errorl with
+      | [] -> ()
+      | _ -> Test.fail "Expected no errors"
+  end;
+  let env, loop_output = Test.(run_loop_once env { default_loop_input with
+    disk_changes = [
+      "foo.php", "";
+      "bar.php", bar_contents;
+    ]
+  }) in
+  if not loop_output.did_read_disk_changes then
+    Test.fail "Expected the server to process disk updates";
+  let expected_error = "File \"/bar.php\", line 3, characters 20-22:\n" ^
+                       "Unbound name: Foo (an object type) (Naming[2049])\n" in
+  Test.assertSingleError expected_error (Errors.get_error_list env.errorl)
diff --git a/hphp/hack/test/integration_ml/test_duplicate_parent.ml b/hphp/hack/test/integration_ml/test_duplicate_parent.ml
new file mode 100644
index 0000000..c6dfec5
--- /dev/null
+++ b/hphp/hack/test/integration_ml/test_duplicate_parent.ml
@@ -0,0 +1,70 @@
+(*
+  This checks that we handle duplicate parent classes, i.e. when Bar
+  extends Foo and there are two declarations of Foo. We want to make sure
+  that when the duplicate gets removed, we recover correctly by
+  redeclaring Bar with the remaining parent class.
+*)
+open Integration_test_base_types
+open ServerEnv
+
+module Test = Integration_test_base
+
+let foo_contents = "<?hh
+    class Foo {
+        public static $x;
+    }
+"
+
+let qux_contents = "
+<?hh
+function h(): string {
+    return 'a';
+}
+
+class Foo {}
+
+function setUpClass() {
+    new Foo();
+    h();
+}
+"
+
+let bar_contents = "
+<?hh
+      class Bar extends Foo {}
+
+      function main(Bar $a) {
+          return $a::$y;
+      }
+"
+
+let () =
+  let env = Test.setup_server () in
+  let env, loop_output = Test.run_loop_once env {
+    disk_changes = [
+      "foo.php", foo_contents;
+      "qux.php", qux_contents;
+      "bar.php", bar_contents;
+    ];
+    new_client = None;
+    persistent_client_request = None;
+  } in
+
+  if not loop_output.did_read_disk_changes then
+    Test.fail "Expected the server to process disk updates";
+  let bar_error =
+    "File \"/bar.php\", line 6, characters 22-23:\n" ^
+  "Could not find class variable $y in type Bar (Typing[4090])\n" ^
+  "File \"/bar.php\", line 3, characters 13-15:\n" ^
+  "Declaration of Bar is here\n" in
+  let qux_error =
+    "File \"/qux.php\", line 7, characters 7-9:\n" ^
+  "Name already bound: Foo (Naming[2012])\n" ^
+  "File \"/foo.php\", line 2, characters 11-13:\n" ^
+  "Previous definition is here\n" in
+
+  (* We should get exactly these two errors *)
+  match (Errors.get_error_list env.errorl)  with
+  | [x; y;] -> Test.assertSingleError bar_error [x];
+    Test.assertSingleError qux_error [y];
+  | _ -> Test.fail "Expected exactly two errors"
diff --git a/hphp/hack/test/integration_ml/test_duplicated_file.ml b/hphp/hack/test/integration_ml/test_duplicated_file.ml
new file mode 100644
index 0000000..ab76df2
--- /dev/null
+++ b/hphp/hack/test/integration_ml/test_duplicated_file.ml
@@ -0,0 +1,44 @@
+(* Duplicate the same file twice *)
+open Integration_test_base_types
+open ServerEnv
+
+module Test = Integration_test_base
+
+let foo_contents = "<?hh //strict
+    class Foo {
+        public function g(): string {
+            return 'a';
+        }
+    }
+"
+
+
+
+let () =
+  let env = Test.setup_server () in
+  let env, loop_output = Test.(run_loop_once env { default_loop_input with
+    disk_changes = [
+      "foo.php", foo_contents;
+    ]
+  }) in
+  if not loop_output.did_read_disk_changes then
+    Test.fail "Expected the server to process disk updates";
+  begin
+    match Errors.get_error_list env.errorl with
+      | [] -> ()
+      | _ -> Test.fail "Expected no errors"
+  end;
+  let env, loop_output = Test.(run_loop_once env { default_loop_input with
+    disk_changes = [
+      "foo.php", foo_contents;
+      "bar.php", foo_contents;
+    ]
+  }) in
+  if not loop_output.did_read_disk_changes then
+    Test.fail "Expected the server to process disk updates";
+
+  let expected_result = "File \"/foo.php\", line 2, characters 11-13:\n" ^
+                        "Name already bound: Foo (Naming[2012])\n" ^
+                        "File \"/bar.php\", line 2, characters 11-13:\n" ^
+                        "Previous definition is here\n" in
+  Test.assertSingleError expected_result (Errors.get_error_list env.errorl);
diff --git a/hphp/hack/test/integration_ml/test_failed_decl.ml b/hphp/hack/test/integration_ml/test_failed_decl.ml
new file mode 100644
index 0000000..3994f68
--- /dev/null
+++ b/hphp/hack/test/integration_ml/test_failed_decl.ml
@@ -0,0 +1,68 @@
+(*
+When a file generates errors in the decl phase, we make the very
+conservative assumption that we know nothing about its dependencies.
+So we redeclare it every time a file changes, even if the changed file
+is wholly unrelated to the contents of the erroneous file.
+
+I can't actually think of any example where this is necessary, but
+until we have a good argument for why it isn't, it's probably
+reasonable to ensure this behavior is not accidentally broken.
+*)
+open Integration_test_base_types
+open ServerEnv
+
+module Test = Integration_test_base
+
+let foo_contents = "<?hh
+class Foo {
+  public function f() {}
+  public final function g() {}
+}
+"
+
+let baz_contents = "<?hh
+class Baz extends Foo {
+  <<__Override>>
+  public function g() {}
+}
+"
+
+let qux_contents = "<?hh
+class Qux {
+
+}
+"
+
+let () =
+  let env = Test.setup_server () in
+  let env, loop_output = Test.run_loop_once env {
+    disk_changes = [
+      "foo.php", foo_contents;
+      "baz.php", baz_contents;
+    ];
+    new_client = None;
+    persistent_client_request = None;
+  } in
+
+  if not loop_output.did_read_disk_changes then
+    Test.fail "Expected the server to process disk updates";
+  let expected_error =
+    "File \"/baz.php\", line 4, characters 19-19:\n" ^
+    "You cannot override this method (Typing[4070])\n" ^
+    "File \"/foo.php\", line 4, characters 25-25:\n" ^
+    "It was declared as final\n" in
+  Test.assertSingleError expected_error (Errors.get_error_list env.errorl);
+
+  (* Now let's edit a wholly unrelated file *)
+  let env, loop_output = Test.run_loop_once env {
+    disk_changes = [
+      "qux.php", qux_contents;
+    ];
+    new_client = None;
+    persistent_client_request = None;
+  } in
+  if not loop_output.did_read_disk_changes then
+    Test.fail "Expected the server to process disk updates";
+  let path = Relative_path.create Relative_path.Root "/baz.php" in
+  if Relative_path.Set.mem env.failed_decl path then ()
+    else Test.fail "Baz should still have failed declaration"
diff --git a/hphp/hack/test/integration_ml/test_modify_file.ml b/hphp/hack/test/integration_ml/test_modify_file.ml
new file mode 100644
index 0000000..8bab5f0
--- /dev/null
+++ b/hphp/hack/test/integration_ml/test_modify_file.ml
@@ -0,0 +1,46 @@
+open Integration_test_base_types
+open ServerEnv
+
+module Test = Integration_test_base
+
+let foo_contents = "<?hh
+        function g(): string {
+            return 'a';
+        }
+"
+
+let foo_changes = "<?hh
+        function g(): int {
+            return 'a';
+        }
+"
+
+let () =
+  let env = Test.setup_server () in
+  let env, loop_output = Test.(run_loop_once env { default_loop_input with
+    disk_changes = [
+      "foo.php", foo_contents;
+    ]
+  }) in
+  if not loop_output.did_read_disk_changes then
+    Test.fail "Expected the server to process disk updates";
+  begin
+    match Errors.get_error_list env.errorl with
+      | [] -> ()
+      | _ -> Test.fail "Expected no errors"
+  end;
+  let env, loop_output = Test.(run_loop_once env { default_loop_input with
+    disk_changes = [
+      "foo.php", foo_changes;
+    ]
+  }) in
+  if not loop_output.did_read_disk_changes then
+    Test.fail "Expected the server to process disk updates";
+
+  let expected_error = "File \"/foo.php\", line 3, characters 20-22:\n" ^
+                      "Invalid return type (Typing[4110])\n" ^
+                      "File \"/foo.php\", line 2, characters 23-25:\n" ^
+                      "This is an int\n" ^
+                      "File \"/foo.php\", line 3, characters 20-22:\n" ^
+                      "It is incompatible with a string\n" in
+  Test.assertSingleError expected_error (Errors.get_error_list env.errorl);
diff --git a/hphp/hack/test/integration_ml/test_new_file.ml b/hphp/hack/test/integration_ml/test_new_file.ml
new file mode 100644
index 0000000..87d5b8b
--- /dev/null
+++ b/hphp/hack/test/integration_ml/test_new_file.ml
@@ -0,0 +1,34 @@
+(**
+ * Copyright (c) 2016, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ *)
+
+open Integration_test_base_types
+open ServerEnv
+
+module Test = Integration_test_base
+
+let foo_contents = "<?hh
+
+{
+"
+
+let () =
+  let env = Test.setup_server () in
+  let env, loop_output = Test.(run_loop_once env { default_loop_input with
+    disk_changes = [
+      "foo.php", foo_contents
+    ]
+  }) in
+
+  if not loop_output.did_read_disk_changes then
+    Test.fail "Expected the server to process disk updates";
+  let expected_error =
+    "File \"/foo.php\", line 4, characters 1-0:\n" ^
+    "Expected } (Parsing[1002])\n" in
+  Test.assertSingleError expected_error (Errors.get_error_list env.errorl);
diff --git a/hphp/hack/test/typecheck/class_as_class_constant.php b/hphp/hack/test/typecheck/class_as_class_constant.php
new file mode 100644
index 0000000..e2b94cf
--- /dev/null
+++ b/hphp/hack/test/typecheck/class_as_class_constant.php
@@ -0,0 +1,14 @@
+<?hh
+/**
+ * Copyright (c) 2014, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+final class DerpyClass {
+  const class = "derp derp";
+}
diff --git a/hphp/hack/test/typecheck/class_as_class_constant.php.exp b/hphp/hack/test/typecheck/class_as_class_constant.php.exp
new file mode 100644
index 0000000..cc017ff
--- /dev/null
+++ b/hphp/hack/test/typecheck/class_as_class_constant.php.exp
@@ -0,0 +1,2 @@
+File "class_as_class_constant.php", line 13, characters 9-13:
+Cannot declare a constant named 'class'. The name 'class' is reserved for the class constant that represents the name of the class (Naming[2070])
diff --git a/hphp/hack/test/typecheck/class_as_class_constant.php.no_format b/hphp/hack/test/typecheck/class_as_class_constant.php.no_format
new file mode 100644
index 0000000..e69de29
diff --git a/hphp/hack/test/typecheck/class_as_enum_constant.php b/hphp/hack/test/typecheck/class_as_enum_constant.php
new file mode 100644
index 0000000..a40bb77
--- /dev/null
+++ b/hphp/hack/test/typecheck/class_as_enum_constant.php
@@ -0,0 +1,15 @@
+<?hh
+/**
+ * Copyright (c) 2014, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+enum DerpyEnum: string as string {
+  LOL = "haha";
+  Class = "DERP";
+}
diff --git a/hphp/hack/test/typecheck/class_as_enum_constant.php.exp b/hphp/hack/test/typecheck/class_as_enum_constant.php.exp
new file mode 100644
index 0000000..d7c0adb
--- /dev/null
+++ b/hphp/hack/test/typecheck/class_as_enum_constant.php.exp
@@ -0,0 +1,2 @@
+File "class_as_enum_constant.php", line 14, characters 3-7:
+Cannot declare a constant named 'class'. The name 'class' is reserved for the class constant that represents the name of the class (Naming[2070])
diff --git a/hphp/hack/test/typecheck/class_as_enum_constant.php.no_format b/hphp/hack/test/typecheck/class_as_enum_constant.php.no_format
new file mode 100644
index 0000000..e69de29
diff --git a/hphp/hack/test/typecheck/class_as_enum_constant2.php b/hphp/hack/test/typecheck/class_as_enum_constant2.php
new file mode 100644
index 0000000..44d151d
--- /dev/null
+++ b/hphp/hack/test/typecheck/class_as_enum_constant2.php
@@ -0,0 +1,15 @@
+<?hh
+/**
+ * Copyright (c) 2014, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+ */
+
+enum DerpyEnum: string as string {
+  LOL = "haha";
+  class = "DERP";
+}
diff --git a/hphp/hack/test/typecheck/class_as_enum_constant2.php.exp b/hphp/hack/test/typecheck/class_as_enum_constant2.php.exp
new file mode 100644
index 0000000..e445337
--- /dev/null
+++ b/hphp/hack/test/typecheck/class_as_enum_constant2.php.exp
@@ -0,0 +1,2 @@
+File "class_as_enum_constant2.php", line 14, characters 3-7:
+Cannot declare a constant named 'class'. The name 'class' is reserved for the class constant that represents the name of the class (Naming[2070])
diff --git a/hphp/hack/test/typecheck/class_as_enum_constant2.php.no_format b/hphp/hack/test/typecheck/class_as_enum_constant2.php.no_format
new file mode 100644
index 0000000..e69de29
diff --git a/hphp/hack/test/typecheck/contravariant_this1.php b/hphp/hack/test/typecheck/contravariant_this1.php
new file mode 100644
index 0000000..d1dfde7
--- /dev/null
+++ b/hphp/hack/test/typecheck/contravariant_this1.php
@@ -0,0 +1,6 @@
+<?hh // strict
+
+final class C<+T> {
+  public function __construct(private T $v) {}
+  public function put1<Tu super this>(Tu $v): void {}
+}
diff --git a/hphp/hack/test/typecheck/contravariant_this1.php.exp b/hphp/hack/test/typecheck/contravariant_this1.php.exp
new file mode 100644
index 0000000..8b53209
--- /dev/null
+++ b/hphp/hack/test/typecheck/contravariant_this1.php.exp
@@ -0,0 +1,2 @@
+File "contravariant_this1.php", line 5, characters 33-36:
+The "this" type cannot be used in this contravariant position because its enclosing class "C" is final and has a variant type parameter "T" (Typing[4158])
diff --git a/hphp/hack/test/typecheck/contravariant_this2.php b/hphp/hack/test/typecheck/contravariant_this2.php
new file mode 100644
index 0000000..ca42882
--- /dev/null
+++ b/hphp/hack/test/typecheck/contravariant_this2.php
@@ -0,0 +1,6 @@
+<?hh // strict
+
+final class C<+T> {
+  public function __construct(private T $v) {}
+  public function put1(this $v): void {}
+}
diff --git a/hphp/hack/test/typecheck/contravariant_this2.php.exp b/hphp/hack/test/typecheck/contravariant_this2.php.exp
new file mode 100644
index 0000000..644d8d2
--- /dev/null
+++ b/hphp/hack/test/typecheck/contravariant_this2.php.exp
@@ -0,0 +1,2 @@
+File "contravariant_this2.php", line 5, characters 24-27:
+The "this" type cannot be used in this contravariant position because its enclosing class "C" is final and has a variant type parameter "T" (Typing[4158])
diff --git a/hphp/hack/test/typecheck/contravariant_this2.php.out b/hphp/hack/test/typecheck/contravariant_this2.php.out
new file mode 100644
index 0000000..644d8d2
--- /dev/null
+++ b/hphp/hack/test/typecheck/contravariant_this2.php.out
@@ -0,0 +1,2 @@
+File "contravariant_this2.php", line 5, characters 24-27:
+The "this" type cannot be used in this contravariant position because its enclosing class "C" is final and has a variant type parameter "T" (Typing[4158])
diff --git a/hphp/hack/test/typecheck/contravariant_this3.php b/hphp/hack/test/typecheck/contravariant_this3.php
new file mode 100644
index 0000000..cf33c72
--- /dev/null
+++ b/hphp/hack/test/typecheck/contravariant_this3.php
@@ -0,0 +1,11 @@
+<?hh // strict
+
+final class C<-T> {
+  public function __construct(private T $v) {}
+  // We'll raise an error on the use of 'this' in the argument
+  // position, but for now the contravariant reference to 'this'
+  // as the return type is accepted.
+  public function id(this $p): this {
+    return $p;
+  }
+}
diff --git a/hphp/hack/test/typecheck/contravariant_this3.php.exp b/hphp/hack/test/typecheck/contravariant_this3.php.exp
new file mode 100644
index 0000000..aa225b0
--- /dev/null
+++ b/hphp/hack/test/typecheck/contravariant_this3.php.exp
@@ -0,0 +1,2 @@
+File "contravariant_this3.php", line 8, characters 22-25:
+The "this" type cannot be used in this contravariant position because its enclosing class "C" is final and has a variant type parameter "T" (Typing[4158])
diff --git a/hphp/hack/test/typecheck/contravariant_this3.php.format_out b/hphp/hack/test/typecheck/contravariant_this3.php.format_out
new file mode 100644
index 0000000..b05442c
--- /dev/null
+++ b/hphp/hack/test/typecheck/contravariant_this3.php.format_out
@@ -0,0 +1,8 @@
+<?hh // strict
+
+final class C<-T> {
+  public function __construct(private T $v) {}
+  public function id(this $p): this {
+    return $p;
+  }
+}
diff --git a/hphp/hack/test/typecheck/contravariant_this3.php.out b/hphp/hack/test/typecheck/contravariant_this3.php.out
new file mode 100644
index 0000000..aa225b0
--- /dev/null
+++ b/hphp/hack/test/typecheck/contravariant_this3.php.out
@@ -0,0 +1,2 @@
+File "contravariant_this3.php", line 8, characters 22-25:
+The "this" type cannot be used in this contravariant position because its enclosing class "C" is final and has a variant type parameter "T" (Typing[4158])
diff --git a/hphp/hack/test/typecheck/keyset/is_keyset.php b/hphp/hack/test/typecheck/keyset/is_keyset.php
new file mode 100644
index 0000000..938e8b6
--- /dev/null
+++ b/hphp/hack/test/typecheck/keyset/is_keyset.php
@@ -0,0 +1,9 @@
+<?hh
+
+function foo(mixed $m): keyset<arraykey> {
+  if (is_keyset($m)) {
+    return $m;
+  } else {
+    return keyset[];
+  }
+}
diff --git a/hphp/hack/test/typecheck/keyset/is_keyset.php.exp b/hphp/hack/test/typecheck/keyset/is_keyset.php.exp
new file mode 100644
index 0000000..4269126
--- /dev/null
+++ b/hphp/hack/test/typecheck/keyset/is_keyset.php.exp
@@ -0,0 +1 @@
+No errors
diff --git a/hphp/hack/test/typecheck/keyset/is_keyset_fail.php b/hphp/hack/test/typecheck/keyset/is_keyset_fail.php
new file mode 100644
index 0000000..de78551
--- /dev/null
+++ b/hphp/hack/test/typecheck/keyset/is_keyset_fail.php
@@ -0,0 +1,9 @@
+<?hh
+
+function f(mixed $k): keyset<string> {
+  if (is_keyset($k)) {
+    return $k;
+  } else {
+    return keyset[];
+  }
+}
diff --git a/hphp/hack/test/typecheck/keyset/is_keyset_fail.php.exp b/hphp/hack/test/typecheck/keyset/is_keyset_fail.php.exp
new file mode 100644
index 0000000..f81ab32
--- /dev/null
+++ b/hphp/hack/test/typecheck/keyset/is_keyset_fail.php.exp
@@ -0,0 +1,10 @@
+File "is_keyset_fail.php", line 5, characters 12-13:
+Invalid return type (Typing[4110])
+File "is_keyset_fail.php", line 5, characters 12-13:
+Some type constraint(s) here are violated
+File "is_keyset_fail.php", line 4, characters 7-15:
+'Tfresh194' is a constrained type
+File "is_keyset_fail.php", line 3, characters 30-35:
+This is a string
+File "is_keyset_fail.php", line 4, characters 7-15:
+It is incompatible with an array key (int/string) from the condition on the predicate \is_keyset
diff --git a/hphp/hack/test/typecheck/keyset/must_be_arraykey.php.exp b/hphp/hack/test/typecheck/keyset/must_be_arraykey.php.exp
index d315373..61d1d98 100644
--- a/hphp/hack/test/typecheck/keyset/must_be_arraykey.php.exp
+++ b/hphp/hack/test/typecheck/keyset/must_be_arraykey.php.exp
@@ -1,8 +1,8 @@
 File "must_be_arraykey.php", line 5, characters 14-19:
 Some type constraint(s) here are violated (Typing[4110])
-File "builtins.hhi", line 120, characters 29-29:
+File "builtins.hhi", line 123, characters 30-30:
 'T' is a constrained type
-File "builtins.hhi", line 120, characters 34-41:
+File "builtins.hhi", line 123, characters 35-42:
 This is an array key (int/string)
 File "must_be_arraykey.php", line 5, characters 21-21:
 It is incompatible with an object of type I
diff --git a/hphp/hack/test/typecheck/override_attr_08.php.exp b/hphp/hack/test/typecheck/override_attr_08.php.exp
index 2e448bc..e4c5653 100644
--- a/hphp/hack/test/typecheck/override_attr_08.php.exp
+++ b/hphp/hack/test/typecheck/override_attr_08.php.exp
@@ -1,4 +1,4 @@
 File "override_attr_08.php", line 17, characters 7-8:
-Method C1::foo is should be an override per the declaring trait; no non-private parent definition found or overridden parent is defined in non-<?hh code (Typing[4071])
+Method C1::foo should be an override per the declaring trait; no non-private parent definition found or overridden parent is defined in non-<?hh code (Typing[4071])
 File "override_attr_08.php", line 14, characters 19-21:
 Declaration of foo() is here
diff --git a/hphp/hack/test/typecheck/override_attr_09.php.exp b/hphp/hack/test/typecheck/override_attr_09.php.exp
index 3aab480..d35d127 100644
--- a/hphp/hack/test/typecheck/override_attr_09.php.exp
+++ b/hphp/hack/test/typecheck/override_attr_09.php.exp
@@ -1,4 +1,4 @@
 File "override_attr_09.php", line 17, characters 7-8:
-Method C1::foo is should be an override per the declaring trait; no non-private parent definition found or overridden parent is defined in non-<?hh code (Typing[4071])
+Method C1::foo should be an override per the declaring trait; no non-private parent definition found or overridden parent is defined in non-<?hh code (Typing[4071])
 File "override_attr_09.php", line 14, characters 26-28:
 Declaration of foo() is here
diff --git a/hphp/hack/test/typecheck/type_structure/type_structure2.php.exp b/hphp/hack/test/typecheck/type_structure/type_structure2.php.exp
index e5ce265..111029d 100644
--- a/hphp/hack/test/typecheck/type_structure/type_structure2.php.exp
+++ b/hphp/hack/test/typecheck/type_structure/type_structure2.php.exp
@@ -1,4 +1,4 @@
 File "type_structure2.php", line 6, characters 3-26:
 Too few arguments (Typing[4104])
-File "builtins.hhi", line 108, characters 10-23:
+File "builtins.hhi", line 111, characters 10-23:
 Definition is here
diff --git a/hphp/hack/test/typecheck/type_structure/type_structure3.php.exp b/hphp/hack/test/typecheck/type_structure/type_structure3.php.exp
index c0f93a1..65db37a 100644
--- a/hphp/hack/test/typecheck/type_structure/type_structure3.php.exp
+++ b/hphp/hack/test/typecheck/type_structure/type_structure3.php.exp
@@ -1,4 +1,4 @@
 File "type_structure3.php", line 8, characters 3-38:
 Too many arguments (Typing[4105])
-File "builtins.hhi", line 108, characters 10-23:
+File "builtins.hhi", line 111, characters 10-23:
 Definition is here
diff --git a/hphp/hack/test/typecheck/type_structure/type_structure5.php.exp b/hphp/hack/test/typecheck/type_structure/type_structure5.php.exp
index 5ef7b38..e7c1209 100644
--- a/hphp/hack/test/typecheck/type_structure/type_structure5.php.exp
+++ b/hphp/hack/test/typecheck/type_structure/type_structure5.php.exp
@@ -1,5 +1,5 @@
 File "type_structure5.php", line 6, characters 3-16:
-The two arguments to typc_structure() must be:
+The two arguments to type_structure() must be:
  - first: ValidClassname::class or an object of that class
  - second: a single-quoted string literal containing the name of a type constant of that class
 second argument is not a string (Typing[4150])
diff --git a/hphp/hack/test/typecheck/typing_fail_inherit2.php b/hphp/hack/test/typecheck/typing_fail_inherit2.php
index a6289d4..aba25a8 100644
--- a/hphp/hack/test/typecheck/typing_fail_inherit2.php
+++ b/hphp/hack/test/typecheck/typing_fail_inherit2.php
@@ -10,10 +10,10 @@
  */
 
 interface Foo {
-  public function bar() : void { }
+  public function bar() : void;
 }
 
-class Bar implements Foo {
+class Baz implements Foo {
   public static function bar() : void { } // ERROR
   public function bar() : void { }
 }
diff --git a/hphp/hack/test/typed_ast/binary_op.php b/hphp/hack/test/typed_ast/binary_op.php
new file mode 100644
index 0000000..b44369d
--- /dev/null
+++ b/hphp/hack/test/typed_ast/binary_op.php
@@ -0,0 +1,5 @@
+<?hh
+
+function foo(): void {
+  1 + 2;
+}
diff --git a/hphp/hack/test/typed_ast/binary_op.php.exp b/hphp/hack/test/typed_ast/binary_op.php.exp
new file mode 100644
index 0000000..3a92d9e
--- /dev/null
+++ b/hphp/hack/test/typed_ast/binary_op.php.exp
@@ -0,0 +1,8 @@
+|binary_op.php:
+(fun
+ (name: \foo)
+ (body:
+  (stmt
+   ((Tint TPrim) expr binop((Tint TPrim) expr Int)((Tint TPrim) expr Int)))
+  ))
+
diff --git a/hphp/hack/test/typed_ast/class_types.php b/hphp/hack/test/typed_ast/class_types.php
new file mode 100644
index 0000000..9287d25
--- /dev/null
+++ b/hphp/hack/test/typed_ast/class_types.php
@@ -0,0 +1,12 @@
+<?hh
+
+class A {}
+
+class B<T> {}
+
+function bar(A $a, B<A> $b) : void {
+}
+
+function foo(A $a, B<A> $b) : void {
+  bar($a, $b);
+}
diff --git a/hphp/hack/test/typed_ast/class_types.php.exp b/hphp/hack/test/typed_ast/class_types.php.exp
new file mode 100644
index 0000000..98c4a30
--- /dev/null
+++ b/hphp/hack/test/typed_ast/class_types.php.exp
@@ -0,0 +1,13 @@
+|class_types.php:
+(fun
+ (name: \foo)
+ (body:
+  (stmt
+   ((Tvoid TPrim) expr Call(TAny expr Id \bar)((TClass \A < >) expr Lvar -943623712)((TClass \B <(TClass \A < >) >) expr Lvar -1047294126)))
+  ))
+(fun
+ (name: \bar)
+ (body:
+  (stmt other stmt)
+  ))
+
diff --git a/hphp/hack/test/typed_ast/function_call.php b/hphp/hack/test/typed_ast/function_call.php
new file mode 100644
index 0000000..988a655
--- /dev/null
+++ b/hphp/hack/test/typed_ast/function_call.php
@@ -0,0 +1,8 @@
+<?hh
+
+function foo(int $x): void {
+}
+
+function bar(): void {
+  foo(1 + 2);
+}
diff --git a/hphp/hack/test/typed_ast/function_call.php.exp b/hphp/hack/test/typed_ast/function_call.php.exp
new file mode 100644
index 0000000..05716eb
--- /dev/null
+++ b/hphp/hack/test/typed_ast/function_call.php.exp
@@ -0,0 +1,13 @@
+|function_call.php:
+(fun
+ (name: \bar)
+ (body:
+  (stmt
+   ((Tvoid TPrim) expr Call(TAny expr Id \foo)((Tint TPrim) expr binop((Tint TPrim) expr Int)((Tint TPrim) expr Int))))
+  ))
+(fun
+ (name: \foo)
+ (body:
+  (stmt other stmt)
+  ))
+
diff --git a/hphp/hack/test/typed_ast/loop_analysis_aliasing.php b/hphp/hack/test/typed_ast/loop_analysis_aliasing.php
new file mode 100644
index 0000000..dedab04
--- /dev/null
+++ b/hphp/hack/test/typed_ast/loop_analysis_aliasing.php
@@ -0,0 +1,14 @@
+<?hh // strict
+
+function loop(int $i) : void {
+  $x = 2;
+  while($i-- > 0) {
+    // Loop analysis here sees different types for the expression "$x"
+    // on different passes - The TAST sees only the overall union type.
+    $y = $x;
+    if ($i > 10) {
+      $x = "hello";
+    }
+    $y; // This expression has a union type.
+  }
+}
diff --git a/hphp/hack/test/typed_ast/loop_analysis_aliasing.php.exp b/hphp/hack/test/typed_ast/loop_analysis_aliasing.php.exp
new file mode 100644
index 0000000..84e71f4
--- /dev/null
+++ b/hphp/hack/test/typed_ast/loop_analysis_aliasing.php.exp
@@ -0,0 +1,22 @@
+|loop_analysis_aliasing.php:
+(fun
+ (name: \loop)
+ (body:
+  (stmt
+   ((Tint TPrim) expr binop(TAny expr Lvar 5)((Tint TPrim) expr Int)))
+  (stmt(While
+    ((Tbool TPrim) expr binop((TUnion(Tint TPrim)) expr other)((Tint TPrim) expr Int))
+    (stmt
+     ((TUnion(Tstring TPrim)(Tint TPrim)) expr binop(TAny expr Lvar 6)((TUnion(Tstring TPrim)(Tint TPrim)) expr Lvar 5)))
+    (stmt(If
+      ((Tbool TPrim) expr binop((TUnion(Tint TPrim)) expr Lvar -25481132)((Tint TPrim) expr Int))
+      (stmt
+       ((Tstring TPrim) expr binop(TAny expr Lvar 5)((Tstring TPrim) expr other)))
+      
+      (stmt other stmt)
+      ))
+    (stmt
+     ((TUnion(Tstring TPrim)(Tint TPrim)) expr Lvar 6))
+    ))
+  ))
+
diff --git a/hphp/hack/test/typed_ast/null_type.php b/hphp/hack/test/typed_ast/null_type.php
new file mode 100644
index 0000000..ff3b07f
--- /dev/null
+++ b/hphp/hack/test/typed_ast/null_type.php
@@ -0,0 +1,14 @@
+<?hh // strict
+
+class MyClass {
+}
+
+function bar(?MyClass $arg) : void {
+}
+
+function foo() : void {
+  $x = null;
+  bar($x);
+  $x = new MyClass();
+  bar($x);
+}
diff --git a/hphp/hack/test/typed_ast/null_type.php.exp b/hphp/hack/test/typed_ast/null_type.php.exp
new file mode 100644
index 0000000..96c3a42
--- /dev/null
+++ b/hphp/hack/test/typed_ast/null_type.php.exp
@@ -0,0 +1,19 @@
+|null_type.php:
+(fun
+ (name: \foo)
+ (body:
+  (stmt
+   (TNull expr binop(TAny expr Lvar 4)(TNull expr other)))
+  (stmt
+   ((Tvoid TPrim) expr Call(TAny expr Id \bar)(TNull expr Lvar 4)))
+  (stmt
+   (TNotImpl expr binop(TAny expr Lvar 4)(TNotImpl expr other)))
+  (stmt
+   ((Tvoid TPrim) expr Call(TAny expr Id \bar)(TNotImpl expr Lvar 4)))
+  ))
+(fun
+ (name: \bar)
+ (body:
+  (stmt other stmt)
+  ))
+
diff --git a/hphp/hack/test/typed_ast/prim_unresolved.php b/hphp/hack/test/typed_ast/prim_unresolved.php
new file mode 100644
index 0000000..10680e1
--- /dev/null
+++ b/hphp/hack/test/typed_ast/prim_unresolved.php
@@ -0,0 +1,12 @@
+<?hh
+
+function g(arraykey $x) : void {}
+
+function foo(int $x) : void {
+  if ($x > 5) {
+    $y = 1;
+  } else {
+    $y = "hello";
+  }
+  g($y);
+}
diff --git a/hphp/hack/test/typed_ast/prim_unresolved.php.exp b/hphp/hack/test/typed_ast/prim_unresolved.php.exp
new file mode 100644
index 0000000..bb1bf89
--- /dev/null
+++ b/hphp/hack/test/typed_ast/prim_unresolved.php.exp
@@ -0,0 +1,21 @@
+|prim_unresolved.php:
+(fun
+ (name: \foo)
+ (body:
+  (stmt(If
+    ((Tbool TPrim) expr binop((Tint TPrim) expr Lvar -187650736)((Tint TPrim) expr Int))
+    (stmt
+     ((Tint TPrim) expr binop(TAny expr Lvar 4)((Tint TPrim) expr Int)))
+    
+    (stmt
+     ((Tstring TPrim) expr binop(TAny expr Lvar 4)((Tstring TPrim) expr other)))
+    ))
+  (stmt
+   ((Tvoid TPrim) expr Call(TAny expr Id \g)((TUnion(Tint TPrim)(Tstring TPrim)) expr Lvar 4)))
+  ))
+(fun
+ (name: \g)
+ (body:
+  (stmt other stmt)
+  ))
+
diff --git a/hphp/hack/test/unit/heap/test_hashtbl.ml b/hphp/hack/test/unit/heap/test_hashtbl.ml
new file mode 100644
index 0000000..bcad58b
--- /dev/null
+++ b/hphp/hack/test/unit/heap/test_hashtbl.ml
@@ -0,0 +1,209 @@
+(**
+ * Copyright (c) 2015, Facebook, Inc.
+ * All rights reserved.
+ *
+ * This source code is licensed under the BSD-style license found in the
+ * LICENSE file in the "hack" directory of this source tree. An additional grant
+ * of patent rights can be found in the PATENTS file in the same directory.
+ *
+*)
+
+type key = Digest.t
+
+external hh_add    : key -> string -> unit = "hh_add"
+external hh_mem    : key -> bool           = "hh_mem"
+external hh_remove : key-> unit            = "hh_remove"
+external hh_move   : key -> key -> unit    = "hh_move"
+external hh_get    : key -> string         = "hh_get_and_deserialize"
+
+let expect ~msg bool =
+  if bool then () else begin
+    print_endline msg;
+    exit 1
+  end
+
+let to_key = Digest.string
+
+let add key value = hh_add (to_key key) (Marshal.to_string value [])
+let mem key = hh_mem (to_key key)
+let remove key = hh_remove (to_key key)
+let move k1 k2 = hh_move (to_key k1) (to_key k2)
+let get key = hh_get (to_key key)
+
+let expect_stats ~nonempty ~used =
+  let open SharedMem in
+  let expected =
+    { nonempty_slots = nonempty;
+      used_slots = used;
+      slots = 8;
+    } in
+  let {
+    nonempty_slots;
+    used_slots;
+    slots;
+  } = hash_stats () in
+  let expect_equals ~name value expected =
+    expect
+      ~msg:(
+        Printf.sprintf "Expected SharedMem.%s to equal %d, got %d"
+          name expected value
+      )
+      (value = expected)
+  in
+  expect_equals ~name:"nonempty_slots" nonempty_slots expected.nonempty_slots;
+  expect_equals ~name:"used_slots" used_slots expected.used_slots;
+  expect_equals ~name:"slots" slots expected.slots
+
+let expect_mem key =
+  expect ~msg:(Printf.sprintf "Expected key '%s' to be in hashtable" key)
+    @@ mem key
+
+let expect_not_mem key =
+  expect ~msg:(Printf.sprintf "Expected key '%s' to not be in hashtable" key)
+  @@ not (mem key)
+
+let expect_get key expected =
+  let value = get key in
+  expect ~msg:(
+    Printf.sprintf "Expected key '%s' to have value '%s', got '%s"
+      key expected value
+  ) (value = expected)
+
+let test_ops () =
+  expect_stats ~nonempty:0 ~used:0;
+  expect_not_mem "0";
+
+  add "0" "";
+  expect_stats ~nonempty:1 ~used:1;
+  expect_mem "0";
+
+  move "0" "1";
+  expect_stats ~nonempty:2 ~used:1;
+  expect_not_mem "0";
+  expect_mem "1";
+
+  remove "1";
+  expect_stats ~nonempty:2 ~used:0;
+  expect_not_mem "1"
+
+let test_hashtbl_full_hh_add () =
+  expect_stats ~nonempty:0 ~used:0;
+
+  add "0" ""; add "1" ""; add "2" ""; add "3" "";
+  add "4" ""; add "5" ""; add "6" ""; add "7" "";
+
+  expect_stats ~nonempty:8 ~used:8;
+
+  try
+    add "8" "";
+    expect ~msg:"Expected the hash table to be full" false
+  with
+    SharedMem.Hash_table_full -> ()
+
+let test_hashtbl_full_hh_move () =
+  expect_stats ~nonempty:0 ~used:0;
+
+  add "0" ""  ; move "0" "1"; move "1" "2"; move "2" "3";
+  move "3" "4"; move "4" "5"; move "5" "6"; move "6" "7";
+
+  expect_stats ~nonempty:8 ~used:1;
+
+  try
+    move "7" "8";
+    expect ~msg:"Expected the hash table to be full" false
+  with
+    SharedMem.Hash_table_full -> ()
+
+(**
+ * An important property to remember about the shared hash table is if a key
+ * is set, it cannot be overwritten. If you want to associate a key with a new
+ * value, then we need to first remove/move the key and then add the new value.
+ *)
+let test_no_overwrite () =
+  expect_stats ~nonempty:0 ~used:0;
+
+  add "0" "Foo";
+  expect_stats ~nonempty:1 ~used:1;
+  expect_mem "0";
+  expect_get "0" "Foo";
+
+  add "0" "Bar";
+  expect_stats ~nonempty:1 ~used:1;
+  expect_mem "0";
+  expect_get "0" "Foo";
+
+  remove "0";
+  expect_stats ~nonempty:1 ~used:0;
+  expect_not_mem "0";
+
+  add "0" "Bar";
+  expect_stats ~nonempty:1 ~used:1;
+  expect_mem "0";
+  expect_get "0" "Bar"
+
+let test_reuse_slots () =
+  expect_stats ~nonempty:0 ~used:0;
+
+  add "0" "0";
+  add "1" "1";
+  expect_mem "0";
+  expect_mem "1";
+  expect_stats ~nonempty:2 ~used:2;
+
+  (* If we reuse a previously used slot, the number of nonempty slots
+   * stays the same
+   *)
+  remove "1";
+  expect_not_mem "1";
+  expect_stats ~nonempty:2 ~used:1;
+  add "1" "Foo";
+  expect_mem "1";
+  expect_get "1" "Foo";
+  expect_stats ~nonempty:2 ~used:2;
+
+  (* If we move to a previously used slot, nonempty slots stays the same *)
+  remove "1";
+  expect_not_mem "1";
+  expect_stats ~nonempty:2 ~used:1;
+  move "0" "1";
+  expect_not_mem "0";
+  expect_mem "1";
+  expect_get "1" "0";
+  expect_stats ~nonempty:2 ~used:1;
+
+  (* Moving to a brand new key will increase number of nonempty slots *)
+  move "1" "2";
+  expect_not_mem "1";
+  expect_mem "2";
+  expect_get "2" "0";
+  expect_stats ~nonempty:3 ~used:1
+
+let tests () =
+  let list = [
+    "test_ops", test_ops;
+    "test_hashtbl_full_hh_add", test_hashtbl_full_hh_add;
+    "test_hashtbl_full_hh_move", test_hashtbl_full_hh_move;
+    "test_no_overwrite", test_no_overwrite;
+    "test_reuse_slots", test_reuse_slots;
+  ] in
+  let setup_test (name, test) = name, fun () ->
+
+  let handle = SharedMem.(
+      init {
+        global_size = 16;
+        heap_size = 1024;
+        dep_table_pow = 2;
+        hash_table_pow = 3;
+        shm_dirs = [];
+        shm_min_avail = 0;
+        log_level = 0;
+      }
+    ) in
+    SharedMem.connect handle ~is_master:true;
+    test ();
+    true
+  in
+  List.map setup_test list
+
+let () =
+  Unit_test.run_all (tests ())
diff --git a/hphp/hack/test/unit/ide/ide_file_content_test.ml b/hphp/hack/test/unit/ide/ide_file_content_test.ml
index 13d6fc2..4d3fb44 100644
--- a/hphp/hack/test/unit/ide/ide_file_content_test.ml
+++ b/hphp/hack/test/unit/ide/ide_file_content_test.ml
@@ -19,14 +19,6 @@ let test_create () =
   let fc = of_content ~content in
   expect_has_content fc content
 
-let test_being_edited () =
-  let content = "for test\n" in
-  let fc = of_content ~content in
-  let before = being_edited fc in
-  Unix.sleep 1;
-  let after = being_edited fc in
-  before && not after
-
 let test_basic_edit () =
   let content = "for test\n" in
   let fc = of_content ~content in
@@ -49,20 +41,6 @@ let test_basic_edit2 () =
   let edited_fc = edit_file fc [edit] in
   expect_has_content edited_fc "free test\n"
 
-let test_being_edited2 () =
-  let content = "for test\n" in
-  let fc = of_content ~content in
-  Unix.sleep 1;
-  let before = being_edited fc in
-  let edit = {
-    range = Some {
-      st = {line = 1; column = 1};
-      ed = {line = 1; column = 1}};
-    text = "just "} in
-  let edited_fc = edit_file fc [edit] in
-  let after = being_edited edited_fc in
-  not before && after
-
 let test_multi_line_edit () =
   let content = "aaaa\ncccc\n" in
   let fc = of_content ~content in
@@ -125,10 +103,8 @@ let test_invalid_edit () =
 
 let tests = [
   "test_create", test_create;
-  "test_being_edited", test_being_edited;
   "test_basic_edit", test_basic_edit;
   "test_basic_edit2", test_basic_edit2;
-  "test_being_edited2", test_being_edited2;
   "test_multi_line_edit", test_multi_line_edit;
   "test_multi_line_edit2", test_multi_line_edit2;
   "test_special_edit", test_special_edit;
diff --git a/hphp/runtime/base/file-util.cpp b/hphp/runtime/base/file-util.cpp
index 0bc1ed8..8f9086e 100644
--- a/hphp/runtime/base/file-util.cpp
+++ b/hphp/runtime/base/file-util.cpp
@@ -15,6 +15,7 @@
 */
 #include "hphp/runtime/base/file-util.h"
 
+#include <algorithm>
 #include <vector>
 #include <fstream>
 
@@ -34,6 +35,7 @@
 #include "hphp/util/exception.h"
 #include "hphp/util/network.h"
 #include "hphp/util/compatibility.h"
+#include "hphp/util/process.h"
 
 namespace HPHP {
 ///////////////////////////////////////////////////////////////////////////////
@@ -575,6 +577,25 @@ String FileUtil::canonicalize(const char *addpath, size_t addlen,
   return ret;
 }
 
+std::string FileUtil::expandUser(const std::string& path,
+                                 const std::string& sysUser) {
+  if (path.front() != '~') {
+    return path;
+  }
+
+  auto pos = std::min(path.find('/'), path.size());
+  auto user = (pos > 1) ? path.substr(1, pos - 1) : sysUser;
+
+  auto defaultUser = user.empty() || user == Process::GetCurrentUser();
+  auto home = defaultUser ? Process::GetHomeDirectory() : "/home/" + user + "/";
+
+  if (pos + 1 < path.size()) {
+    return home + path.substr(pos + 1);
+  } else {
+    return home;
+  }
+}
+
 std::string FileUtil::normalizeDir(const std::string &dirname) {
   /*
    * normalizeDir may be called before very early one, such as
diff --git a/hphp/runtime/base/file-util.h b/hphp/runtime/base/file-util.h
index 1750900..68ca52c 100644
--- a/hphp/runtime/base/file-util.h
+++ b/hphp/runtime/base/file-util.h
@@ -82,6 +82,8 @@ String canonicalize(const std::string& path);
 String canonicalize(const char* path, size_t len,
                     bool collapse_slashes = true);
 
+std::string expandUser(const std::string& path,
+                       const std::string& sysUser = "");
 /**
  * Makes sure there is ending slash by changing "path/name" to "path/name/".
  */
diff --git a/hphp/runtime/base/header-kind.h b/hphp/runtime/base/header-kind.h
index 72c4270..e26ed83 100644
--- a/hphp/runtime/base/header-kind.h
+++ b/hphp/runtime/base/header-kind.h
@@ -28,10 +28,11 @@ enum class HeaderKind : uint8_t {
   Dict, VecArray, Keyset,
   // Other ordinary refcounted heap objects
   String, Resource, Ref,
-  Object, WaitHandle, ResumableObj, AwaitAllWH,
+  Object, WaitHandle, AsyncFuncWH, AwaitAllWH,
   // Collections
   Vector, Map, Set, Pair, ImmVector, ImmMap, ImmSet,
-  ResumableFrame, // ResumableNode followed by Frame, Resumable, ObjectData
+  // other kinds, not used for countable objects.
+  AsyncFuncFrame, // ResumableNode followed by Frame, Resumable, ObjectData
   NativeData, // a NativeData header preceding an HNI ObjectData
   SmallMalloc, // small req::malloc'd block
   BigMalloc, // big req::malloc'd block
@@ -43,7 +44,7 @@ const unsigned NumHeaderKinds = unsigned(HeaderKind::Hole) + 1;
 extern const char* header_names[];
 
 inline bool haveCount(HeaderKind k) {
-  return uint8_t(k) < uint8_t(HeaderKind::ResumableFrame);
+  return uint8_t(k) < uint8_t(HeaderKind::AsyncFuncFrame);
 }
 
 /*
diff --git a/hphp/runtime/base/heap-collect.cpp b/hphp/runtime/base/heap-collect.cpp
index 02caead..31ccbc6 100644
--- a/hphp/runtime/base/heap-collect.cpp
+++ b/hphp/runtime/base/heap-collect.cpp
@@ -165,7 +165,7 @@ private:
     auto h = reinterpret_cast<const Header*>(p);
     assert(h &&
            h->kind() <= HeaderKind::BigMalloc &&
-           h->kind() != HeaderKind::ResumableFrame &&
+           h->kind() != HeaderKind::AsyncFuncFrame &&
            h->kind() != HeaderKind::NativeData);
     work_.push_back(h);
   }
@@ -194,7 +194,7 @@ inline bool Marker::mark(const void* p, GCBits marks) {
   assert(p && ptrs_.isHeader(p));
   auto h = static_cast<const Header*>(p);
   assert(h->kind() <= HeaderKind::BigMalloc &&
-         h->kind() != HeaderKind::ResumableObj);
+         h->kind() != HeaderKind::AsyncFuncWH);
   auto old_marks = h->hdr_.marks;
   h->hdr_.marks = old_marks | marks;
   return old_marks == GCBits::Unmarked;
@@ -209,17 +209,17 @@ void Marker::operator()(const ObjectData* p) {
   if (!p) return;
   assert(isObjectKind(p->headerKind()));
   auto kind = p->headerKind();
-  if (kind == HeaderKind::ResumableObj) {
-    // Resumable object, prefixed by a ResumableNode header, which is what
-    // we need to mark.
-    // [ResumableNode][locals][Resumable][ObjectData<ResumableObj>]
+  if (kind == HeaderKind::AsyncFuncWH) {
+    // c_AsyncFunctionWaitHandle, prefixed by a ResumableNode header,
+    // which is what we need to mark.
+    // [ResumableNode][locals][Resumable][c_AsyncFunctionWaitHandle]
     auto r = Resumable::FromObj(p);
     auto frame = reinterpret_cast<const TypedValue*>(r) -
                  r->actRec()->func()->numSlotsInFrame();
     auto node = reinterpret_cast<const ResumableNode*>(frame) - 1;
-    assert(node->hdr.kind == HeaderKind::ResumableFrame);
+    assert(node->hdr.kind == HeaderKind::AsyncFuncFrame);
     if (mark(node)) {
-      // mark the ResumableFrame prefix, but enqueue the ObjectData* to scan
+      // mark the AsyncFuncFrame prefix, but enqueue the ObjectData* to scan
       enqueue(p);
     }
     assert(!p->getVMClass()->getNativeDataInfo());
@@ -368,8 +368,8 @@ void Marker::checkedEnqueue(const void* p, GCBits bits) {
       assert(!h->obj_.getAttribute(ObjectData::HasNativeData));
       enqueue(h);
       break;
-    case HeaderKind::ResumableFrame:
-      enqueue(h->resumableObj());
+    case HeaderKind::AsyncFuncFrame:
+      enqueue(h->asyncFuncWH());
       break;
     case HeaderKind::NativeData:
       enqueue(h->nativeObj());
@@ -377,7 +377,7 @@ void Marker::checkedEnqueue(const void* p, GCBits bits) {
     case HeaderKind::String:
       // nothing to queue since strings don't have pointers
       break;
-    case HeaderKind::ResumableObj:
+    case HeaderKind::AsyncFuncWH:
     case HeaderKind::BigObj:
     case HeaderKind::Free:
     case HeaderKind::Hole:
@@ -455,10 +455,10 @@ NEVER_INLINE void Marker::init() {
                "object with NativeData from forEachHeader");
         ptrs_.insert(h);
         break;
-      case HeaderKind::ResumableFrame: {
+      case HeaderKind::AsyncFuncFrame: {
         // Pointers to either the frame or object will be mapped to the frame.
         ptrs_.insert(h);
-        auto obj = reinterpret_cast<const Header*>(h->resumableObj());
+        auto obj = reinterpret_cast<const Header*>(h->asyncFuncWH());
         obj->hdr_.marks = GCBits::Unmarked;
         break;
       }
@@ -477,9 +477,9 @@ NEVER_INLINE void Marker::init() {
           unknown_objects_.emplace_back(h);
         }
         break;
-      case HeaderKind::ResumableObj:
-        // ResumableObj should not be encountered on their own, they should
-        // always be prefixed by a ResumableFrame allocation.
+      case HeaderKind::AsyncFuncWH:
+        // AsyncFuncWH should not be encountered on their own while scanning.
+        // They should always be prefixed by an AsyncFuncFrame allocation.
       case HeaderKind::Free:
       case HeaderKind::Hole:
       case HeaderKind::BigObj:
@@ -598,7 +598,7 @@ DEBUG_ONLY bool check_sweep_header(const Header* h) {
       // objects; should not have native-data
       assert(!h->obj_.getAttribute(ObjectData::HasNativeData));
       break;
-    case HeaderKind::ResumableFrame:
+    case HeaderKind::AsyncFuncFrame:
     case HeaderKind::NativeData:
       // not counted but marked when embedded object is marked
       break;
@@ -610,7 +610,7 @@ DEBUG_ONLY bool check_sweep_header(const Header* h) {
       // free memory; these should not be marked.
       assert(!(h->hdr_.marks & GCBits::Mark));
       break;
-    case HeaderKind::ResumableObj:
+    case HeaderKind::AsyncFuncWH:
     case HeaderKind::BigObj:
     case HeaderKind::Hole:
       // These should never be encountered because they don't represent
@@ -665,7 +665,7 @@ NEVER_INLINE void Marker::sweep() {
       case HeaderKind::ImmVector:
       case HeaderKind::ImmMap:
       case HeaderKind::ImmSet:
-      case HeaderKind::ResumableFrame:
+      case HeaderKind::AsyncFuncFrame:
       case HeaderKind::NativeData: {
         freed_ += h_size;
         auto obj = h->obj();
@@ -693,7 +693,7 @@ NEVER_INLINE void Marker::sweep() {
         // should not be in ptrmap; fall through to assert
       case HeaderKind::Hole:
       case HeaderKind::BigObj:
-      case HeaderKind::ResumableObj:
+      case HeaderKind::AsyncFuncWH:
         assert(false && "skipped by forEachHeader()");
         break;
     }
diff --git a/hphp/runtime/base/heap-graph.cpp b/hphp/runtime/base/heap-graph.cpp
index cdcb1e7..737bd80 100644
--- a/hphp/runtime/base/heap-graph.cpp
+++ b/hphp/runtime/base/heap-graph.cpp
@@ -282,7 +282,7 @@ HeapGraph makeHeapGraph(bool include_free) {
   PtrMap blocks;
 
   // parse the heap once to create a PtrMap for pointer filtering. Create
-  // one node for every parsed block, including NativeData and ResumableFrame
+  // one node for every parsed block, including NativeData and AsyncFuncFrame
   // blocks. Only include free blocks if requested.
   MM().forEachHeader([&](Header* h) {
     if (h->kind() != HeaderKind::Free || include_free) {
diff --git a/hphp/runtime/base/heap-report.cpp b/hphp/runtime/base/heap-report.cpp
index 9ca3359..e7f780d 100644
--- a/hphp/runtime/base/heap-report.cpp
+++ b/hphp/runtime/base/heap-report.cpp
@@ -59,7 +59,7 @@ DEBUG_ONLY std::string describe(const HeapGraph& g, int n) {
       break;
     case HeaderKind::Object:
     case HeaderKind::WaitHandle:
-    case HeaderKind::ResumableObj:
+    case HeaderKind::AsyncFuncWH:
     case HeaderKind::AwaitAllWH:
       out << ":" << h->obj_.classname_cstr();
       break;
@@ -78,7 +78,7 @@ DEBUG_ONLY std::string describe(const HeapGraph& g, int n) {
     case HeaderKind::SmallMalloc:
       out << "[" << h->malloc_.nbytes << "]";
       break;
-    case HeaderKind::ResumableFrame:
+    case HeaderKind::AsyncFuncFrame:
     case HeaderKind::NativeData:
       break;
     case HeaderKind::Free:
diff --git a/hphp/runtime/base/heap-scan.h b/hphp/runtime/base/heap-scan.h
index 4b75897..cdd2022 100644
--- a/hphp/runtime/base/heap-scan.h
+++ b/hphp/runtime/base/heap-scan.h
@@ -76,7 +76,7 @@ template<class F> void scanHeader(const Header* h,
       return h->globals_.scan(mark);
     case HeaderKind::Object:
     case HeaderKind::WaitHandle:
-    case HeaderKind::ResumableObj:
+    case HeaderKind::AsyncFuncWH:
     case HeaderKind::AwaitAllWH:
       return h->obj_.scan(mark);
     case HeaderKind::Pair:
@@ -113,8 +113,8 @@ template<class F> void scanHeader(const Header* h,
       return mark((&h->malloc_)+1, h->malloc_.nbytes - sizeof(MallocNode));
     case HeaderKind::NativeData:
       return h->nativeObj()->scan(mark);
-    case HeaderKind::ResumableFrame:
-      return h->resumableObj()->scan(mark);
+    case HeaderKind::AsyncFuncFrame:
+      return h->asyncFuncWH()->scan(mark);
     case HeaderKind::String:
     case HeaderKind::Free:
       // these don't have pointers. some clients might generically
@@ -129,7 +129,7 @@ template<class F> void scanHeader(const Header* h,
 }
 
 template<class F> void ObjectData::scan(F& mark) const {
-  if (m_hdr.kind == HeaderKind::ResumableObj) {
+  if (m_hdr.kind == HeaderKind::AsyncFuncWH) {
     // scan the frame locals, iterators, and Resumable
     auto r = Resumable::FromObj(this);
     auto frame = reinterpret_cast<const TypedValue*>(r) -
diff --git a/hphp/runtime/base/memory-manager-defs.h b/hphp/runtime/base/memory-manager-defs.h
index 7b42e66..c550cd9 100644
--- a/hphp/runtime/base/memory-manager-defs.h
+++ b/hphp/runtime/base/memory-manager-defs.h
@@ -58,29 +58,29 @@ struct Header {
   }
 
   const Resumable* resumable() const {
-    assert(kind() == HeaderKind::ResumableFrame);
+    assert(kind() == HeaderKind::AsyncFuncFrame);
     return reinterpret_cast<const Resumable*>(
       (char*)this + sizeof(ResumableNode) + resumable_.framesize
     );
   }
   Resumable* resumable() {
-    assert(kind() == HeaderKind::ResumableFrame);
+    assert(kind() == HeaderKind::AsyncFuncFrame);
     return reinterpret_cast<Resumable*>(
       (char*)this + sizeof(ResumableNode) + resumable_.framesize
     );
   }
-  const ObjectData* resumableObj() const {
+  const ObjectData* asyncFuncWH() const {
     DEBUG_ONLY auto const func = resumable()->actRec()->func();
     assert(func->isAsyncFunction());
     auto obj = reinterpret_cast<const ObjectData*>(resumable() + 1);
-    assert(obj->headerKind() == HeaderKind::ResumableObj);
+    assert(obj->headerKind() == HeaderKind::AsyncFuncWH);
     return obj;
   }
-  ObjectData* resumableObj() {
+  ObjectData* asyncFuncWH() {
     DEBUG_ONLY auto const func = resumable()->actRec()->func();
     assert(func->isAsyncFunction());
     auto obj = reinterpret_cast<ObjectData*>(resumable() + 1);
-    assert(obj->headerKind() == HeaderKind::ResumableObj);
+    assert(obj->headerKind() == HeaderKind::AsyncFuncWH);
     return obj;
   }
   const ObjectData* nativeObj() const {
@@ -100,7 +100,7 @@ struct Header {
   // return the (possibly inner ptr) ObjectData*
   const ObjectData* obj() const {
     return isObjectKind(kind()) ? &obj_ :
-           kind() == HeaderKind::ResumableFrame ? resumableObj() :
+           kind() == HeaderKind::AsyncFuncFrame ? asyncFuncWH() :
            kind() == HeaderKind::NativeData ? nativeObj() :
            nullptr;
   }
@@ -151,7 +151,7 @@ inline size_t Header::size() const {
     case HeaderKind::String:
       return str_.heapSize();
     case HeaderKind::Object:
-    case HeaderKind::ResumableObj:
+    case HeaderKind::AsyncFuncWH:
       // [ObjectData][subclass][props]
       return obj_.heapSize();
     case HeaderKind::Vector:
@@ -178,9 +178,8 @@ inline size_t Header::size() const {
     case HeaderKind::BigMalloc:   // [MallocNode][bytes...]
     case HeaderKind::BigObj:      // [MallocNode][Header...]
       return malloc_.nbytes;
-    case HeaderKind::ResumableFrame:
-      // Async functions -
-      // [ResumableNode][locals][Resumable][ObjectData<WaitHandle>]
+    case HeaderKind::AsyncFuncFrame:
+      // [ResumableNode][locals][Resumable][c_AsyncFunctionWaitHandle]
       return resumable()->size();
     case HeaderKind::NativeData:
       // [NativeNode][NativeData][ObjectData][props] is one allocation.
@@ -268,7 +267,7 @@ template<class Fn> void MemoryManager::forEachObject(Fn fn) {
     switch (h->kind()) {
       case HeaderKind::Object:
       case HeaderKind::WaitHandle:
-      case HeaderKind::ResumableObj:
+      case HeaderKind::AsyncFuncWH:
       case HeaderKind::AwaitAllWH:
       case HeaderKind::Vector:
       case HeaderKind::Map:
@@ -279,8 +278,8 @@ template<class Fn> void MemoryManager::forEachObject(Fn fn) {
       case HeaderKind::ImmSet:
         ptrs.push_back(&h->obj_);
         break;
-      case HeaderKind::ResumableFrame:
-        ptrs.push_back(h->resumableObj());
+      case HeaderKind::AsyncFuncFrame:
+        ptrs.push_back(h->asyncFuncWH());
         break;
       case HeaderKind::NativeData:
         ptrs.push_back(h->nativeObj());
diff --git a/hphp/runtime/base/memory-manager.cpp b/hphp/runtime/base/memory-manager.cpp
index 589821a..45a5c79 100644
--- a/hphp/runtime/base/memory-manager.cpp
+++ b/hphp/runtime/base/memory-manager.cpp
@@ -585,9 +585,9 @@ void MemoryManager::flush() {
 const char* header_names[] = {
   "PackedArray", "MixedArray", "EmptyArray", "ApcArray",
   "GlobalsArray", "ProxyArray", "DictArray", "VecArray", "KeysetArray",
-  "String", "Resource", "Ref", "Object", "WaitHandle", "ResumableObj",
+  "String", "Resource", "Ref", "Object", "WaitHandle", "AsyncFuncWH",
   "AwaitAllWH", "Vector", "Map", "Set", "Pair", "ImmVector", "ImmMap", "ImmSet",
-  "ResumableFrame", "NativeData", "SmallMalloc", "BigMalloc", "BigObj",
+  "AsyncFuncFrame", "NativeData", "SmallMalloc", "BigMalloc", "BigObj",
   "Free", "Hole"
 };
 static_assert(sizeof(header_names)/sizeof(*header_names) == NumHeaderKinds, "");
@@ -672,7 +672,7 @@ void MemoryManager::checkHeap(const char* phase) {
       case HeaderKind::Proxy:
       case HeaderKind::Object:
       case HeaderKind::WaitHandle:
-      case HeaderKind::ResumableObj:
+      case HeaderKind::AsyncFuncWH:
       case HeaderKind::AwaitAllWH:
       case HeaderKind::Vector:
       case HeaderKind::Map:
@@ -683,7 +683,7 @@ void MemoryManager::checkHeap(const char* phase) {
       case HeaderKind::ImmSet:
       case HeaderKind::Resource:
       case HeaderKind::Ref:
-      case HeaderKind::ResumableFrame:
+      case HeaderKind::AsyncFuncFrame:
       case HeaderKind::NativeData:
       case HeaderKind::SmallMalloc:
       case HeaderKind::BigMalloc:
diff --git a/hphp/runtime/base/memory-manager.h b/hphp/runtime/base/memory-manager.h
index 103ecd3..9967317 100644
--- a/hphp/runtime/base/memory-manager.h
+++ b/hphp/runtime/base/memory-manager.h
@@ -635,7 +635,7 @@ struct MemoryManager {
    *            call this directly to avoid unnecessary initFree()s.
    * forEachHeader(): Like iterate(), but with an eager initFree().
    * forEachObject(): Iterate just the ObjectDatas, including the kinds with
-   *                  prefixes (NativeData and ResumableFrame).
+   *                  prefixes (NativeData and AsyncFuncFrame).
    */
   void initFree();
   template<class Fn> void iterate(Fn fn);
diff --git a/hphp/runtime/base/runtime-option.cpp b/hphp/runtime/base/runtime-option.cpp
index bc71699..1675cbe 100644
--- a/hphp/runtime/base/runtime-option.cpp
+++ b/hphp/runtime/base/runtime-option.cpp
@@ -556,6 +556,7 @@ int RuntimeOption::DebuggerDefaultRpcTimeout = 30;
 std::string RuntimeOption::DebuggerDefaultSandboxPath;
 std::string RuntimeOption::DebuggerStartupDocument;
 int RuntimeOption::DebuggerSignalTimeout = 1;
+std::string RuntimeOption::DebuggerAuthTokenScript;
 
 std::string RuntimeOption::SendmailPath = "sendmail -t -i";
 std::string RuntimeOption::MailForceExtraParameters;
@@ -1145,6 +1146,8 @@ void RuntimeOption::Load(
                    "Eval.Debugger.RPC.HostDomain");
       Config::Bind(DebuggerDefaultRpcTimeout, ini, config,
                    "Eval.Debugger.RPC.DefaultTimeout", 30);
+      Config::Bind(DebuggerAuthTokenScript, ini, config,
+                   "Eval.Debugger.Auth.TokenScript");
     }
   }
   {
diff --git a/hphp/runtime/base/runtime-option.h b/hphp/runtime/base/runtime-option.h
index 38e9291..a1ea82b 100644
--- a/hphp/runtime/base/runtime-option.h
+++ b/hphp/runtime/base/runtime-option.h
@@ -664,6 +664,7 @@ public:
   static std::string DebuggerDefaultSandboxPath;
   static std::string DebuggerStartupDocument;
   static int DebuggerSignalTimeout;
+  static std::string DebuggerAuthTokenScript;
 
   // Mail options
   static std::string SendmailPath;
diff --git a/hphp/runtime/debugger/cmd/all.h b/hphp/runtime/debugger/cmd/all.h
index ea1a4a9..f4b281d 100644
--- a/hphp/runtime/debugger/cmd/all.h
+++ b/hphp/runtime/debugger/cmd/all.h
@@ -17,6 +17,7 @@
 #ifndef incl_HPHP_EVAL_DEBUGGER_CMD_ALL_H_
 #define incl_HPHP_EVAL_DEBUGGER_CMD_ALL_H_
 
+#include "hphp/runtime/debugger/cmd/cmd_auth.h"
 #include "hphp/runtime/debugger/cmd/cmd_eval.h"
 #include "hphp/runtime/debugger/cmd/cmd_abort.h"
 #include "hphp/runtime/debugger/cmd/cmd_break.h"
diff --git a/hphp/runtime/debugger/cmd/cmd_auth.cpp b/hphp/runtime/debugger/cmd/cmd_auth.cpp
new file mode 100644
index 0000000..7331d77
--- /dev/null
+++ b/hphp/runtime/debugger/cmd/cmd_auth.cpp
@@ -0,0 +1,55 @@
+/*
+   +----------------------------------------------------------------------+
+   | HipHop for PHP                                                       |
+   +----------------------------------------------------------------------+
+   | Copyright (c) 2010-2016 Facebook, Inc. (http://www.facebook.com)     |
+   +----------------------------------------------------------------------+
+   | This source file is subject to version 3.01 of the PHP license,      |
+   | that is bundled with this package in the file LICENSE, and is        |
+   | available through the world-wide-web at the following url:           |
+   | http://www.php.net/license/3_01.txt                                  |
+   | If you did not receive a copy of the PHP license and are unable to   |
+   | obtain it through the world-wide-web, please send a note to          |
+   | license@php.net so we can mail you a copy immediately.               |
+   +----------------------------------------------------------------------+
+*/
+
+#include "hphp/runtime/debugger/cmd/cmd_auth.h"
+
+#include "hphp/runtime/base/file-util.h"
+#include "hphp/runtime/debugger/debugger_client.h"
+#include "hphp/util/process-exec.h"
+#include <string>
+
+namespace HPHP { namespace Eval {
+///////////////////////////////////////////////////////////////////////////////
+
+TRACE_SET_MOD(debugger);
+
+void CmdAuth::sendImpl(DebuggerThriftBuffer& thrift) {
+  DebuggerCommand::sendImpl(thrift);
+  thrift.write(m_token);
+}
+
+void CmdAuth::recvImpl(DebuggerThriftBuffer& thrift) {
+  DebuggerCommand::recvImpl(thrift);
+  thrift.read(m_token);
+}
+
+void CmdAuth::onClient(DebuggerClient& client) {
+  auto path = FileUtil::expandUser(RuntimeOption::DebuggerAuthTokenScript);
+  const char *argv[] = { "", path.data(), nullptr };
+  // We *should* be invoking the file in the same process.
+  if (path.empty() || !proc::exec("php", argv, nullptr, m_token, nullptr)) {
+    m_token.clear();
+  }
+
+  client.sendToServer(this);
+}
+
+bool CmdAuth::onServer(DebuggerProxy& proxy) {
+  return proxy.sendToClient(this);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+}}
diff --git a/hphp/runtime/debugger/cmd/cmd_auth.h b/hphp/runtime/debugger/cmd/cmd_auth.h
new file mode 100644
index 0000000..307fbad
--- /dev/null
+++ b/hphp/runtime/debugger/cmd/cmd_auth.h
@@ -0,0 +1,45 @@
+/*
+   +----------------------------------------------------------------------+
+   | HipHop for PHP                                                       |
+   +----------------------------------------------------------------------+
+   | Copyright (c) 2010-2016 Facebook, Inc. (http://www.facebook.com)     |
+   +----------------------------------------------------------------------+
+   | This source file is subject to version 3.01 of the PHP license,      |
+   | that is bundled with this package in the file LICENSE, and is        |
+   | available through the world-wide-web at the following url:           |
+   | http://www.php.net/license/3_01.txt                                  |
+   | If you did not receive a copy of the PHP license and are unable to   |
+   | obtain it through the world-wide-web, please send a note to          |
+   | license@php.net so we can mail you a copy immediately.               |
+   +----------------------------------------------------------------------+
+*/
+
+#ifndef incl_HPHP_EVAL_DEBUGGER_CMD_AUTH_H_
+#define incl_HPHP_EVAL_DEBUGGER_CMD_AUTH_H_
+
+#include "hphp/runtime/debugger/debugger_command.h"
+#include <string>
+
+namespace HPHP { namespace Eval {
+///////////////////////////////////////////////////////////////////////////////
+
+struct CmdAuth : DebuggerCommand {
+  explicit CmdAuth() : DebuggerCommand(KindOfAuth) {}
+
+  const std::string& getToken() const { return m_token; }
+
+  bool onServer(DebuggerProxy&) override;
+  void onClient(DebuggerClient&) override;
+
+protected:
+  void sendImpl(DebuggerThriftBuffer&) override;
+  void recvImpl(DebuggerThriftBuffer&) override;
+
+private:
+  std::string m_token;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+}}
+
+#endif // incl_HPHP_EVAL_DEBUGGER_CMD_AUTH_H_
diff --git a/hphp/runtime/debugger/debugger_client.cpp b/hphp/runtime/debugger/debugger_client.cpp
index b88f316..9df1ce7 100644
--- a/hphp/runtime/debugger/debugger_client.cpp
+++ b/hphp/runtime/debugger/debugger_client.cpp
@@ -31,6 +31,7 @@
 #include "hphp/runtime/ext/std/ext_std_network.h"
 #include "hphp/runtime/ext/string/ext_string.h"
 #include "hphp/util/logger.h"
+#include "hphp/util/process-exec.h"
 #include "hphp/util/process.h"
 #include "hphp/util/stack-trace.h"
 #include "hphp/util/string-vsnprintf.h"
@@ -759,6 +760,7 @@ void DebuggerClient::run() {
   } else {
     hphp_invoke_simple(m_options.extension, false);
   }
+
   while (true) {
     bool reconnect = false;
     try {
@@ -1102,8 +1104,9 @@ DebuggerCommandPtr DebuggerClient::eventLoop(EventLoopKind loopKind,
         Logger::Error("Unable to communicate with server. Server's down?");
         throw DebuggerServerLostException();
       }
-      if (cmd->is(DebuggerCommand::KindOfSignal)) {
-        // Respond to signal polling from the server.
+      if (cmd->is(DebuggerCommand::KindOfSignal) ||
+          cmd->is(DebuggerCommand::KindOfAuth)) {
+        // Respond to polling from the server.
         cmd->onClient(*this);
         continue;
       }
diff --git a/hphp/runtime/debugger/debugger_command.cpp b/hphp/runtime/debugger/debugger_command.cpp
index 3a94f76..4a9fbd3 100644
--- a/hphp/runtime/debugger/debugger_command.cpp
+++ b/hphp/runtime/debugger/debugger_command.cpp
@@ -148,6 +148,7 @@ bool DebuggerCommand::Receive(DebuggerThriftBuffer& thrift,
     case KindOfEval     : cmd = std::make_shared<CmdEval>(); break;
     case KindOfInterrupt: cmd = std::make_shared<CmdInterrupt>(); break;
     case KindOfSignal   : cmd = std::make_shared<CmdSignal>(); break;
+    case KindOfAuth     : cmd = std::make_shared<CmdAuth>(); break;
     case KindOfShell    : cmd = std::make_shared<CmdShell>(); break;
     case KindOfInternalTesting :
       cmd = std::make_shared<CmdInternalTesting>();
diff --git a/hphp/runtime/debugger/debugger_command.h b/hphp/runtime/debugger/debugger_command.h
index 0cdfd89..3e0bd51 100644
--- a/hphp/runtime/debugger/debugger_command.h
+++ b/hphp/runtime/debugger/debugger_command.h
@@ -90,6 +90,7 @@ struct DebuggerCommand {
     // DebuggerProxy -> DebuggerClient
     KindOfInterrupt           = 10000,
     KindOfSignal              = 10001,
+    KindOfAuth                = 10002,
 
     // Internal testing only
     KindOfInternalTesting     = 20000, // The real test command
diff --git a/hphp/runtime/debugger/debugger_proxy.cpp b/hphp/runtime/debugger/debugger_proxy.cpp
index 1fcd39a..e970d77 100644
--- a/hphp/runtime/debugger/debugger_proxy.cpp
+++ b/hphp/runtime/debugger/debugger_proxy.cpp
@@ -22,6 +22,7 @@
 
 #include <folly/Conv.h>
 
+#include "hphp/runtime/debugger/cmd/cmd_auth.h"
 #include "hphp/runtime/debugger/cmd/cmd_interrupt.h"
 #include "hphp/runtime/debugger/cmd/cmd_flow_control.h"
 #include "hphp/runtime/debugger/cmd/cmd_signal.h"
@@ -803,6 +804,36 @@ Variant DebuggerProxy::ExecutePHP(const std::string &php, String &output,
   return ret;
 }
 
+std::string DebuggerProxy::requestAuthToken() {
+  TRACE_RB(2, "DebuggerProxy::requestauthToken: sending auth request\n");
+  CmdAuth cmd;
+  if (!cmd.onServer(*this)) {
+    TRACE_RB(2, "DebuggerProxy::requestAuthToken: "
+             "Failed to send CmdAuth to client\n");
+    return "";
+  }
+
+  DebuggerCommandPtr res;
+  while (!DebuggerCommand::Receive(m_thrift, res,
+                                   "DebuggerProxy::requestAuthToken()")) {
+    checkStop();
+  }
+  if (!res) {
+    TRACE_RB(2, "DebuggerProxy::requestAuthToken: "
+             "Failed to get CmdAuth back from client\n");
+    return "";
+  }
+
+  auto token = std::dynamic_pointer_cast<CmdAuth>(res);
+  if (!token) {
+    TRACE_RB(2, "DebuggerProxy::requestAuthToken: "
+             "bad response from token request: %d", res->getType());
+    return "";
+  }
+
+  return token->getToken();
+}
+
 int DebuggerProxy::getRealStackDepth() {
   TRACE(2, "DebuggerProxy::getRealStackDepth\n");
   int depth = 0;
diff --git a/hphp/runtime/debugger/debugger_proxy.h b/hphp/runtime/debugger/debugger_proxy.h
index ba1acf0..de20a68 100644
--- a/hphp/runtime/debugger/debugger_proxy.h
+++ b/hphp/runtime/debugger/debugger_proxy.h
@@ -117,6 +117,8 @@ struct DebuggerProxy : Synchronizable,
   Variant ExecutePHP(const std::string &php, String &output, int frame,
                      bool &failed, int flags);
 
+  std::string requestAuthToken();
+
 private:
   bool blockUntilOwn(CmdInterrupt &cmd, bool check);
   bool checkBreakPoints(CmdInterrupt &cmd);
diff --git a/hphp/runtime/debugger/dummy_sandbox.cpp b/hphp/runtime/debugger/dummy_sandbox.cpp
index 313423a..57599ec 100644
--- a/hphp/runtime/debugger/dummy_sandbox.cpp
+++ b/hphp/runtime/debugger/dummy_sandbox.cpp
@@ -24,9 +24,9 @@
 #include "hphp/runtime/server/source-root-info.h"
 #include "hphp/runtime/base/externals.h"
 #include "hphp/runtime/base/php-globals.h"
+#include "hphp/runtime/base/file-util.h"
 
 #include "hphp/util/logger.h"
-#include "hphp/util/process.h"
 
 namespace HPHP { namespace Eval {
 ///////////////////////////////////////////////////////////////////////////////
@@ -177,27 +177,7 @@ std::string DummySandbox::getStartupDoc(const DSandboxInfo &sandbox) {
       path += '/';
     }
     path += m_startupFile;
-
-    // resolving home directory
-    if (path[0] == '~') {
-      std::string user, home;
-      size_t pos = path.find('/');
-      if (pos == std::string::npos) pos = path.size();
-      if (pos > 1) {
-        user = path.substr(1, pos - 1);
-      }
-      if (user.empty()) user = sandbox.m_user;
-      if (user.empty() || user == Process::GetCurrentUser()) {
-        home = Process::GetHomeDirectory();
-      } else {
-        home = "/home/" + user + "/";
-      }
-      if (pos + 1 < path.size()) {
-        path = home + path.substr(pos + 1);
-      } else {
-        path = home;
-      }
-    }
+    path = FileUtil::expandUser(path, sandbox.m_user);
   }
   return path;
 }
diff --git a/hphp/runtime/ext/asio/ext_async-function-wait-handle.h b/hphp/runtime/ext/asio/ext_async-function-wait-handle.h
index a76c60f..e12f80b 100644
--- a/hphp/runtime/ext/asio/ext_async-function-wait-handle.h
+++ b/hphp/runtime/ext/asio/ext_async-function-wait-handle.h
@@ -61,7 +61,7 @@ struct c_AsyncFunctionWaitHandle final : c_ResumableWaitHandle {
 
   explicit c_AsyncFunctionWaitHandle(Class* cls =
       c_AsyncFunctionWaitHandle::classof()) noexcept
-    : c_ResumableWaitHandle(cls, HeaderKind::ResumableObj) {}
+    : c_ResumableWaitHandle(cls, HeaderKind::AsyncFuncWH) {}
   ~c_AsyncFunctionWaitHandle();
 
  public:
diff --git a/hphp/runtime/ext/debugger/ext_debugger.cpp b/hphp/runtime/ext/debugger/ext_debugger.cpp
index df1ea16..5c5425f 100644
--- a/hphp/runtime/ext/debugger/ext_debugger.cpp
+++ b/hphp/runtime/ext/debugger/ext_debugger.cpp
@@ -32,6 +32,7 @@ struct DebuggerExtension final : Extension {
   DebuggerExtension() : Extension("debugger", NO_EXTENSION_VERSION_YET) {}
   void moduleInit() override {
     HHVM_NAMED_FE(__SystemLib\\debugger_get_info, HHVM_FN(debugger_get_info));
+    HHVM_FE(hphpd_auth_token);
     HHVM_FE(hphpd_break);
     HHVM_FE(hphp_debugger_attached);
     loadSystemlib();
@@ -40,6 +41,15 @@ struct DebuggerExtension final : Extension {
 
 ///////////////////////////////////////////////////////////////////////////////
 
+String HHVM_FUNCTION(hphpd_auth_token) {
+  TRACE(5, "in f_hphpd_auth_token()\n");
+  if (auto proxy = Debugger::GetProxy()) {
+    return String(proxy->requestAuthToken());
+  }
+
+  return String();
+}
+
 void HHVM_FUNCTION(hphpd_break, bool condition /* = true */) {
   TRACE(5, "in f_hphpd_break()\n");
   if (!RuntimeOption::EnableDebugger || !condition ||
diff --git a/hphp/runtime/ext/debugger/ext_debugger.h b/hphp/runtime/ext/debugger/ext_debugger.h
index 7ccefc6..6ec9285 100644
--- a/hphp/runtime/ext/debugger/ext_debugger.h
+++ b/hphp/runtime/ext/debugger/ext_debugger.h
@@ -23,6 +23,7 @@
 namespace HPHP {
 ///////////////////////////////////////////////////////////////////////////////
 
+String HHVM_FUNCTION(hphpd_auth_token);
 void HHVM_FUNCTION(hphpd_break, bool condition = true);
 bool HHVM_FUNCTION(hphp_debugger_attached);
 Array HHVM_FUNCTION(debugger_get_info);
diff --git a/hphp/runtime/ext/debugger/ext_debugger.php b/hphp/runtime/ext/debugger/ext_debugger.php
index abb4043..4fd0a84 100644
--- a/hphp/runtime/ext/debugger/ext_debugger.php
+++ b/hphp/runtime/ext/debugger/ext_debugger.php
@@ -14,6 +14,12 @@ namespace __SystemLib {
 
 namespace {
 
+  /* Request authentication token from the client. The token is empty in case of
+   * error.
+   */
+  <<__HipHopSpecific, __Native("NoFCallBuiltin")>>
+  function hphpd_auth_token(): string;
+
   /* Sets a hard breakpoint. When a debugger is running, this line of code will
    * break into debugger, if condition is met. If there is no debugger that's
    * attached, it will not do anything.
diff --git a/hphp/runtime/ext/objprof/ext_heapgraph.cpp b/hphp/runtime/ext/objprof/ext_heapgraph.cpp
index 0abfaad..891d776 100644
--- a/hphp/runtime/ext/objprof/ext_heapgraph.cpp
+++ b/hphp/runtime/ext/objprof/ext_heapgraph.cpp
@@ -251,9 +251,9 @@ std::string getNodesConnectionName(
       // Obvious cases that do not need pointer type
       case HeaderKind::AwaitAllWH:
       case HeaderKind::WaitHandle:
-      case HeaderKind::ResumableObj:
+      case HeaderKind::AsyncFuncWH:
       case HeaderKind::Pair:
-      case HeaderKind::ResumableFrame:
+      case HeaderKind::AsyncFuncFrame:
       case HeaderKind::Set:
       case HeaderKind::ImmSet:
       case HeaderKind::Vector:
diff --git a/hphp/runtime/ext_zend_compat/php-src/ext/standard/basic_functions.h b/hphp/runtime/ext_zend_compat/php-src/ext/standard/basic_functions.h
index 2a66361..6198166 100644
--- a/hphp/runtime/ext_zend_compat/php-src/ext/standard/basic_functions.h
+++ b/hphp/runtime/ext_zend_compat/php-src/ext/standard/basic_functions.h
@@ -115,8 +115,6 @@ PHP_FUNCTION(getprotobynumber);
 
 PHP_NAMED_FUNCTION(php_if_crc32);
 
-PHP_FUNCTION(register_tick_function);
-PHP_FUNCTION(unregister_tick_function);
 #ifdef HAVE_GETLOADAVG
 PHP_FUNCTION(sys_getloadavg);
 #endif
diff --git a/hphp/runtime/vm/resumable.h b/hphp/runtime/vm/resumable.h
index 7b57b30..f518c6c 100644
--- a/hphp/runtime/vm/resumable.h
+++ b/hphp/runtime/vm/resumable.h
@@ -92,7 +92,7 @@ struct alignas(16) Resumable {
     auto resumable = reinterpret_cast<Resumable*>(frame + frameSize);
 
     node->framesize = frameSize;
-    node->hdr.kind = HeaderKind::ResumableFrame;
+    node->hdr.kind = HeaderKind::AsyncFuncFrame;
 
     return resumable;
   }
-- 
2.7.4

